{"pages":[],"posts":[{"title":"Android 7.0 Notification Sound Issue","text":"前言最近遇到一个问题：自定义Notification通知声音(一个外部存储MP3文件)，Android7.0版本上无法正常播放。 分析 查阅代码是否正常执行，setSound是否设置有效Uri正常执行,设置的Uri有效 查看Log发现权限问题相关Log 1MediaPlayer: Couldn&apos;t open content://xxxxxxxx/new_order.mp3: java.lang.SecurityException: Permission Denial: opening provider android.support.v4.content.FileProvider from ProcessRecord{ce87f22 2005:com.android.systemui/u0a18} (pid=2005, uid=10018) that is not exported from uid 10257 传递参数FileProvider Uri，com.android.systemui无访问权限，导致设置的MP3无法播放 adb shell dumpsys notification查看sound是否为设置的Urisound为设置的Uri，正常 解决办法使用grantUriPermissions()12grantUriPermission(\"com.android.systemui\", sound, Intent.FLAG_GRANT_READ_URI_PERMISSION); (这个具体情况可以根据上面分析中的Log确定包名) 使用android.resource假设使用raw资源保存test.mp3文件，然后使用 1Uri uri = Uri.parse(\"android.resource://“+ context.getPackageName() + R.id.test); 1Uri uri = Uri.parse(\"android.resource://“+ context.getPackageName() + \"/raw/test.mp3\"); 禁止严格模式&amp;不使用FileProvider（不推荐）1StrictMode.setVmPolicy(new StrictMode.VmPolicy.Builder().build()); 总结 Android7.0 注意Uri权限问题 Android8.0 注意setSound在NotificationChannel完成 参考 Notifications, Sounds, Android 7.0, and Aggravation Google Issue Tracker Stackoverflow Issue Google Fixed","link":"/2019/01/11/Android 7.0 Notification Sound Issue/"},{"title":"Android Device Monitor启动插件","text":"前言最近使用Android Studio3.3调试应用过程中，需要使用Android Device Monitor，但是界面上找不到入口，印象中之前的版本是存在的。 官方解释： Android Device Monitor was deprecated in Android Studio 3.1 and removed from Android Studio 3.2. The features that you could use through the Android Device Monitor have been replaced by new features. The table below helps you decide which features you should use instead of these deprecated and removed features. 官方准备弃用Android Device Monitor 并推荐开发者使用对应的新特性作为替代品。具体查阅[官网]。(https://developer.android.google.cn/studio/profile/monitor) 对于习惯使用Android Device Monitor的开发者来说，每次都需要目录下触发monitor很不方便。所以，用最简单的方式将其集成到Android Studio界面上是相对不错的解决方案。 准备 开发环境：intellij IDEA 开发手册：intellij Official Docs 参考项目：IntelliJ-OnlineSearch, svgtoandroid 需求 满足工作环境(Windows, Mac Pro) Android Studio主界面启动 单次配置 源代码AndroidDeviceMonitorPlugin plugin.xml 如果不清楚菜单分组分类，可以去Android Studio 主工具菜单空白处右键查阅 点击“Customize Menus And Toolbars”，得见下方内容 SettingsConfigurable LaunchMonitorAction 总结 第一次开发Intellij Plugin：Java界面开发早已忘却 单纯实现功能，逻辑相对简单，但是插件开发里应该有很多门道 多看官文和成功案例","link":"/2019/03/16/Android Device Monitor启动插件/"},{"title":"Android Studio 小技巧（2）：AS中Button文字默认大写的问题","text":"问题类型Layout中添加一个Button 12345&lt;Button android:id=\"@+id/bt_showerror\" android:layout_width=\"200dp\" android:layout_height=\"wrap_content\" android:text=\"ShowError\"/&gt; 预览界面和真机运行却显示： 与直接设置的字符串的显示不一样，显示的文字都显示了大写。 原因探索 AS中针对Activity中设置 android:theme=”@style/AppTheme” 而 而AppTheme的父主题是Theme.AppCompat.Light.DarkActionBar，一直追溯，追溯的过程中关注一个属性值： android:textAllCaps 最后可以找到主题中已经将这个属性设置为true，导致最后出现了你看到的现象。 解决办法 默认的SDK中的设置属性是无法改变的，除非你重新编译对应的framework代码。 这里我们可以直接在对应的Button中设置属性： android:textAllCaps=”false” 这样字体的大小写就正常了 123456&lt;Button android:id=\"@+id/bt_showerror\" android:layout_width=\"200dp\" android:layout_height=\"wrap_content\" android:text=\"ShowError\" android:textAllCaps=\"false\" /&gt;","link":"/2016/07/03/Android Studio 小技巧（2）：AS中Button文字默认大写的问题/"},{"title":"Android Studio 小技巧（1）：如何导入AAR文件","text":"导入AAR、JAR文件 File- &gt; New -&gt; New Module 然后在app中的build.gradle中做如下添加 dependencies { …… compile project(‘:MODULE-NAME’) } 例如 dependencies { …… compile project(‘:circleimageview-2.0.0’) } 也可以直接在app的依赖选项中直接选择最后一个“Module dependency”,然后添加对应的MODULE即可 jar包也可以采用这种方式导入,但是也可以使用另外一种方式 方式 使用 Library dependency 可以选择一些可用的android原生依赖包 File dependency 可以选择一些文件形式的依赖包，比如第三Jar包等 Module dependency 当前工程下的模块依赖 快速添加Material Design Drawableres/drawable 右键 New-&gt; Vector Asset 或者Image Asset 同样的方式使用Image Asset界面大同小异。","link":"/2016/06/24/Android Studio 小技巧（1）：如何导入AAR文件/"},{"title":"AngularJS基础：开发环境准备","text":"Sublime Text 3注册码 —– BEGIN LICENSE —– TwitterInc 200 User License EA7E-890007 1D77F72E 390CDD93 4DCBA022 FAF60790 61AA12C0 A37081C5 D0316412 4584D136 94D7F7D4 95BC8C1C 527DA828 560BB037 D1EDDD8C AE7B379F 50C9D69D B35179EF 2FE898C4 8E4277A8 555CE714 E1FB0E43 D5D52613 C3D12E98 BC49967F 7652EED2 9D2D2E61 67610860 6D338B72 5CF95C69 E36B85CC 84991F19 7575D828 470A92AB —— END LICENSE —— 安装AngularJS提示插件安装Package Control 使用Ctrl+`快捷键或者通过View-&gt;Show Console菜单打开命令行，粘贴如下代码 1import urllib.request,os; pf = 'Package Control.sublime-package'; ipp = sublime.installed_packages_path(); urllib.request.install_opener( urllib.request.build_opener( urllib.request.ProxyHandler()) ); open(os.path.join(ipp, pf), 'wb').write(urllib.request.urlopen( 'http://sublime.wbond.net/' + pf.replace(' ','%20')).read()) 点击Preferences -&gt; Package Control菜单，选择install。输入AngularJS即可安装插件 Node.js安装Angular CLI 安装1npm install -g @angular/cli 创建项目创建新项目 1ng new my-app 启动项目 12cd my-appng serve --open 编辑项目","link":"/2018/01/22/AngularJS小白（1）：开发环境准备/"},{"title":"Android开发问题积累","text":"在线Gif加载解决办法Glide完美解决 1Glide.with(context).load(pic).placeholder(R.drawable.loading).into(imageView); pic: url地址 R.drawable.loading: gif加载之前图片 imageView：目标imageview Intent调用图库使用L版本手机的时候，通过Intent调用图库，选择图片后出现”不支持的媒体类型”或者是”Failed to read row 0, column 6 from a CursorWindow which has 1 rows, 6 columns”。由于对数据库这一款疏于了解，不能很快的定位出这个问题，首先想到的办法就是将出问题的文件不要暴露在用户眼前。 解决办法12345678910Intent intent = null;if (Build.VERSION.SDK_INT &lt; 19){ intent = new Intent(Intent.ACTION_GET_CONTENT); intent.setType(\"image/*\");}else{ intent = new Intent(Intent.ACTION_PICK, android.provider.MediaStore.Images.Media.EXTERNAL_CONTENT_URI);} 不同的Android版本，选择系统图库中图片的方式有点差别，这个是需要注意的，Google不断更新API肯定是有原因的，所以，Android版本的兼容性问题是迭代开发和维护工作中不可避免的。单看代码是比较简单，但是当开发者不知道的时候，这个问题可能就会浪费很多时间。 AlertDialog获取PositionButton，NeturalButton 和 NegativeButton，一定要先调用show()方法解决办法1234dialog.show();//注意 必须先调用这个，否则下面会报空指针异常if(xxxxx) { dialog.getButton(DialogInterface.BUTTON_NEGATIVE).setVisibility(GONE);} else { dialog.getButton(DialogInterface.BUTTON_NEGATIVE).setVisibility(VISIBLE);} L版本上Toast无法显示解决办法 L版本上通知管理中，关闭了对应应用的通知权限，去“设置”-&gt; “通知管理”中打开即可 避免因为权限问题导致Toast无法显示，可以尝试自定义完成类似Toast的功能 TextView走马灯解决办法123456789TextView tv = new TextView(activity);tv.setText(\"XXXXXXXXXXXX\");tv.setSingleLine(true);tv.setEllipsize(TextUtils.TruncateAt.MARQUEE);tv.setMarqueeRepeatLimit(-1);tv.setFocusable(true);tv.setFocusableInTouchMode(true);tv.setHorizontallyScrolling(true);tv.requestFocus(); 使用系统ACTION_SEND 发送文字或者图片解决办法发送文字 123456String message = \"This is a sharing Text\";Intent shareIntent = new Intent();shareIntent.setAction(Intent.ACTION_SEND);shareIntent.setType(\"text/plain\");shareIntent.putExtra(Intent.EXTRA_TEXT, message);this.startActivity(shareIntent); 发送图片 123456789/* localqrcode是一个bitmap对象*/String pathofBmp = Images.Media.insertImage( activity.getContentResolver(), localqrcode, \"title\", null);Uri bmpUri = Uri.parse(pathofBmp);//获取本地UriIntent intent= new Intent( android.content.Intent.ACTION_SEND); intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK); intent.putExtra(Intent.EXTRA_STREAM, bmpUri);//流类型intent.setType(\"image/png\");activity.startActivity(intent.createChooser(intent, \"选择\")); 调用系统资源解决办法12345678910/*获取导航栏高度 */private int getNavigationBarHeight() { boolean hasNavigationBar = getResources().getBoolean(Resources.getSystem().getIdentifier(\"config_showNavigationBar\", \"bool\", \"android\")); if(hasNavigationBar) { return getResources().getDimensionPixelSize(Resources.getSystem().getIdentifier(\"navigation_bar_height\", \"dimen\",\"android\")); } return 0;} 通过Resources.getSystem().getIdentifier(“config_showNavigationBar”, “bool”, “android”));这类方式获取ID，然后通过正常的资源使用方式使用即可 Okhttp异常 Okhttp异常： System.err: java.lang.IllegalStateException: closed System.err: at okio.RealBufferedSource.rangeEquals(RealBufferedSourc System.err: at okio.RealBufferedSource.rangeEquals(RealBufferedSourc System.err: at okhttp3.internal.Util.bomAwareCharset(Util.java:397) System.err: at okhttp3.ResponseBody.string(ResponseBody.java:173) 解决办法Response response = okHttpClient.newCall(request).execute();这里返回的response一般我们后面就会执行response.body().string()，但是如果连续调用两次response.body().string()，就会出现如上的错误 actionBar.setDisplayHomeAsUpEnabled(true);后如何修改返回图标解决办法actionBar.setHomeAsUpIndicator(R.drawable.__picker_back); toolbar上menu的标题字体颜色如何修改解决办法style.xml文件中添加 &lt;item name=&quot;actionMenuTextColor&quot;&gt;#ffffff&lt;/item&gt; WebView无法显示图片解决办法1234webView.getSettings().setBlockNetworkImage(false); if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.LOLLIPOP) { webView.getSettings().setMixedContentMode(WebSettings.MIXED_CONTENT_ALWAYS_ALLOW); } Unable to execute dex: method ID not in [0, 0xffff]: 65536解决办法 Eclipse: dex.force.jumbo=true Android Studio : multiDexEnabled true 自定义Dialog大小解决办法123456Window dialogWindow = dialog.getWindow();DensityUtil du = new DensityUtil(mContext);WindowManager.LayoutParams p = dialogWindow.getAttributes(); // 获取对话框当前的参数值p.height = (int) (du.getHeight() * 0.5); // 高度设置为屏幕的0.6，根据实际情况调整p.width = (int) (du.getWidth() * 0.8); // 宽度设置为屏幕的0.65，根据实际情况调整dialogWindow.setAttributes(p); Eclipse Conversion to Dalvik format failed with error 1对我有效的解决办法这个问题的原因比较多，网上有的人说重启一下Eclipse就好了，换一个工作空间就好了。我尝试了都不行，或许只是对我不行。下面是对我有效的办法： 关闭自动Build：Project-&gt;Build Automatically clean项目：Project-&gt;Clean 手动Build，右键点击项目，然后：Build Project 然后再Export项目，报错消失了！","link":"/2016/10/31/Android开发问题积累/"},{"title":"Android 投射工具和录屏工具","text":"前言写博客，难免需要上传手机截图或者是Gif文件，分享两个常用的工具 GifCamGifCam,一个简单的 屏幕录制工具，可以实现Gif的录制编辑和保存 Total ControlTotal Control， 是一个简单的手机屏幕共享到PC的工具，直接在PC上安装客户端，然后连接手机，会自动安装一个apk。这个工具做出的不是简单的投射，通过PC操作，点击手机屏幕可以实现对应的操作。 LICEcapMac系统中GifCam的替代品","link":"/2016/11/14/Android 投射工具和录屏工具/"},{"title":"CentOS + Docker + Gitlab-ce","text":"Docker安装与启动搜索1yum search docker 安装1yum install docker 启动1systemctl start docker 开机自启动1systemctl enable docker.service 查看状态1systemctl status docker 查看版本12docker versiondocker -v 查看信息1docker info 镜像打包和导入12//将名为gitlab/gitlab-ce的image打包成gitlab.tardocker save -o gitlab.tar gitlab/gitlab-ce 12//导入imagedocker load -i gitlab.tar Gitlab-ce安装搜索1docker search gitlab-ce 下载一般情况下，我都是使用官方镜像或者阿里镜像 1docker pull gitlab/gitlab-ce 安装123456789sudo docker run -i \\ --hostname centos \\ --publish 443:443 --publish 80:80 --publish 22:22 \\ --name gitlab \\ --restart always \\ --volume /srv/gitlab/config:/etc/gitlab \\ --volume /srv/gitlab/logs:/var/log/gitlab \\ --volume /srv/gitlab/data:/var/opt/gitlab \\ docker.io/gitlab/gitlab-ce /srv目录下若没有对应文件夹，可自行创建，也可修改成其他文件路径 使用进入Gitlab Docker环境1docker exec -it gitlab /bin/bash 全局配置文件修改下载地址中的显示IP也在此修改 1/etc/gitlab/gitlab.rb ssh端口修改后处理1234567docker exec -it gitlab /bin/bashvi /etc/gitlab/gitlab.rb#修改ssh对应host地址gitlab_rails['gitlab_ssh_host'] = 'xxx.xxx.xxx.xxx'#修改ssh映射端口gitlab_rails['gitlab_shell_ssh_port'] = 23 注意打开服务器上对应的端口 定时备份以及自动上传ftp服务器编辑定时任务（每天凌晨两点备份，三点上传。下面sh文件是自编的一个ftp上传脚本） 1234vi /var/spool/cron/root 0 2 * * * docker exec -t gitlab gitlab-rake gitlab:backup:create CRON=1 0 3 * * * /root/BKConfig/upload_bk.sh 脚本内容 1234567891011#!/bin/bashftp -n&lt;&lt;!open &lt;ftp服务器地址&gt;user &lt;username&gt; &lt;password&gt;binarylcd &lt;待上传的文件夹路径&gt;promptmput *closebye! 阿里云加速器寻找属于你的加速器阿里云官网，登陆以后，找到“弹性计算“下的“容器镜像服务“，然后你就可以看到属于你自己的“镜像加速器“ 服务器Docker镜像配置/etc/docker/daemon.json 123{ \"registry-mirrors\": [\"&lt;your accelerate address&gt;\"]} 替换成你自己的加速器地址即可。 配置完成后重启Dockerdocker overlay2 空间占满100%时，处理方法原文: https://unix.stackexchange.com/questions/414483/docker-increase-available-disk-space跟换overlay2目录地址：You could move the docker directory to somewhere under /home and create a symlink /var/lib/docker pointing to the new location. For example: shut down docker first mv /var/lib/docker /home/ ln -s /home/docker/ /var/lib/ restart docker now Use another directory if /home/docker already exists. Instead of, or as well as, the symlink from /var/lib/docker -&gt; /home/docker, you could also reconfigure docker so that it expects to find its directory under /home rather than /var/lib.","link":"/2018/04/21/CentOS + Docker + Gitlab-ce/"},{"title":"CentOS + Docker + MySql","text":"Docker安装与启动搜索1yum search docker 安装1yum install docker 启动1systemctl start docker 查看状态1systemctl status docker 查看版本12docker versiondocker -v 查看信息1docker info Mysql安装搜索1docker search mysql 下载一般情况下，我都是使用官方镜像或者阿里镜像 1docker pull mysql 运行1docker run --name onlyloveyd-mysql -e MYSQL_ROOT_PASSWORD=my-secret-pw -p 3306:3306 -d mysql:latest –name 指定数据库名称 －e MYSQL_ROOT_PASSWORD=my-secret-pw 配置root账号密码 －p 指定端口映射 －d 指定镜像 查看运行状态1docker ps -a 使用进入Mysql Docker环境1docker exec -it onlyloveyd-mysql /bin/bash onlyloveyd-mysql 替换成 对应容器名 进入mysql1mysql -u root -p 输入密码后进入mysql 配置允许Mysql远程连接使用mysql命令的时候注意以分号结尾。 123use mysql;select host,user,authentication_string from user;update user set host = '%' where user = 'root'; 存在host为‘％‘，user为‘root‘的记录就代表用户可以在任何一台机器上使用root账号登陆。","link":"/2018/04/21/CentOS + Docker + MySql/"},{"title":"CentOS + Tomcat + SSL","text":"前言 最近iOS开发企业应用需要使用HTTPS协议的地址来做应用升级，所以需要搭建一个支持HTTPS的Tomcat 下载Tomcat1wget http://mirrors.tuna.tsinghua.edu.cn/apache/tomcat/tomcat-7/v7.0.86/bin/apache-tomcat-7.0.86.tar.gz 配置SSL证书下载SSL证书文件腾讯云上申请免费SSL证书，记住设置的密码，配置tomcat的时候会使用到，待申请通过，会颁发证书，下载证书解压后，目录结构如下，应该是针对不用的容器有不用的配置方法。 Tomcat下配置证书 拷贝上图中Tomcat下的jks文件到 tomcat安装目录下conf 目录 “xxxxapache-tomcat-7.0.86/conf/”下（当然你也可以使用其他路径，这里方后续配置server.xml，才放在此处）； 编辑“xxxx/apache-tomcat-7.0.86/conf/server.xml” 取消下图位置注释，然后添加 keystoreFile=&quot;conf/xxxx.jks&quot;keystorePass=&quot;xxx&quot; ，最后结果下图二 Tomcat启动安装目录，bin目录下 1./startup.sh 访问 “https://xxxx:8443” 常见问题8443端口未开放123sudo firewall-cmd --zone=public --add-port=8443/tcp --permanentsystemctl restart firewalld.service 8443端口被占用12lsof -i tcp:8443//查询8443端口使用情况kill -9 xxx //kill掉对应进程 lsof / netstat / wget not found123yum install lsofyum install net-toolsyum install wget","link":"/2018/04/25/CentOS + Tomcat + SSL/"},{"title":"Flutter版 Gank.io","text":"前言每次练手都是用【代码家】大佬的接口，再次感谢。 FlutterGank GankIOClient GankIOWithKotlin 干货数据源 应用中的所有干货数据均来自干货集中营。 App设计 色调：远州鼠、落栗、苏芳、石竹、枯草、柳煤竹茶、锖青磁、鸠羽紫八种淡雅的颜色，分别对应不同的干货数据。 布局：简约风格，极简主义，去繁就简。 UI设计 黑白灰紫蓝 圆角 材料设计 Author CSDN Website JueJin Android ScreenShot iOS ScreenShot FAQ Missing xcode dependency: Python module “six”解决办法 WebView插件解决办法 Dart Html Parse解决方法 KeyBoard Causes Overflow解决办法 其他问题解决办法 国内网络问题解决办法","link":"/2018/05/12/Flutter版 Gank.io/"},{"title":"MacOS 10.11.6 Android源码编译并刷机","text":"前言Mac OS之前是10.14版本，Xcode也是最新的Xcode 10，与官文要求的编译环境相差很大，导致编译过程中出现各种奇葩错误，无力解决，遂重装系统。好在Mac OS重装系统很方便，在线安装即可。所以，安装10.11版本，目前编译Android6.0.1源码无问题。 环境 Mac OS ：10.11.6 OS X EI Capitan JDK：jdk7 Xcode：离线安装的Xcode 7.1 以及对应的Command Line Tool（官方下载安装） MacPorts 创建分区mac系统默认是不区分大小写的。 1hdiutil create -type SPARSE -fs 'Case-sensitive Journaled HFS+' -size 150g ~/android.dmg 这将创建一个.dmg.sparseimage文件，该文件在装载后可用作具有 Android 开发所需格式的驱动盘。若发现大小不足，可以重新修改 1hdiutil resize -size &lt;new-size-you-want&gt;g ~/android.dmg.sparseimage 在~/.bash_profile添加两个方法 1234# mount the android file imagemountAndroid() { hdiutil attach ~/android.dmg.sparseimage -mountpoint /Volumes/android; }# unmount the android file imageumountAndroid() { hdiutil detach /Volumes/android; } 环境准备JDK安装Xcode7.1/Command Line Tool安装（官方下载安装）下载时注意和系统10.11配套的Xcode，以及和Xcode版本对应的Command Line Tool MacPorts 从macports.org 下载安装,请确保 /opt/local/bin 在路径中显示在 /usr/bin 前面。否则，请将以下内容添加到环境变量配置文件(~/.bash_profile)中： 1export PATH=/opt/local/bin:$PATH 通过 MacPorts 获取 Make、Git 、 GPG、BISON 软件包 1POSIXLY_CORRECT=1 sudo port install gmake libsdl git gnupg bison 设置文件描述符数量上限在 Mac OS 中，可同时打开的文件描述符的默认数量上限太低，在高度并行的编译流程中，可能会超出此上限。要提高此上限，在~/.bash_profile下添加 12# set the number of open files to be 1024ulimit -S -n 1024 下载 国内采用清华源，国外自便 Repo ~目录下新建bin目录，进入后下载repo 1234mkdir bincd bincurl https://mirrors.tuna.tsinghua.edu.cn/git/git-repo -o repochmod +x repo /bin目录加入PATH，/.bash_profile添加 1export PATH=\"~/bin:$PATH\" repo的运行过程中会尝试访问官方的git源更新自己，如果想使用tuna的镜像源进行更新，可以将如下内容复制到你的~/.bash_profile里 1export REPO_URL='https://mirrors.tuna.tsinghua.edu.cn/git/git-repo/' 下载源码12345cd /Volumes/androidmkdir aospcd aosprepo init -u https://aosp.tuna.tsinghua.edu.cn/platform/manifest -b android-6.0.1_r1repo sync 编译清理1make clobber 设置环境1source build/envsetup.sh 选择编译对象1lunch 如果是运行模拟器，选择1即可，如果是编译刷机，根据具体机型选择编译对象。 执行编译1make -j8 -jN 表示编译并行任务数，这个示电脑情况而定，一般取cpu数的1～2倍就可以 编译AOSP 8.0.0_r17并刷机环境变化jdk7换成 jdk8 为了方便jdk版本切换，在.bash_profile中添加如下内容 1234567export JAVA_7_HOME=/Library/Java/JavaVirtualMachines/jdk1.7.0_80.jdk/Contents/Homeexport JAVA_8_HOME=/Library/Java/JavaVirtualMachines/jdk1.8.0_201.jdk/Contents/Homeexport JAVA_HOME=$JAVA_8_HOMEalias jdk8='export JAVA_HOME=$JAVA_8_HOME'alias jdk7='export JAVA_HOME=$JAVA_7_HOME' 然后在终端下使用jdk7或者jdk8来切换环境 驱动下载按照对应的细分版本下载驱动 下面是具体下载内容 extract-huawei-angler.sh extract-huawei-angler.sh下载放至AOSP根目录，执行 执行编译lunch选择angler，执行编译，待编译完成 刷机123456# 手机连接电脑情况下adb reboot bootloader# 进入源码编译输出的目录fastboot flashing unlockfastboot flashall -wfastboot reboot 结果虽然最后刷入userdata失败，但是不影响运行，系统成功刷入。 问题Git下载内容过大1git config --global http.postBuffer 524288000 Android6.0.1修改build/core/combo/mac_version.mk1mac_sdk_versions_supported := 10.6 10.7 10.8 10.9 改为 1mac_sdk_versions_supported := 10.6 10.7 10.8 10.9 10.11","link":"/2019/04/01/MacOS 10.11.6 Android源码编译并刷机/"},{"title":"PowerDesign 12.0 & PDMReader轻松生成数据字典","text":"前言最近需要编制项目文档，其中必不可少的内容就是数据字典，手动编制过于麻烦且容易出错，采用SQL语句查询表信息然后整理成文档的方式也是非常的耗时。于是开始搜寻解决方案，了解到PowerDesign这个工具。所以下载了PowerDesign，按照个人习惯，总是喜欢使用最新版本，但是使用过程中发现导出的PDM文件，使用最新版本的PDMReader无法导入，这就尴尬了，网友说，一般这种情况是两者的版本不匹配导致的，并且在操作PDMReader的时候，无意中发现如下界面于是我去下载了PowerDesign12.0，再次尝试，竟然可以成功的生成数据字典。 工具对应版本的PowerDesign和PDMReader，已上传至CSDNPowerDesign12以及PDMReader 使用方式 PowerDesign生成PDM文件 PDMReader导入PowerDesign生成的PDM文件，并导出为word即可 遇到问题 PowerDesign针对oracle只能使用32位odbc，若没有对应驱动，需要手动安装一下下载地址，对应的配置方法如官网所述 本地数据源可以通过【控制面板】-&gt;【管理工具】-&gt;【ODBC数据源(32位)】进行配置","link":"/2018/10/31/PowerDesign 12.0 & PDMReader轻松生成数据字典/"},{"title":"Markdown博文快速转为微信文章","text":"介绍技术博文在CSDN上，全是Markdown格式，最近看各位大佬又是个人网站又是个人微信公众号，突然发现：“个人博客小站 + 个人微信公众号 + CSDN + 掘金+ … = 程序员标配“。所以最近在整理自己的个人订阅号。部分文章开始往微信平台转移，但是微信格式不是采用的Markdown而是采用的富文本，重新书写的工作量比较大，所以如何高效的将Markdown文章转成微信支持的格式，是一个问题。下面介绍一下我自己的一套方法，如有更好的办法，请不吝赐教。 工具 MacBook MarkEditor基础版非付费 Markdown Here 插件（Chrome，Safari等浏览器支持） 135微信文章在线编辑器 步骤1. 将Markdown格式的CSDN文章复制到MarkEditor编辑器2. 将MarkEditor编辑器中的内容复制到135编辑器方便我们添加一些其他的内容3. 浏览器中点击“Markdown Here“插件，优化文章格式4. 最后复制到微信公众号文章编辑器中即可。除了表格，其他的格式基本上全部能正确的转换","link":"/2017/05/07/Markdown博文快速转为微信文章/"},{"title":"RxJava2-基础使用","text":"介绍 RxJava，响应式编程，告别AsyncTask，与Retrofit组成了日常开发经典组合。之前，好读书不求甚解得态度，让我对其印象并不深刻，知识层面比较浅薄。为了加深印象，重新学习。 添加依赖12implementation 'io.reactivex.rxjava2:rxandroid:2.0.1'implementation 'io.reactivex.rxjava2:rxjava:2.1.7' 举例说明上游和下游（被观察者和观察者）12345678910111213141516171819202122232425262728293031Observable&lt;Integer&gt; observable = Observable.create(new ObservableOnSubscribe&lt;Integer&gt;() { @Override public void subscribe(ObservableEmitter&lt;Integer&gt; e) throws Exception { e.onNext(111); e.onNext(222); e.onComplete(); }});Observer&lt;Integer&gt; observer = new Observer&lt;Integer&gt;() { @Override public void onSubscribe(Disposable d) { Logger(\"onSubscribe\"); } @Override public void onNext(Integer integer) { Logger(\"onNext integer = \" + integer); } @Override public void onError(Throwable e) { Logger(\"onError e = \" + e.getMessage()); } @Override public void onComplete() { Logger(\"onComplete\"); }};observable.subscribe(observer); 运行结果 流程 创建Observable 创建Observer Observerable订阅（subscribe）Observer ObservableObservable是一个抽象类，实现ObservableSource接口 1public abstract class Observable&lt;T&gt; implements ObservableSource&lt;T&gt; 而ObservableSource接口中只有一个订阅方法 123456789public interface ObservableSource&lt;T&gt; { /** * Subscribes the given Observer to this ObservableSource instance. * @param observer the Observer, not null * @throws NullPointerException if {@code observer} is null */ void subscribe(@NonNull Observer&lt;? super T&gt; observer);} 通过create方法创建Observable，稍微追下源码，帮助理解 1234public static &lt;T&gt; Observable&lt;T&gt; create(ObservableOnSubscribe&lt;T&gt; source) { ObjectHelper.requireNonNull(source, \"source is null\"); return RxJavaPlugins.onAssembly(new ObservableCreate&lt;T&gt;(source));} 参数类型为ObservableOnSubscribe接口 123456789public interface ObservableOnSubscribe&lt;T&gt; { /** * Called for each Observer that subscribes. * @param e the safe emitter instance, never null * @throws Exception on error */ void subscribe(@NonNull ObservableEmitter&lt;T&gt; e) throws Exception;} ObservableEmitter可以理解成发射器，看下它的源码。它继承Emitter。而Emitter中才是我们最基础最常用的功能。 12345678public interface ObservableEmitter&lt;T&gt; extends Emitter&lt;T&gt; { void setDisposable(@Nullable Disposable d); void setCancellable(@Nullable Cancellable c); boolean isDisposed(); ObservableEmitter&lt;T&gt; serialize(); @Experimental boolean tryOnError(@NonNull Throwable t);} 上面这部分代码，删除了部分注释，可在源码中查阅。 12345678910111213141516171819public interface Emitter&lt;T&gt; { /** * Signal a normal value. * @param value the value to signal, not null */ void onNext(@NonNull T value); /** * Signal a Throwable exception. * @param error the Throwable to signal, not null */ void onError(@NonNull Throwable error); /** * Signal a completion. */ void onComplete();} 从上面Emitter的代码可以看出，我们可以发射三种消息： onNext, onComplete, onError。从语义上就很容易看出他们的作用。 针对三个事件，做一些说明： 发射器可以发送无限个onNext, Observer也可以接收无限个onNext； 发射器发送一个onComplete后, onComplete之后的事件将会继续发送, 而Observer收到第一个onComplete事件之后将不再继续接收事件； 发射器发送了一个onError后, onError之后的事件将继续发送, 而Observer收到onError事件之后将不再继续接收事件； 发射器可以不发送onComplete或onError； 发射器不能同时发出onComplete和onError； 不允许发出多个onError或者onComplete。 Observer相对于Observable而言，Observer就简单很多，我们只需要针对我们感兴趣的事件作出相应的处理即可。 123456public interface Observer&lt;T&gt; { void onSubscribe(@NonNull Disposable d); void onNext(@NonNull T t); void onError(@NonNull Throwable e); void onComplete();} 这里有一个新内容Disposable，先看代码，“象征一个一次性资源”，从注释上看是这个意思。但是如何理解？ 123456789101112131415/** * Represents a disposable resource. */public interface Disposable { /** * Dispose the resource, the operation should be idempotent. */ void dispose(); /** * Returns true if this resource has been disposed. * @return true if this resource has been disposed */ boolean isDisposed();} 举例： 123456789101112131415161718192021222324252627282930313233343536373839Observable&lt;Integer&gt; observable = Observable.create(new ObservableOnSubscribe&lt;Integer&gt;() { @Override public void subscribe(ObservableEmitter&lt;Integer&gt; e) throws Exception { e.onNext(111); e.onNext(222); e.onNext(333); e.onComplete(); e.onNext(444); }});Observer&lt;Integer&gt; observer = new Observer&lt;Integer&gt;() { Disposable mDisposable; @Override public void onSubscribe(Disposable d) { Logger(\"onSubscribe\"); mDisposable = d; } @Override public void onNext(Integer integer) { Logger(\"onNext integer = \" + integer); if(integer== 222 &amp;&amp; !mDisposable.isDisposed()) { mDisposable.dispose(); } } @Override public void onError(Throwable e) { Logger(\"onError e = \" + e.getMessage()); } @Override public void onComplete() { Logger(\"onComplete\"); }};observable.subscribe(observer); 运行结果： 可以看到发射器发送了222之后，剩下的事件Observer并没有处理，那么剩下的事件发射器有没有发送呢？在发射器发射事件之前添加log。 可以看到发射器的事件并没有受到Disposable影响，只是Observer没有接收到222之后的事件而已。 Disposable的作用应该是，截断发射器与Observer之间的事件通道。","link":"/2018/01/06/RxJava2小白手册（1）- 基础使用/"},{"title":"RxJava2-map","text":"介绍 操作符map，字面理解一下，就是映射，那么这个操作符如何使用呢？ 举例说明代码示例1234567891011121314151617181920212223242526272829303132333435363738394041Observable&lt;Integer&gt; observable = Observable.create(new ObservableOnSubscribe&lt;Integer&gt;() { @Override public void subscribe(ObservableEmitter&lt;Integer&gt; e) throws Exception { Logger(\"Emit 1\"); e.onNext(1); Logger(\"Emit 2\"); e.onNext(2); e.onComplete(); }});Observer&lt;String&gt; observer = new Observer&lt;String&gt;() { @Override public void onSubscribe(Disposable d) { Logger(\"onSubscribe\"); } @Override public void onNext(String object) { Logger(\" onNext \" + object); } @Override public void onError(Throwable e) { Logger(\"onError e = \" + e.getMessage()); } @Override public void onComplete() { Logger(\"onComplete\"); }};observable.subscribeOn(Schedulers.io()) .map(new Function&lt;Integer, String&gt;() { @Override public String apply(Integer integer) throws Exception { return \"i am \" + integer; } }) .observeOn(AndroidSchedulers.mainThread()) .subscribe(observer); 运行结果 可以看到首先执行的是onSubscribe方法，然后发射两个onNext事件，两个Integer参数经过转换之后成为String类型，然后传递给Observer作出动作，这就是Map的作用。 源码浅析下面是map操作符的源码。 1234567//观察map中Function的两个参数，一个是T也就是变化前的类型，R为变化后的类型，最后返回的是R类型的Observerable(姑且这么说)public final &lt;R&gt; Observable&lt;R&gt; map(Function&lt;? super T, ? extends R&gt; mapper) { //常规非空检查 ObjectHelper.requireNonNull(mapper, \"mapper is null\"); //又是onAssembly,不重要，关注ObservableMap return RxJavaPlugins.onAssembly(new ObservableMap&lt;T, R&gt;(this, mapper));} 看下ObservableMap的构造方法，传入的参数，source为转换前的Observable&lt; T &gt;, 第二个参数就是我们得function。ObservableMap继承AbstractObservableWithUpstream，而后者继承Observable，可以看出来，经过map转换后的Observable对象就是ObservableMap类型。 1234public ObservableMap(ObservableSource&lt;T&gt; source, Function&lt;? super T, ? extends U&gt; function) { super(source); this.function = function;} 既然转换后是ObservableMap类型，那么必然存在subscribeActual方法，果然 123public void subscribeActual(Observer&lt;? super U&gt; t) { source.subscribe(new MapObserver&lt;T, U&gt;(t, function));} 看看MapObserver是个什么东西？ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748//MapObserver继承BasicFuseableObserver，而后者实现了Observer接口static final class MapObserver&lt;T, U&gt; extends BasicFuseableObserver&lt;T, U&gt; { //map操作符中的function final Function&lt;? super T, ? extends U&gt; mapper; //actual是栗子中我们后面subscribe的Observer MapObserver(Observer&lt;? super U&gt; actual, Function&lt;? super T, ? extends U&gt; mapper) { super(actual); this.mapper = mapper; } @Override public void onNext(T t) { //done在执行了onError或者onComplete之后为true,具体查看父类BasicFuseableObserver。done为true时，不做处理。 if (done) { return; } if (sourceMode != NONE) { actual.onNext(null); return; } //U类型，转换后的类型，栗子中为String U v; try { //常规非空检查，但是里面有个apply的操作，这个apply的操作就是我们上面栗子中把Integer转成String的操作。v就是转换后的String类型 v = ObjectHelper.requireNonNull(mapper.apply(t), \"The mapper function returned a null value.\"); } catch (Throwable ex) { fail(ex); return; } //Observer执行onNext操作，v为转换后的类型，如栗子中的String actual.onNext(v); } @Override public int requestFusion(int mode) { return transitiveBoundaryFusion(mode); } @Nullable @Override public U poll() throws Exception { T t = qs.poll(); return t != null ? ObjectHelper.&lt;U&gt;requireNonNull(mapper.apply(t), \"The mapper function returned a null value.\") : null; } } 为什么发射之后Observer的onNext没有立刻执行，因为上文例子中subscribeOn和observeOn所在的线程不一样。","link":"/2018/01/08/RxJava2小白手册（3）- map/"},{"title":"Xen虚拟机镜像的安装","text":"了解系统安装在哪个磁盘上：fdisk -l 建立存放虚拟机镜像的目录：mkdir /mnt/vmx 更改文件系统格式： mkfs -t ext4 /dev/sda或者/dev/sdb(系统不在的那个硬盘） 将非系统硬盘挂载到系统盘的一个目录下： mount -o loop/dev/sda或者/dev/sdb(系统不在的那个硬盘） /mnt/vmx 再将vm镜像copy到/mnt/vmx下 mount -o loop xxxxx.img /mnt/vm 在转至/mnt/vm下 配置文件","link":"/2014/04/23/Xen虚拟机镜像的安装/"},{"title":"xm 命令","text":"xm console &lt;域ID&gt; ctrl+ ] 退出虚拟机到宿主 xm reboot &lt;域ID&gt; xm pause &lt;域ID&gt; xm resume &lt;域ID&gt; xm shutdown &lt;域ID&gt; xm destroy 域名 删除虚拟机","link":"/2014/04/28/xm 命令/"},{"title":"WanAndroidClient","text":"前言 鸿神的WanAndroid网站后台API已经开放。具体接口详情参考博文： http://www.wanandroid.com/blog/show/2 所以，对于不熟悉Kotlin的我而言，借此机会练习一下。 使用开源库 CardView RecyclerView BGARefreshLayout BGABanner BGAViewPager BRVAH Retrofit RxJava RxAndroid Moshi Okhttp3 Anko Glide com.orhanobut:logger FlexBox Lottie AgentWeb FlycoTabLayout 效果 源代码 WanAndroidClient","link":"/2018/02/25/WanAndroidClient/"},{"title":"Xen虚拟机下挂载","text":"//创建源vdisk挂载目录； mkdir vd1 //创建目标vdisk挂载目录；mkdir vd2 //只需第一次执行iscsiadm -m discovery –type sendtargets –portal 192.168.3.221 //挂载；\\root\\4xvd_loginxmount -o loop /dev/sdc /mnt/vdisk //挂载源vdisk；mount -o loop /mnt/vdisk/vmm4_vm9_dt.img /mnt/vd1 //制作vdisk；以VMM1的VM1为例(初始化）dd if=/dev/zero of=/mnt/vdisk/vmm1_vm1_dt.img bs=1M seek=81920 count=1mkfs -t ext4 /mnt/vdisk/vmm1_vm1_dt.img //挂载目标vdisk；以VMM1的VM1为例mount -o loop /mnt/vdisk/vmm1_vm1_dt.img /mnt/vd2","link":"/2014/04/25/Xen虚拟机下挂载/"},{"title":"《 Linux 》Crond 定时任务","text":"简介 crond的概念和crontab是不可分割的。crontab是一个命令，常见于Unix和类Unix的操作系统之中，用于设置周期性被执行的指令。该命令从标准输入设备读取指令，并将其存放于“crontab”文件中，以供之后读取和执行。该词来源于希腊语chronos(χρόνος)，原意是时间。而crond正是它的守护进程。 说明 Linux下的任务调度分为两类，系统任务调度和用户任务调度。 系统任务调度：系统周期性所要执行的工作，比如写缓存数据到硬盘、日志清理等。 在/etc目录下有一个crontab文件，这个就是系统任务调度的配置文件。 用户任务调度：用户定期要执行的工作，比如用户数据备份、定时邮件提醒等。用户可以使用 crontab 工具来定制自己的计划任务。所有用户定义的crontab 文件都被保存在 /var/spool/cron目录中。其文件名与用户名一致。 权限问题文件 | 说明 --------------- | ---------------------- /etc/cron.deny | 该文件中所列用户不允许使用crontab命令 /etc/cron.allow | 该文件中所列用户允许使用crontab命令 如果两个文件都不存在，则只有root用户才能使用crontab命令。 如果cron.allow存在但cron.deny不存在，则只有列在cron.allow文件里的用户才能使用crontab命令，如果root用户也不在里面，则root用户也不能使用crontab。 如果cron.allow不存在, cron.deny存在，则只有列在cron.deny文件里面的用户不能使用crontab命令，其它用户都能使用。 如果两个文件都存在，则列在cron.allow文件中而且没有列在cron.deny中的用户可以使用crontab，如果两个文件中都有同一个用户，以cron.allow文件里面是否有该用户为准，如果cron.allow中有该用户，则可以使用crontab命令。 定时任务 /var/spool/cron/ 所有用户crontab文件存放的目录,以用户名命名。 用户所建立的crontab文件中，每一行都代表一项任务，每行的每个字段代表一项设置，它的格式共分为六个字段，前五段是时间设定段，第六段是要执行的命令段。 在以上各个字段中，还可以使用以下特殊字符： 星号（*）：代表所有可能的值，例如month字段如果是星号，则表示在满足其它字段的制约条件后每月都执行该命令操作。 逗号（,）：可以用逗号隔开的值指定一个列表范围，例如，“1,2,5,7,8,9” 中杠（-）：可以用整数之间的中杠表示一个整数范围，例如“2-6”表示“2,3,4,5,6” 正斜线（/）：可以用正斜线指定时间的间隔频率，例如“0-23/2”表示每两小时执行一次。同时正斜线可以和星号一起使用，例如*/10，如果用在minute字段，表示每十分钟执行一次。 Crond服务安装crontab1yum install crontabs 常用操作1234567891011service crond start //启动服务service crond stop //关闭服务service crond restart //重启服务service crond reload //重新载入配置service crond status //启动服务chkconfig -level 35 crond on //设置开机自启动 crontab命令 示例 每天凌晨2点执行Gitlab备份 每天凌晨3点执行一个sh脚本","link":"/2018/08/20/《 Linux 》Crond 定时任务/"},{"title":"《Android  Studio》  Android Studio 使用Aliyun Maven","text":"Gradle配置1234567891011121314allprojects { repositories { maven{ url 'http://maven.aliyun.com/nexus/content/groups/public/'} jcenter() }}...allprojects { repositories { maven{ url 'http://maven.aliyun.com/nexus/content/groups/public/'} jcenter() }} 速度 自己登陆这个网站Aliyun Maven，查询下对应的开源库感受一下就知道了。","link":"/2017/03/25/《Android  Studio》  Android Studio 使用Aliyun Maven/"},{"title":"《Android Framework 之路》Android5.1 Camera Framework（四）——框架总结","text":"前言 从之前的几篇文件，可以基本弄清楚 Camera从APK，经过framework的衔接，与HAL层进行交互，最终通过驱动完成Camera的一些动作。 Camera层次分析 APP层 Framework层 库层 大致的框架图如下 从图中可以看到几个关键的地方： APP从JAVA层过渡到CPP层中间通过JNI层的android_hardware_Camera.cpp文件实现，文件中主要涉及从java方法到cpp函数的映射关系，方便作出对应的处理; Camera交互对象，从开始连接过程中式Camera与CameraService，连接之后基本上就是Camera与CameraClient进行交互，这里注意到CameraClient是继承CameraService::Client的，而后者则是继承BnCamera,继承ICamera，Camera类中存在一个ICamera变量，就是这个内容; Camera类继承BnCameraClient，继承ICameraClient，这样就可以实现Camera与CameraClient的交互; 至于CameraService与Camera底层库的交互，只是Camera HAL 层的模块加载是在CameraService中实现的，真正的HAL层的创建是在CameraClient的初始化过程中 今天的内容比较的少，主要是总结下。 本文中代码使用的是Android5.1原始代码","link":"/2015/09/13/《Android Framework 之路》Android5.1 Camera Framework（四）——框架总结/"},{"title":"《Android Framework 之路》多线程","text":"多线程编程JAVA多线程方式 继承Thread线程，实现run方法 实现Runnable接口 JAVA单继承性，当我们想将一个已经继承了其他类的子类放到Thread中时，单继承的局限就体现出来了但是可以实现多个接口，所以第二种方法相对于第一种来说灵活许多其次，通过new Thread(Runnable runnable).start()启动线程的方式，若变量在runnable中定义，多个线程可以共用，因为来自同一个对象比较适合多个相同程序代码的线程去处理同一资源的情况 Android多线程方式主要集中在UI线程和其他线程的交互问题上 Thread,Handler,Message AsyncTask Runnable 第一种方式，new Thread()然后通过Handler sendMessage,由Handler的handleMessage方法实现对应的处理，完成与UI进程的交互 123456789101112131415private Handler mHandler = new Handler(){ public void handleMessage(Message msg) { /*do sth through msg */ }}public BadThread extends Thread { private final static String TAG = this.getClass().getName(); public void run() { /*coding*/ }};new BadThread().start(); 第二种方式，异步线程的方式，doInBackground()中执行任务，onPreExecute()准备工作，onPostExecute()任务结束后调用，onProgressUpdate与publishProgress配合使用，实现和UI线程的交互 123456789AsyncTask mLoadingTask = new AsyncTask(){ protected Object doInBackground(Object[] objects) { } protected void onProgressUpdate(Object[] values) { } ......}mLoadingTask.execute(); 第三种方式，Runnable对象，通过Handler直接Post等方法启动线程，实现与UI线程的交互 1234567private Runnable mRunnable = new Runnable(){ public void run() { /*do sth*/ }}mHandler.post(mRunnable);","link":"/2016/04/26/《Android Framework 之路》多线程/"},{"title":"《Android Framework 之路》BootAnimation（1）","text":"介绍 开机动画，BootAnimation，就是Android手机开机郭晨各种以一个展示给用户的界面，实际是一个多个帧组成的动画，在界面上进行一帧一帧的播放，形成开机动画的效果。本文针对Android5.1源码分析BootAnimation 源码分析文件产生Android平台的开机动画由system/bin下的bootanimation文件完成，而这个文件产生于 frameworks/base/cmds/bootanimation/Android.mk 12345678910111213141516171819202122232425262728293031LOCAL_PATH:= $(call my-dir)include $(CLEAR_VARS)LOCAL_SRC_FILES:= \\ bootanimation_main.cpp \\ AudioPlayer.cpp \\ BootAnimation.cppLOCAL_CFLAGS += -DGL_GLEXT_PROTOTYPES -DEGL_EGLEXT_PROTOTYPESLOCAL_C_INCLUDES += external/tinyalsa/includeLOCAL_SHARED_LIBRARIES := \\ libcutils \\ liblog \\ libandroidfw \\ libutils \\ libbinder \\ libui \\ libskia \\ libEGL \\ libGLESv1_CM \\ libgui \\ libtinyalsaLOCAL_MODULE:= bootanimationifdef TARGET_32_BIT_SURFACEFLINGERLOCAL_32_BIT_ONLY := trueendifinclude $(BUILD_EXECUTABLE) 编译结果为bootanimation的bin文件，所以，在有足够权限的前提下，在adb shell下执行bootanimation也是可以看到对应的开机动画效果的。 启动开机动画开机动画是以bin文件的形式存在于手机系统中，开机过程中通过init.rc定义 system/core/rootdir/init.rc 123456service bootanim /system/bin/bootanimation class core user graphics group graphics audio disabled//定义了disable，在开机过程中不会自动的启动 oneshot 这里不会启动，那么在哪里启动？ 由于开机动画对SurfaceFlinger有依赖，所以应该是在SurfaceFlinger启动之后再开始执行，看一下源码。 SurfaceFlinger的启动在init.rc文件中 12345service surfaceflinger /system/bin/surfaceflinger class core user system group graphics drmrpc onrestart restart zygote 与SurfaceFlinger相关的源码存在于frameworks\\native\\services\\surfaceflinger入口frameworks/native/services/surfaceflinger/main_surfaceflinger.cpp 123456789101112131415161718192021222324252627282930313233343536373839404142#if defined(HAVE_PTHREADS)#include &lt;sys/resource.h&gt;#endif#include &lt;cutils/sched_policy.h&gt;#include &lt;binder/IServiceManager.h&gt;#include &lt;binder/IPCThreadState.h&gt;#include &lt;binder/ProcessState.h&gt;#include &lt;binder/IServiceManager.h&gt;#include \"SurfaceFlinger.h\"using namespace android;int main(int, char**) { // When SF is launched in its own process, limit the number of // binder threads to 4. ProcessState::self()-&gt;setThreadPoolMaxThreadCount(4); // start the thread pool sp&lt;ProcessState&gt; ps(ProcessState::self()); ps-&gt;startThreadPool(); // instantiate surfaceflinger sp&lt;SurfaceFlinger&gt; flinger = new SurfaceFlinger();#if defined(HAVE_PTHREADS) setpriority(PRIO_PROCESS, 0, PRIORITY_URGENT_DISPLAY);#endif set_sched_policy(0, SP_FOREGROUND); // initialize before clients can connect flinger-&gt;init();//开机动画在这里执行，接着往下看 // publish surface flinger sp&lt;IServiceManager&gt; sm(defaultServiceManager()); sm-&gt;addService(String16(SurfaceFlinger::getServiceName()), flinger, false); // run in this thread flinger-&gt;run(); return 0;} frameworks/native/services/surfaceflinger/SurfaceFlinger.cpp 1234567void SurfaceFlinger::init() { ALOGI( \"SurfaceFlinger's main thread ready to run. \" \"Initializing graphics H/W...\"); .... // start boot animation startBootAnim();} 接着执行startBootAnim(); 12345void SurfaceFlinger::startBootAnim() { // start boot animation property_set(\"service.bootanim.exit\", \"0\"); property_set(\"ctl.start\", \"bootanim\");} 这里采用的是通过property_set中”ctl.start”的方式执行bootanim,这里是通过设置属性值的方式来启动的，属性值的设置采用的是C/S模式，socket连接，这里不详述，大致说下，这行代码会执行到 system/core/init/property_service.c 123456789101112131415161718192021222324252627282930313233343536373839void handle_property_set_fd(){ ...... switch(msg.cmd) { case PROP_MSG_SETPROP: ...... //这里很关键 if(memcmp(msg.name,\"ctl.\",4) == 0) { // Keep the old close-socket-early behavior when handling // ctl.* properties. close(s); if (check_control_mac_perms(msg.value, source_ctx)) { handle_control_message((char*) msg.name + 4, (char*) msg.value); } else { ERROR(\"sys_prop: Unable to %s service ctl [%s] uid:%d gid:%d pid:%d\\n\", msg.name + 4, msg.value, cr.uid, cr.gid, cr.pid); } //这里很关键 } else { if (check_perms(msg.name, source_ctx)) { property_set((char*) msg.name, (char*) msg.value); } else { ERROR(\"sys_prop: permission denied uid:%d name:%s\\n\", cr.uid, msg.name); } // Note: bionic's property client code assumes that the // property server will not close the socket until *AFTER* // the property is written to memory. close(s); } freecon(source_ctx); break; default: close(s); break; }} 接下来执行到system/core/init/init.c 123456789101112void handle_control_message(const char *msg, const char *arg){ if (!strcmp(msg,\"start\")) { msg_start(arg);//就是这条路 } else if (!strcmp(msg,\"stop\")) { msg_stop(arg); } else if (!strcmp(msg,\"restart\")) { msg_restart(arg); } else { ERROR(\"unknown control msg '%s'\\n\", msg); }} 接着往下执行 123456789101112131415161718192021222324252627static void msg_start(const char *name){ struct service *svc = NULL; char *tmp = NULL; char *args = NULL; if (!strchr(name, ':')) svc = service_find_by_name(name); else { tmp = strdup(name); if (tmp) { args = strchr(tmp, ':'); *args = '\\0'; args++; svc = service_find_by_name(tmp); } } if (svc) { service_start(svc, args); } else { ERROR(\"no such service '%s'\\n\", name); } if (tmp) free(tmp);} 这里找到“bootanim”然后执行service_start函数，这里就是启动bootanim的地方。","link":"/2016/08/07/《Android Framework 之路》BootAnimation（1）/"},{"title":"《Android HAL 之路》 HAL 简介","text":"HAL层概述 名称： HAL， Hardware Abstracting Layer，中文名字：硬件抽象层。 作用：对Linux内核驱动程序的封装，向上提供接口，屏蔽低层的实现细节。向上衔接Android Runtime和Framework，向下衔接驱动程序 产生原因：利益，竞争 Android代码结构中，HAL层的内容主要集中在Hardware目录中，结合之前讲解Camera模块的时候提到的 system/lib/hw/camera.$(TARGET_BOARD_PLATFORM).so HAL层的内容集成在动态库中，然后CameraService通过这个So访问其中的内容。 如何访问？ void CameraService::onFirstRef() hw_get_module(CAMERA_HARDWARE_MODULE_ID, (const hw_module_t **)&amp;rawModule) 每一个独立的HAL层的so，有一个与其对应的Id #define CAMERA_HARDWARE_MODULE_ID “camera” 定义在hardware/libhardware/include/hardware/camera_common.h 又或者 system/lib/hw/audio.primary.$(TARGET_BOARD_PLATFORM) frameworks/av/services/audioflinger/AudioFlinger.cpp rc = hw_get_module_by_class(AUDIO_HARDWARE_MODULE_ID, if_name, &amp;mod); #define AUDIO_HARDWARE_MODULE_ID “audio” 定义在 hardware/libhardware/include/hardware/audio.h 当然这里只是举个例子，Audio需要加载的模块不止这一个。 基本上每一个模块对应一个So，命名方式也是比较相似，xxx.$(TARGET_BOARD_PLATFORM),存放路径 system/lib/hw system/lib64/hw hw_get_module -&gt;hw_get_module_by_class 定义在hardware/libhardware/include/hardware/hardware.h 实现在hardware/libhardware/hardware.c 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950int hw_get_module(const char *id, const struct hw_module_t **module){ return hw_get_module_by_class(id, NULL, module);}……int hw_get_module_by_class(const char *class_id, const char *inst, const struct hw_module_t **module){ int i = 0; char prop[PATH_MAX] = {0}; char path[PATH_MAX] = {0}; char name[PATH_MAX] = {0}; char prop_name[PATH_MAX] = {0}; if (inst)//如果inst不为空，name= class_id.inst snprintf(name, PATH_MAX, \"%s.%s\", class_id, inst); else //如果为空的话，name = class_id strlcpy(name, class_id, PATH_MAX); //判断是否有配置项定义了对应的Hal层 snprintf(prop_name, sizeof(prop_name), \"ro.hardware.%s\", name); if (property_get(prop_name, prop, NULL) &gt; 0) { if (hw_module_exists(path, sizeof(path), name, prop) == 0) {//若存在则跳转 goto found; } } //循环查找ro.hardware，ro.product.board，ro.board.platform，ro.arch for (i=0 ; i&lt;HAL_VARIANT_KEYS_COUNT; i++) { if (property_get(variant_keys[i], prop, NULL) == 0) { continue; } if (hw_module_exists(path, sizeof(path), name, prop) == 0) { goto found; } } /* Nothing found, try the default */ if (hw_module_exists(path, sizeof(path), name, \"default\") == 0) { goto found; } return -ENOENT;found: /* load the module, if this fails, we're doomed, and we should not try * to load a different variant. */ return load(class_id, path, module);} 再看看hw_module_exists这个方法 12345678910111213141516static int hw_module_exists(char *path, size_t path_len, const char *name, const char *subname){ //拼凑HAL so库的名字 /vendor/lib/hw/name.subname.so或者/vendor/lib64/hw/name.subname.so snprintf(path, path_len, \"%s/%s.%s.so\", HAL_LIBRARY_PATH2, name, subname); if (access(path, R_OK) == 0) return 0; //拼凑HAL so库的名字 /system/lib/hw/name.subname.so或者/system/lib64/hw/name.subname.so snprintf(path, path_len, \"%s/%s.%s.so\", HAL_LIBRARY_PATH1, name, subname); if (access(path, R_OK) == 0) return 0; return -ENOENT;} 以audio其中的一个so为例，在源码中找一个芯片平台高通msm8974 system/lib/hw/audio.primary.msm8974.so 顺着以上的代码很好理解，当然这个msm8974必然是可以用过循环的那几个配置项其中的一个获取，否则就是 system/lib/hw/audio.promary.default.so 如何加载 以上代码跳转到found之后 return load(class_id, path, module); 12345678910111213141516171819static int load(const char *id, const char *path, const struct hw_module_t **pHmi){ …… //打开so,获取句柄 handle = dlopen(path, RTLD_NOW); …… /* Get the address of the struct hal_module_info. */ //获取地址空间的入口 const char *sym = HAL_MODULE_INFO_SYM_AS_STR; hmi = (struct hw_module_t *)dlsym(handle, sym); …… …… hmi-&gt;dso = handle; …… *pHmi = hmi; //赋值给传入参数 ……} 最后上层拿到的就是hw_module_t * 然后通过这个入口操作库中的内容，并且每一个HAL模块在定义自己的结构的时候也是需要按照一定的规范来执行。这个留着明天再写吧……","link":"/2016/04/20/《Android HAL 之路》 HAL 简介/"},{"title":"《Android Studio》 Android Studio 配置Code Style","text":"步骤一：下载 下载Square的代码规范 git clone https://github.com/square/java-code-styles.git 步骤二：安装 windows install.bat Macos/Linux install.sh 看下脚本内容：install.bat 12345678910111213141516171819202122REM Installs Square's IntelliJ configs into your user configs.@echo offecho Installing Square IntelliJ configs...setlocal enableDelayedExpansionfor /D %%i in (\"%userprofile%\"\\.AndroidStudio*) do call :copy_config \"%%i\"for /D %%i in (\"%userprofile%\"\\.IdeaIC*) do call :copy_config \"%%i\"for /D %%i in (\"%userprofile%\"\\.IntelliJIdea*) do call :copy_config \"%%i\"echo.echo Restart IntelliJ and/or AndroidStudio, go to preferences, and apply 'Square' or 'SquareAndroid'.exit /bREM sub function for copy config files:copy_configset config_dir=%~1\\configecho Installing to \"!config_dir!\"xcopy /s configs \"!config_dir!\"echo Done.echo.exit /b install.sh 123456789101112131415161718192021222324252627282930313233#!/bin/bash# Installs Square's IntelliJ configs into your user configs.echo \"Installing Square IntelliJ configs...\"CONFIGS=\"$( cd \"$( dirname \"${BASH_SOURCE[0]}\" )\" &amp;&amp; pwd )/configs\"for i in $HOME/Library/Preferences/IntelliJIdea* \\ $HOME/Library/Preferences/IdeaIC* \\ $HOME/Library/Preferences/AndroidStudio* \\ $HOME/.IntelliJIdea*/config \\ $HOME/.IdeaIC*/config \\ $HOME/.AndroidStudio*/configdo if [[ -d $i ]]; then # Install codestyles mkdir -p $i/codestyles cp -frv \"$CONFIGS/codestyles\"/* $i/codestyles # Install inspections mkdir -p $i/inspection cp -frv \"$CONFIGS/inspection\"/* $i/inspection # Install options (\"Exclude from Import and Completion\") mkdir -p $i/options cp -frv \"$CONFIGS/options\"/* $i/options fidoneecho \"Done.\"echo \"\"echo \"Restart IntelliJ and/or AndroidStudio, go to preferences, and apply 'Square' or 'SquareAndroid'.\" 从代码上看，和手动配置一样，但是脚本的执行效率事不言而喻的。执行完成之后大致就是如下log： 步骤三：配置 Preference &gt; CodeStyle &gt; Java and then you can choose what you like ~ over!","link":"/2017/03/26/《Android Studio》 Android Studio 配置Code Style/"},{"title":"《Android 基础（三 十）》Fragment (3) ~ PreferenceFragment","text":"简介 PreferenceFragment , 展示一系列的Preference条目并且当与用户有交互时，产生的值会自动保存到SharedPreferences中，通过PreferenceManager#getDefaultSharedPreferences(android.content.Context)可以查看对应的SharedPreferences的值。展示的Preferences的风格会随着系统而改变，通过XML文件可以快速的创建Preferences，官方推荐使用Fragment来实现这类功能。 创建XML Tag 意义 PreferenceScreen 必须作为根节点，代表整个Preferences屏幕 PreferenceCategory 一组Preferences,便于分类 SwitchPreference 两种状态的preference,开关 ListPreference 列表显示Preference, android:entries设置的内容是我们在设置时看到的内容，而android:entryValues就是保存在preferences.xml中的值 CheckBoxPreference 复选框Preference，勾选和不勾选 RingtonePreference Ringtone选择Preference EditTextPreference 编辑类Preference MultiSelectListPreference 多选类Preference 常用属性 属性 用法 android:title 标题 android:defaultValue 默认值 android:key SharedPreference中保存值时使用的Key值 android:entries 列表或者多选框的显示内容 android:entryValues 列表或者多选框保存过程中对应的值 代码使用XML文件123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;PreferenceScreen xmlns:android=\"http://schemas.android.com/apk/res/android\"&gt; &lt;PreferenceCategory android:title=\"无线和网络\"&gt; &lt;SwitchPreference android:defaultValue=\"false\" android:title=\"WLAN\" android:key=\"switch_preference_wlan\" /&gt; &lt;SwitchPreference android:defaultValue=\"false\" android:title=\"蓝牙\" android:key=\"switch_preference_bluetooth\" /&gt; &lt;ListPreference android:defaultValue=\"1\" android:title=\"休眠\" android:entries=\"@array/pref_sleep_interval\" android:entryValues=\"@array/pref_sleep_interval\" android:key=\"list_preference_sleep\" /&gt; &lt;/PreferenceCategory&gt; &lt;PreferenceCategory android:title=\"设备\" android:persistent=\"false\" android:orderingFromXml=\"false\"&gt; &lt;CheckBoxPreference android:defaultValue=\"false\" android:title=\"静音\" android:key=\"check_box_preference_virate\" /&gt; &lt;RingtonePreference android:defaultValue=\"\" android:title=\"铃声\" android:key=\"ringtone_preference_ringtone\" /&gt; &lt;/PreferenceCategory&gt; &lt;PreferenceCategory android:title=\"隐私和安全\"&gt; &lt;EditTextPreference android:defaultValue=\"Default value\" android:selectAllOnFocus=\"true\" android:singleLine=\"true\" android:title=\"设备名称\" android:key=\"edit_text_preference_devicename\" /&gt; &lt;MultiSelectListPreference android:title=\"辅助功能\" android:defaultValue=\"@array/pref_assit_function\" android:entries=\"@array/pref_assit_function\" android:entryValues=\"@array/pref_assit_function\" android:key=\"multi_select_list_preference_assit\" /&gt; &lt;/PreferenceCategory&gt;&lt;/PreferenceScreen&gt; arrays.xml文件12345678910111213141516171819&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;resources&gt; &lt;array name=\"pref_sleep_interval\"&gt; &lt;item&gt;30秒&lt;/item&gt; &lt;item&gt;1分钟&lt;/item&gt; &lt;item&gt;2分钟&lt;/item&gt; &lt;item&gt;5分钟&lt;/item&gt; &lt;item&gt;10分钟&lt;/item&gt; &lt;item&gt;30分钟&lt;/item&gt; &lt;/array&gt; &lt;array name=\"pref_assit_function\"&gt; &lt;item&gt;灵犀一指&lt;/item&gt; &lt;item&gt;指关节截屏&lt;/item&gt; &lt;item&gt;通话录音&lt;/item&gt; &lt;item&gt;白科技&lt;/item&gt; &lt;item&gt;黑科技&lt;/item&gt; &lt;/array&gt;&lt;/resources&gt; 自定义PreferenceFragment PreferenceFragment是抽象类，需要自己实现 1234567891011121314public class BaseFragment extends PreferenceFragment { @Override public void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); addPreferencesFromResource(R.xml.prefs); } @Override public boolean onPreferenceTreeClick(PreferenceScreen preferenceScreen, Preference preference) { Toast.makeText(getActivity(), preference.toString() + \" is Clicked\", Toast.LENGTH_LONG).show(); return super.onPreferenceTreeClick(preferenceScreen, preference); }} Activity中使用12345BaseFragment baseFragment = new BaseFragment();FragmentManager fm = getFragmentManager();FragmentTransaction transaction = fm.beginTransaction();transaction.replace(xxxxxx,baseFragment);transaction.commit(); 结果 SharedPreference结果&lt;中文乱码是系统问题&gt;","link":"/2016/11/18/《Android 基础（三 十）》Fragment (3) ~ PreferenceFragment/"},{"title":"《Android 基础（三十七）》 自定义ViewPagerIndicator","text":"简介学习Android，自定义View不可避免，之前一直忽视这块内容，现在开始学，应该不算太晚。从常见的ViewPagerIndicator开始，当然，万能的Github上包罗万象，好用的indicator也是不胜枚举，旨在学习自定义View的一般操作过程。 思路 做一个简单的ViewPagerIndicator，只支持平均大小的TextView，支持点，矩形和三角形。 使用LinearLayout作为父类； 定义indicator的颜色，高度和半径，当然也可以定义其他的属性； 使用到Path，Paint，Canvas等图形绘制的内容； 使用Kotlin 实现圆形indicator定义自定义属性styles.xml 123456&lt;attr name=\"y_indicator_color\" format=\"color\"/&gt;&lt;attr name=\"y_indicator_radius\" format=\"dimension\"/&gt;&lt;declare-styleable name=\"YVPDotIndicator\"&gt; &lt;attr name=\"y_indicator_color\"/&gt; &lt;attr name=\"y_indicator_radius\"/&gt;&lt;/declare-styleable&gt; 代码实现 通过设置ViewPager，然后从Adapter的getPageTitle方法获取TextView的显示内容，然后添加标签，然后绘制圆形指示器，通过ViewPager的滑动回调方法，设置圆形指示器的位置。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117class YVPDotIndicator : LinearLayout { private var mStartPos: Float = 0.0F//indicator开始位置 private var mWidthOffset: Int = 0//初始offset private var mPaint: Paint? = null private var mIndicatorColor = Color.parseColor(\"#FFFFFF\")//indicator颜色 private var mIndicatorRadius = 2//圆形indicator半径 private var mVp: ViewPager? = null private var pageListener = InterPageChangeListener() private var mTabCount: Int? = 0 private var mTabWidth: Float? = 0.0F private val defaultLayoutParams = LinearLayout.LayoutParams(0, LayoutParams.MATCH_PARENT, 1.0f) constructor(context: Context, attrs: AttributeSet) : this(context, attrs, 0) constructor(context: Context, attrs: AttributeSet, defStyle: Int) : super(context, attrs, defStyle) { setWillNotDraw(false) val dm = resources.displayMetrics val a = context.theme.obtainStyledAttributes(attrs, R.styleable.YVPDotIndicator, defStyle, 0) mIndicatorRadius = TypedValue.applyDimension(TypedValue.COMPLEX_UNIT_DIP, mIndicatorRadius.toFloat(), dm).toInt() mIndicatorColor = a.getColor(R.styleable.YVPDotIndicator_y_indicator_color, Color.parseColor(\"#FFFFFF\")) mIndicatorRadius = a.getDimensionPixelSize(R.styleable.YVPDotIndicator_y_indicator_radius, 2) a.recycle() initPaint() } /** * 设置ViewPager */ fun setViewPager(vp: ViewPager) { mVp = vp if (vp.adapter == null) { throw IllegalArgumentException() } notifyDataSetChanged() mVp?.addOnPageChangeListener(pageListener) } fun notifyDataSetChanged() { this.removeAllViews() mTabCount = mVp?.adapter?.count for (i in 0..mTabCount?.let { it - 1 } as Int) { addTextTab(i, mVp?.adapter?.getPageTitle(i).toString()) } } fun addTextTab(position: Int, title: String) { var tab = TextView(context) tab.text = title tab.gravity = Gravity.CENTER tab.setSingleLine() tab.isFocusable = true tab.setOnClickListener { mVp?.currentItem = position } this.addView(tab, position, defaultLayoutParams) } /** * 初始化画笔 */ private fun initPaint() { mPaint = Paint() mPaint?.color = mIndicatorColor mPaint?.isAntiAlias = true mPaint?.style = Paint.Style.FILL } override fun onSizeChanged(w: Int, h: Int, oldw: Int, oldh: Int) { super.onSizeChanged(w, h, oldw, oldh) mTabWidth = (w / childCount).toFloat() mStartPos = mTabWidth?.let { it/2 } as Float } override fun dispatchDraw(canvas: Canvas?) { canvas?.save() canvas?.translate(0.0F, height.toFloat()) canvas?.drawCircle(mStartPos + mWidthOffset, -mIndicatorRadius.toFloat(), mIndicatorRadius.toFloat(), mPaint) canvas?.restore() super.dispatchDraw(canvas) } inner class InterPageChangeListener: ViewPager.OnPageChangeListener { override fun onPageScrollStateChanged(state: Int) { } override fun onPageSelected(position: Int) { } override fun onPageScrolled(position: Int, positionOffset: Float, positionOffsetPixels: Int) { val tabWidth = screenWidth / childCount mWidthOffset = (tabWidth * position + tabWidth * positionOffset).toInt() invalidate() } } /** * 获取屏幕宽度 * @return */ private val screenWidth: Int get() { val windowManager = context.getSystemService(Context.WINDOW_SERVICE) as WindowManager val displayMetrics = DisplayMetrics() windowManager.defaultDisplay.getMetrics(displayMetrics) return displayMetrics.widthPixels }} 其他Indicator 类似的矩形指示器和三角形指示器，均可按照上面的方式实现。 具体效果 示例源码YVPIndicator","link":"/2017/07/28/《Android 基础（三十七）》 自定义ViewPagerIndicator/"},{"title":"《Android 基础（三十二）》 ViewFlipper","text":"简介 View Flipper，是ViewAnimator的子类，而ViewAnimator又是继承自FrameLayout，而FrameLayout就是平时基本上只显示一个子视图的布局，由于FrameLayout下不好确定子视图的位置，所以很多情况下子视图之前存在相互遮挡，这样就造成了很多时候我们基本上只要求FrameLayout显示一个子视图，然后通过某些控制来实现切换。正好，ViewFlipper帮我们实现了这个工作，我们需要做的就是，选择恰当的时机调用其恰当的方法即可 类结构 方法 意义 startFlipping 开始浏览 stopFlipping 停止浏览 setFlipInterval 设置View之间切换的时间间隔 getAccessibilityClassName 获取类名称 isFlipping 判断是否正在浏览 setAutoStart 设置是否自动开始浏览 isAutoStart 判断是否为自动开始浏览 基本使用动画定义scalein.xml 12345678910111213&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;set xmlns:android=\"http://schemas.android.com/apk/res/android\"&gt; &lt;scale android:duration=\"1000\" android:fromXScale=\"0.2\" android:fromYScale=\"0.2\" android:toYScale=\"1\" android:toXScale=\"1\" android:pivotX=\"50%\" android:pivotY=\"50%\" &gt; &lt;/scale&gt;&lt;/set&gt; scaleout.xml 123456789101112&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;set xmlns:android=\"http://schemas.android.com/apk/res/android\"&gt; &lt;scale android:duration=\"1000\" android:fromXScale=\"1\" android:fromYScale=\"1\" android:toYScale=\"0.2\" android:toXScale=\"0.2\" android:pivotX=\"50%\" android:pivotY=\"50%\"&gt; &lt;/scale&gt;&lt;/set&gt; 布局文件activity_main.xml 123456789101112131415161718192021222324252627282930313233343536373839404142&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:tools=\"http://schemas.android.com/tools\" android:id=\"@+id/activity_main\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:orientation=\"vertical\" tools:context=\"jzfp.gs.com.animationdemo.MainActivity\"&gt; &lt;android.support.v7.widget.Toolbar android:id=\"@+id/toolbar\" android:layout_width=\"match_parent\" android:layout_height=\"?attr/actionBarSize\" android:background=\"@color/colorPrimary\"&gt;&lt;/android.support.v7.widget.Toolbar&gt; &lt;！--渐入动画 和 渐出动画定义--&gt; &lt;ViewFlipper android:id=\"@+id/vf\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:inAnimation=\"@anim/scalein\" android:outAnimation=\"@anim/scaleout\"&gt; &lt;ImageView android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:background=\"@mipmap/one\" /&gt; &lt;ImageView android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:background=\"@mipmap/two\" /&gt; &lt;ImageView android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:background=\"@mipmap/three\" /&gt; &lt;/ViewFlipper&gt;&lt;/LinearLayout&gt; 左右滑动切换123456789101112131415161718192021222324252627282930313233343536public class MainActivity extends AppCompatActivity { private ViewFlipper viewFlipper = null; float PosX = 0, CurrentX = 0; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); Toolbar toolbar = (Toolbar) findViewById(R.id.toolbar); toolbar.setNavigationIcon(R.drawable.left); setSupportActionBar(toolbar);//设置ActionBar viewFlipper = (ViewFlipper) findViewById(R.id.vf); } @Override public boolean onTouchEvent(MotionEvent event) { switch (event.getAction()) { case MotionEvent.ACTION_DOWN: PosX = event.getX(); break; case MotionEvent.ACTION_MOVE: CurrentX = event.getX(); break; case MotionEvent.ACTION_UP: if (CurrentX - PosX &gt; 25.0) {//向右滑动切换到上一页 viewFlipper.showPrevious(); } else if (CurrentX - PosX &lt; -25.0) {//向左滑动，切换到下一页 viewFlipper.showNext(); } } return true; }} 实际效果","link":"/2016/11/28/《Android 基础（三十二）》 ViewFlipper/"},{"title":"《Android 基础（三）》 MVP模式","text":"前言 MVP，这里指的并不是篮球比赛中的MVP（最有价值球员），而是一种代码框架和设计思想，它是由MVC演变而来的。MVP模式（Model-View-Presenter）是MVC模式的一个衍生。主要目的是为了解耦，使项目易于维护。Model 是业务逻辑和实体模型,View 是包含Presenter的引用。所要做的就是当有交互时，调用Presenter里的对应方法。通常会通过Activity实现Presenter 是负责完成View于Model间的交互，从Model里取数据，返回给View处理好的数据。 MVC模式（Model-View-Controller） 主要目的是讲显示逻辑和业务逻辑独立出来，Model 是应用程序中用于处理应用程序数据逻辑的部分，View 是应用程序中处理数据显示的部分，Controller 是应用程序中处理用户交互的部分 从构造图上可以看到最主要的差异就是 MVC中是允许Model和View进行交互的，而MVP中很明显，Model与View之间的交互由Presenter完成。还有一点就是Presenter与View之间的交互是通过接口的 MVP使用方法代码结构 代码内容 LoginActivity.java 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162public class LoginActivity extends AppCompatActivity implements ILoginView { @Bind(R.id.usernameWrapper) TextInputLayout usernameWrapper; @Bind(R.id.passwordWrapper) TextInputLayout passwordWrapper; @Bind(R.id.bt_clear) Button btClear; @Bind(R.id.bt_login) Button btLogin; private LoginPresenterCompl loginPresenterCompl; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_login); ButterKnife.bind(this); loginPresenterCompl = new LoginPresenterCompl(this); } @OnClick({R.id.bt_clear, R.id.bt_login}) public void onClick(View view) { String username = usernameWrapper.getEditText().getText().toString(); String password = passwordWrapper.getEditText().getText().toString(); switch (view.getId()) { case R.id.bt_clear: loginPresenterCompl.clearText(); break; case R.id.bt_login: loginPresenterCompl.doLogin(username, password); break; } } @Override public void onLoginResult(boolean isLogged) { if (isLogged) { Toast.makeText(this, \"Logged in Successfully\", Toast.LENGTH_SHORT).show(); } else { Toast.makeText(this, \"Logged Failed\", Toast.LENGTH_SHORT).show(); } return; } @Override public void onClearText() { usernameWrapper.getEditText().setText(\"\"); passwordWrapper.getEditText().setText(\"\"); usernameWrapper.clearFocus(); passwordWrapper.clearFocus(); InputMethodManager imm = (InputMethodManager) getSystemService(Context.INPUT_METHOD_SERVICE); if (imm != null) { imm.hideSoftInputFromWindow(getWindow().getDecorView().getWindowToken(), 0); } }} LoginActivity实现ILoginView接口 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364public interface ILoginView { void onLoginResult(boolean isLogged); void onClearText();}```java LoginPresenterCompl.java实现ILoginPresenter接口```javapublic class LoginPresenterCompl implements ILoginPresenter{ private ILoginView iLoginView; Handler handler; public LoginPresenterCompl(ILoginView loginView) { iLoginView = loginView; handler = new Handler(Looper.getMainLooper()); } @Override public void doLogin(String username, String password) { final String tp_username = username; final String tp_password = password; new Thread(new Runnable() { @Override public void run() { boolean isLogged = false ; if(UserModel.isValidUser(tp_username , tp_password)) { isLogged = true; } final boolean tp_isLogged = isLogged; handler.post(new Runnable() { @Override public void run() { iLoginView.onLoginResult(tp_isLogged); } }); } }).start(); } @Override public void clearText() { new Thread(new Runnable() { @Override public void run() { handler.post(new Runnable() { @Override public void run() { iLoginView.onClearText(); } }); } }).start(); }} 1234567891011121314151617181920212223242526272829303132333435363738public interface ILoginPresenter { void doLogin(String username, String password); void clearText();}```java UserModel.java这个没有怎么使用，但是实际使用过程中不同的Model会有不同的处理方式```javapublic class UserModel { public String username; public String password; public UserModel(String username, String password) { this.username = username; this.password = password; } public String getUsername() { return username; } public void setUsername(String username) { this.username = username; } public String getPassword() { return password; } public void setPassword(String password) { this.password = password; } public static boolean isValidUser(String username, String password){ return (username.equals(\"guagua\") &amp;&amp; password.equals(\"guagua\")); }} 简约类图： 效果图","link":"/2016/05/31/《Android 基础（三）》 MVP模式/"},{"title":"《Android 基础（三十六）》 Spinner","text":"简介微调框提供一种方法，让用户可以从值集中快速选择一个值。默认状态下，微调框显示其当前所选的值。 触摸微调框可显示下拉菜单，其中列有所有其他可用值，用户可从中选择一个新值。 使用方法1234&lt;Spinner android:id=\"@+id/planets_spinner\" android:layout_width=\"fill_parent\" android:layout_height=\"wrap_content\" /&gt; 属性值 XML属性值 含义 android:dropDownHorizontalOffset 下拉框横向偏移量 android:dropDownSelector 下拉列表被选中行背景 android:dropDownVerticalOffset 下拉列表的纵向偏移量,相对于spinner控件 android:dropDownWidth 下拉列表子项宽度 android:gravity 选中项的位置摆放 android:popupBackground 下拉列表背景 android:prompt 弹出对话框的标题，只能使用字符串引用，不能直接使用字符串,”dialog”模式下可用 android:spinnerMode “spinner”,“dialog” 两种模式 android:entries 显示可选数据源,”@array/xxx”,这个属性继承自AbsSpinner 注意： android:dropDownHorizontalOffset使用过程中没有任何效果, Google Issue跟踪 https://code.google.com/p/android/issues/detail?id=70754 主要方法 两种模式简单使用Spinner1234567891011121314151617181920212223&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:tools=\"http://schemas.android.com/tools\" android:id=\"@+id/container\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:orientation=\"vertical\"&gt; &lt;Spinner android:id=\"@+id/sp\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:layout_marginTop=\"20dp\" android:dropDownSelector=\"@color/colorPrimaryDark\" android:dropDownVerticalOffset=\"50dp\" android:dropDownWidth=\"200dp\" android:entries=\"@array/fruit\" android:gravity=\"center_horizontal\" android:popupBackground=\"@color/colorAccent\" android:spinnerMode=\"dropdown\" /&gt;&lt;/LinearLayout&gt; Dialog123456789101112131415161718&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" android:id=\"@+id/container\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:orientation=\"vertical\"&gt; &lt;Spinner android:id=\"@+id/sp\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:layout_marginTop=\"20dp\" android:entries=\"@array/fruit\" android:prompt=\"@string/app_name\" android:spinnerMode=\"dialog\" /&gt;&lt;/LinearLayout&gt; 数据填充看下当我们设置”android:entries”，系统是如何帮我处理数据的。Spinner继承AbsSpinner, android:entries属性也是从其继承过来。 123456789101112131415161718public AbsSpinner(Context context, AttributeSet attrs, int defStyleAttr, int defStyleRes) { super(context, attrs, defStyleAttr, defStyleRes); initAbsSpinner(); final TypedArray a = context.obtainStyledAttributes( attrs, R.styleable.AbsSpinner, defStyleAttr, defStyleRes); //获取entrie对应的字符串数组 final CharSequence[] entries = a.getTextArray(R.styleable.AbsSpinner_entries); if (entries != null) { //构建 ArrayAdapter,使用默认布局 final ArrayAdapter&lt;CharSequence&gt; adapter = new ArrayAdapter&lt;CharSequence&gt;( context, R.layout.simple_spinner_item, entries); //设置下拉列表子项的布局 adapter.setDropDownViewResource(R.layout.simple_spinner_dropdown_item); // 和Spinner绑定 setAdapter(adapter); } a.recycle(); } 倘若我们不使用”android:entries”属性，依然可以使用简洁的代码来实现以上效果： 123456Spinner mSp = (Spinner)findViewById(R.id.sp);ArrayAdapter&lt;CharSequence&gt; adapter = ArrayAdapter.createFromResource(this,R.array.fruit, android.R.layout.simple_spinner_item); adapter.setDropDownViewResource(android.R.layout.simple_spinner_dropdown_item);mSp.setAdapter(adapter); 从代码上看和系统帮我们完成的内容相似，只是获取字符串数组的方式不一样了而已。createFromResource() 方法允许从字符串数组创建 ArrayAdapter。 此方法的第三个参数是布局资源，其定义所选选择如何显示在微调框控件中。 simple_spinner_item 布局由平台提供，是默认布局，除非您想为微调框外观定义自己的布局，否则应使用此布局。 然后，应调用 setDropDownViewResource(int) 指定适配器应用于显示微调框选择列表的布局（simple_spinner_dropdown_item 是平台定义的另一标准布局）。调用 setAdapter() 以将适配器应用到 Spinner。为微调框提供的选择可来自任何来源，但必须通过 SpinnerAdapter 来提供，例如，如果选择可通过数组获取，则通过 ArrayAdapter）来提供，如果选择可通过数据库查询获取，则通过 CursorAdapter 来提供。 从上面的代码可以看出，我们可以自定义的地方还是很多的，比如说两个布局：android.R.layout.simple_spinner_itemandroid.R.layout.simple_spinner_dropdown_item我们可以替换成自己的布局，实现一些自定义的效果 响应用户选择 当用户从下拉菜单中选择一个项目时，Spinner 对象会收到一个 on-item-selected 事件。 要为微调框定义选择事件处理程序，请实现 AdapterView.OnItemSelectedListener 接口以及相应的 onItemSelected() 回调方法。 12345678910111213141516mSp.setOnItemSelectedListener(new AdapterView.OnItemSelectedListener() { //parent The AdapterView where the selection happened //view The view within the AdapterView that was clicked //position The position of the view in the adapter //id The row id of the item that is selected @Override public void onItemSelected(AdapterView&lt;?&gt; parent, View view, int position, long id) { TextView textView = (TextView)view; Toast.makeText(MainActivity.this, textView.getText().toString() + \" was selected and position is \" + position, Toast.LENGTH_SHORT).show(); } @Override public void onNothingSelected(AdapterView&lt;?&gt; parent) { Toast.makeText(MainActivity.this, \"nothing selected \", Toast.LENGTH_SHORT).show(); } }); AdapterView.OnItemSelectedListener 需要 onItemSelected() 和 onNothingSelected() 回调方法。 备注 参考Google官方内容： https://developer.android.com/guide/topics/ui/controls/spinner.html","link":"/2017/04/09/《Android 基础（三十六）》 Spinner/"},{"title":"《Android 基础（二十七）》 Android Studio常用技巧（免费代理下载Google内容）","text":"简介由于Android Studio这个开发工具体量比较大，所以很多功能平时开发的时候不做积累，后续就会随着使用的减少渐渐忘却，所以，写笔记。 技巧集合开发版SHA1和发布版SHA1的获取 发布版 发布版就是使用自己创建的keystore文件 keytool -list -v -keystore xxxxxxxx 开发板 keytool -list -v -keystore C:/Users/xxx/.android/debug.keystore -alias androiddebugkey -storepass android -keypass android (xxx代表电脑当前用户名) 加快Gradle构建速度 Build,Execution,Deployment &gt; Compiler 添加 创建Asset文件夹，JNI文件夹等 下载镜像免费代理设置 Appearance &amp; Behavior &gt; System Settings &gt; HTTP Proxy 手动签名jarsgner-verbose-keystore[keystorePath]-singnedjar [apkOut] [apkln] [alias]","link":"/2016/11/04/《Android 基础（二十七）》 Android Studio常用技巧（免费代理下载Google内容）/"},{"title":"《Android 基础（九）》  Ndk配置与Demo","text":"介绍 The NDK is a toolset that allows you to implement parts of your app using native-code languages such as C and C++. For certain types of apps, this can be helpful so you can reuse existing code libraries written in these languages, but most apps do not need the Android NDK. Before downloading the NDK, you should understand that the NDK will not benefit most apps. As a developer, you need to balance its benefits against its drawbacks. Notably, using native code on Android generally does not result in a noticable performance improvement, but it always increases your app complexity. In general, you should only use the NDK if it is essential to your app—never because you simply prefer to program in C/C++. 配置 SDK Tool中安装Ndk 设置”Android NDK ocation”，若为自动下载，应该就是在SDK目录下 新建JNI目录（src/main/jni），并且在build.gradle下添加ndk内容 12345678910defaultConfig { applicationId “mraz.com.jnidemo” minSdkVersion 15 targetSdkVersion 24 versionCode 1 versionName “1.0” ndk { moduleName ‘jniTest’//这里就是生成so的模块名，[也就是libjniTest.so](http://xn--libjniTest-k92py04kef1a.so) } } Rebuild Project之后出现如下错误，则需要在gradle.properties中设置”android.useDeprecatedNdk=true” 新建一个Java类 实际使用经过上面的步骤，我们创建一个java类，其中定义两个native方法JniTest.java 12345678package mraz.com.jnidemo;public class JniTest { static { System.loadLibrary(\"jniTest\"); } public native String getHello(); public native int getSum(int a , int b);} 首先，我们需要生成这个类对应的native代码中的头文件，使用javah在Android Studio中使用Terminal，具有tab键联想功能以Demo为例，生成对应的头文件到jni目录下：javah -d app\\src\\main\\jni-classpath app\\build\\intermediates\\classes\\debug mraz.com.jnidemo.JniTest生成头文件mraz_com_jnidemo_JniTest.h 1234567891011121314151617181920212223242526272829/* DO NOT EDIT THIS FILE - it is machine generated */#include &lt;jni.h&gt;/* Header for class mraz_com_jnidemo_JniTest */#ifndef _Included_mraz_com_jnidemo_JniTest#define _Included_mraz_com_jnidemo_JniTest#ifdef __cplusplusextern \"C\" {#endif/* * Class: mraz_com_jnidemo_JniTest * Method: getHello * Signature: ()Ljava/lang/String; */JNIEXPORT jstring JNICALL Java_mraz_com_jnidemo_JniTest_getHello (JNIEnv *env, jobject object);/* * Class: mraz_com_jnidemo_JniTest * Method: getSum * Signature: (II)I */JNIEXPORT jint JNICALL Java_mraz_com_jnidemo_JniTest_getSum (JNIEnv *env, jobject object, jint a, jint b);#ifdef __cplusplus}#endif#endif 然后在JNI目录下创建对应的源文件mraz_com_jnidemo_JniTest.c具体实现如下： 12345678910111213141516171819#include \"mraz_com_jnidemo_JniTest.h\"#include&lt;jni.h&gt;//// Created by Mraz on 2016/6/28.//JNIEXPORT jstring JNICALL Java_mraz_com_jnidemo_JniTest_getHello(JNIEnv *env, jobject object){ return (*env)-&gt;NewStringUTF(env, \"hello\");}/* * Class: mraz_com_jnidemo_JniTest * Method: getSum * Signature: (II)I */JNIEXPORT jint JNICALL Java_mraz_com_jnidemo_JniTest_getSum (JNIEnv *env, jobject object, jint a, jint b) { return (a + b);} 对应java类JniTest.java，加载so，定义native方法 1234567891011package mraz.com.jnidemo;/** * Created by Mraz on 2016/6/28. */public class JniTest { static { System.loadLibrary(\"jniTest\"); } public native String getHello(); public native int getSum(int a , int b);} MainActivity.java中使用JniTest.java 1234567891011121314151617181920package mraz.com.jnidemo;import android.os.Bundle;import android.support.v7.app.AppCompatActivity;import android.util.Log;import android.widget.TextView;public class MainActivity extends AppCompatActivity { @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); JniTest jniTest = new JniTest(); Log.e(\"yidong\", \" hello = \" + jniTest.getHello()); Log.e(\"yidong\", \" sum = \" + jniTest.getSum(4, 6)); TextView textView = (TextView) findViewById(R.id.tv_jni); textView.setText(String.valueOf(jniTest.getSum(5, 6))); }} 结果","link":"/2016/06/28/《Android 基础（九）》  Ndk配置与Demo/"},{"title":"《Android 基础（二十一）》Android 屏幕适配","text":"基本概念什么是屏幕尺寸、屏幕分辨率、屏幕像素密度？ 屏幕尺寸是指屏幕对角线的长度。单位是英寸，1英寸=2.54厘米 屏幕分辨率是指在横纵向上的像素点数，单位是px，1px=1像素点，一般是纵向像素横向像素，如1280×720 屏幕像素密度是指每英寸上的像素点数，单位是dpi，即“dot per inch”的缩写，像素密度和屏幕尺寸和屏幕分辨率有关 屏幕像素密度计算公式 屏幕像素密度=纵向分辨率2+横向分辨率2屏幕尺寸 屏幕像素密度 = \\dfrac{\\sqrt{纵向分辨率^2 + 横向分辨率^2}}{屏幕尺寸} 屏幕像素密度=屏幕尺寸纵向分辨率2+横向分辨率2​​ 例如：计算Nexus5的屏幕像素密度： 屏幕尺寸：4.95inch、分辨率：1920×1080，屏幕像素密度：445 屏幕像素密度=19202+108024.95=445 屏幕像素密度 = \\dfrac{\\sqrt{1920^2 + 1080^2}}{4.95} =445屏幕像素密度=4.9519202+10802​​=445 计算结果可以对应上，证明这个结论是OK的。 什么是dp、dip、dpi、sp、px？ dp/dip—-&gt; dip和dp是一个意思，都是Density Independent Pixels的缩写，即密度无关像素，上面我们说过，dpi是屏幕像素密度，假如一英寸里面有160个像素，这个屏幕的像素密度就是160dpi，那么在这种情况下，dp和px如何换算呢？在Android中，规定以160dpi为基准，1dip=1px，如果密度是320dpi，则1dip=2px，以此类推。 dpi—&gt; 屏幕像素密度的单位，“dot per inch”的缩写,上面有介绍 sp—&gt; Scale-Independent Pixels的缩写，可以根据文字大小首选项自动进行缩放。Google推荐我们使用12sp以上的大小，通常可以使用12sp，14sp，18sp，22sp，最好不要使用奇数和小数。 px—&gt; 像素，物理上的绝对单位 什么是mdpi、hdpi、xdpi、xxdpi、xxxdpi？ 名称 像素密度范围 图标尺寸 比例 mdpi 120dpi~160dpi 48x48px 1 hdpi 160dpi~240dpi 72x72px 1.5 xhdpi 240dpi~320dpi 96x96px 2 xxhdpi 320dpi~480dpi 144x144px 3 xxxhdpi 480dpi~640dpi 192x192px 4 在处理图标的时候，通过mdpi的48x48然后按照一定的比例制作对应的图标放入对应的文件夹下即可。 解决方案使用wrap_content、match_parent、layout_weightwrap_content——————-&gt; 包裹内容match_parent/fill_parent —&gt; 填满父布局layout_weight——————-&gt; 布局权重前面两个不同多讲，layout_weight layout_weight只有在Linearlayout中才有效。之所以android:layout_weight会引起争议，是因为在设置该属性的同时，设置android:layout_width为wrap_content和match_parent会造成两种截然相反的效果。 公式：所占宽度=原来宽度+剩余空间所占百分比的宽度 一般情况，我们都是设置要进行比例分配的方向的宽度为0dp，然后再用权重进行分配A.width：B.widht = A.layout_weight : B.layout_weight 但是如果设置要进行比例分配的方向的宽度为match_parent,效果就截然相反。A.width：B.widht = B.layout_weight : A.layout_weight Google官方推荐，当使用weight属性时，将width设为0dip即可，效果跟设成wrap_content是一样的。这样weight就可以理解为占比了！ 使用线性布局和相对布局,尽量减少对绝对布局的使用线性布局中可以使用layout_weight的方式相对布局可以保持容器中子View相对位置的稳定绝对布局太过于死板 使用限定符尺寸限定符 res/layout-large/main.xml (适用与android 3.2之前) 最小限定符 res/layout-sw600dp/main.xml (Small Width, 适用于android 3.2之后) 使用布局别名这种方式是通过资源文件使用别名 123&lt;resource &gt;&lt;item name=\"main\" type=\"layout\"&gt;@layout/main_twopanes&lt;/item&gt;&lt;resource&gt; 替换后面的main_twopanes的名称为不同的布局，然后定义在不同的文件夹下，然后使用的过程中使用 1setContentView(R.layout.main) 加载的过程中，就可以根据屏幕尺寸和android版本加载不同的布局，但是别名都是main。 使用屏幕方向限定符横屏和竖屏的显示方式往往有一些差异。 横屏： res/values-sw600dp-land/layouts.xml 竖屏： res/values-sw600dp-port/layouts.xml 使用自动拉伸位图 自动拉伸位图，即android下特有的.9.png图片格式。 工具，draw9patch.bat 特点， 左边和上边点下一个像素或多个像素点，是选择了拉伸的像素，即把选择的像素点进行拉伸。选择的像素点越多，拉伸的程度也越大。 右边和下边是选择内容区域，在右边和下边画上直线，交叉的区域就是内容区域。","link":"/2016/09/21/《Android 基础（二十一）》Android 屏幕适配/"},{"title":"《Android 基础（二十三）》 Android Studio快捷键","text":"前言Android Studio对于快捷键的设置比较的灵活，开发者在从不同的平台转移到Android Studio进行Android开发的时候，应该都能找到合适的KeyMap和快捷键使用方式，因为AS直接其他平台的快捷键映射或者是自定义快捷键，比较的方便，此文只为记录。 KeyMap针对不同的平台有不同的映射 还可以自定义快捷键，右键点击一项，展开菜单，可以设置键盘快捷键和鼠标快捷键 针对不同的模块，都可以设置快捷键，比如说编辑过程中的一些操作以及IDE上方的主菜单，版本控制等等，尽管快捷键很方便，但是记忆也是比较费劲的，所以记住一些使用概率很高的快捷键基本上就可以很大程度的提高开发效率 常用快捷键 File 快捷键 打开Settings Ctrl + ALt + S 打开Project Struct Ctrl + ALt + Shift + S 保存 Ctrl + S 同步 Ctrl + Y 文件比较，选中一个文件后按快捷键 Ctrl + D 快捷创建 Ctrl + Alt + Insert Edit 快捷键 Undo Ctrl + Z Redo Ctrl + Shift + Z Cut Ctrl + X Copy Ctrl + C 复制路径名 Ctrl + Shift + C 复制引用 Ctrl + Shift +Alt + C Paste Ctrl + V 从复制历史中选择后粘贴 Ctrl + Shift + V 删除 Delete 查找 Ctrl + F 替换 Ctrl + R 浏览下一个查询结果 F3 浏览上一个查询结果 Shift + F3 向下查找当前选中内容 Ctrl + F3 选中所有和当前选中内容的查找结果 Ctrl + Alt + Shift + J 添加当前选中对象为下个查找对象 Alt + J 高亮选中对象的引用 Ctrl + Shift + F7 列选中模式开关 Alt + Shift + Insert 全选 Ctrl + A 扩大选中范围 Ctrl + W 缩小选中范围 Ctrl + Shift + W 自动补全 Ctrl + Shift + Enter 显示提示信息 Ctrl + Shift + Space 合并行 Ctrl + Shift + J 复制一行 Ctrl + D 删除一行 Ctrl + Y 选中内容切换大小写 Ctrl + Shift + U 增加缩进 Tab 减少缩进 Shift + Tab 备注 列选中 行选中, 在Column Selection Mode关闭的情况下，按住 Alt 键执行选中，依然可以出现列选中的效果 View 快捷键 JSON View Meta + Ctrl + Shift + N Navigation 快捷键 跳转到行 Ctrl + G 查找类 Ctrl + N 查找文件 Ctrl + Shift + N 查找Symbols Ctrl + Shift + Alt + N Back Ctrl + Alt + 向左箭头 Forward Ctrl + Alt + 向右箭头 上一个编辑过的地方 Ctrl + Alt + BackSpace 代码中下一个报错的地方 F2 代码中上一个报错的地方 Shift + F2 下一个方法 Alt + 向下箭头 上一个方法 Alt + 向上箭头 Code 快捷键 可以覆写的方法 Ctrl + O 可以覆写的方法 Ctrl + I 生成各种东西 Alt + Insert，一些插件提示的内容也可以用过Generate产生，比如如中的GsonFormat Surround With Ctrl + Alt + T 取消行注释，在执行一次Alt + / Alt + / 插入模板内容 Ctrl + J，这个可以用来快速打log，注释或者通用的方法，比较方便 用模板包裹 Ctrl + Alt + J 块注释 Alt + Shift + / 取消行注释，在执行一次Alt + Shift+ / Alt + Shift + / 格式化代码 Alt + Shift + L 解决缩进格式错误 Alt + Shift + I 快速导入包和删除不要的包 Alt + Shift + O Statements上移 Ctrl + Shift + 向上箭头 Statements下移 Ctrl + Shift + 向下箭头 行上移 Alt+ Shift + 向上箭头 行下移 Alt+ Shift + 向下箭头 Build 快捷键 构建项目 Ctrl + F9 Run 快捷键 Run Alt + Shift + F10 Debug Alt + Shift + F9","link":"/2016/09/25/《Android 基础（二十三）》 Android Studio快捷键/"},{"title":"《Android 基础（二十九）》 Fragment (2) ~ DialogFragment","text":"简介 上一篇简单的介绍了下Fragment的使用方法，这一篇主要看下DialogFragment。在android 3.0时被引入。是一种特殊的Fragment，用于在Activity的内容之上展示一个模态的对话框。典型的用于：展示警告框，输入框，确认框等等。之前的博客中有针对AlertDialog作出过详细的介绍，这个的功能和它比较类似，但是官方推荐的必然会有其牛逼之处~ 使用方法：参考Fragment使用方法和Fragment基本相同，但是DialogFragment多出来一个onCreateDialog方法 创建Fragment对应的布局文件123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" android:layout_width=\"250dp\" android:layout_height=\"wrap_content\" android:orientation=\"vertical\"&gt; &lt;TextView android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:layout_gravity=\"center_horizontal\" android:gravity=\"center_horizontal\" android:text=\"MOBLIE APP\" android:textColor=\"@color/colorAccent\" android:textStyle=\"bold|italic\" /&gt; &lt;android.support.design.widget.TextInputLayout android:layout_width=\"250dp\" android:layout_height=\"wrap_content\"&gt; &lt;EditText android:id=\"@+id/et_username\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:hint=\"Username\" /&gt; &lt;/android.support.design.widget.TextInputLayout&gt; &lt;android.support.design.widget.TextInputLayout android:layout_width=\"250dp\" android:layout_height=\"wrap_content\"&gt; &lt;EditText android:id=\"@+id/et_passwrod\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:hint=\"Password\" /&gt; &lt;/android.support.design.widget.TextInputLayout&gt; &lt;Button android:id=\"@+id/bt_login\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:text=\"登录\" /&gt;&lt;/LinearLayout&gt; 创建继承DialogFragment的Fragment并重写onCreateView方法12345678public class ContentFragment extends DialogFragment { @Nullable @Override public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) { View view = inflater.inflate(R.layout.content_fragment, container); return view; }} Activity中使用1234private void showRunDialog() { ContentFragment dialog = new ContentFragment(); dialog.show(getFragmentManager(), \"login\");//后面的字串是Tag } 效果 使用方法: DialogFragment独有创建Fragment对应的布局文件这个布局可以和上面相同，但是为了区分效果，单独编写一个 123456789101112131415161718192021222324252627282930313233343536373839404142&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:orientation=\"vertical\"&gt; &lt;TextView android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:layout_gravity=\"center_horizontal\" android:gravity=\"center\" android:text=\"Mobile APP\" android:textColor=\"@color/colorAccent\" android:textSize=\"20sp\" android:textStyle=\"bold|italic\" /&gt; &lt;android.support.design.widget.TextInputLayout android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\"&gt; &lt;EditText android:id=\"@+id/et_username\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:hint=\"Username\" /&gt; &lt;/android.support.design.widget.TextInputLayout&gt; &lt;android.support.design.widget.TextInputLayout android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\"&gt; &lt;EditText android:id=\"@+id/et_passwrod\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:hint=\"Password\" /&gt; &lt;/android.support.design.widget.TextInputLayout&gt;&lt;/LinearLayout&gt; 创建继承DialogFragment的Fragment并重写onCreateDialog方法123456789101112131415161718192021222324252627282930public class DialogContent extends DialogFragment { @RequiresApi(api = Build.VERSION_CODES.LOLLIPOP) @Override public Dialog onCreateDialog(Bundle savedInstanceState) { AlertDialog.Builder builder = new AlertDialog.Builder(getActivity()); final View view = getActivity().getLayoutInflater().inflate(R.layout.content_dialog, null, false); builder.setView(view) .setPositiveButton(\"登录\", new DialogInterface.OnClickListener() { @Override public void onClick(DialogInterface dialog, int which) { final String username = ((EditText) (view.findViewById(R.id.et_username))).getText().toString(); final String password = ((EditText) (view.findViewById(R.id.et_passwrod))).getText().toString(); ((MainActivity) getActivity()).setUsernameAndPassword(username, password);//与Activity交互，也可以通过实现接口的方式实现 } }) .setNegativeButton(\"注册\", new DialogInterface.OnClickListener() { @Override public void onClick(DialogInterface dialog, int which) { final String username = ((EditText) (view.findViewById(R.id.et_username))).getText().toString(); final String password = ((EditText) (view.findViewById(R.id.et_passwrod))).getText().toString(); ((MainActivity) getActivity()).setUsernameAndPassword(\"注册\", \"注册\");//与Activity交互，也可以通过实现接口的方式实现 } }); return builder.create(); }} 在onCreateDialog方法中，通过创建AlertDialog的方式来生成Dialog Activity中使用方式和上面相同效果 优势屏幕旋转过程中对话框不消失","link":"/2016/11/08/《Android 基础（二十九）》 Fragment (2) ~ DialogFragment/"},{"title":"《Android 基础（二十五）》 View Animation","text":"简介 视图动画，主要包括位移，透明度，旋转和缩放，View本身的属性并没有发生变化，只是在这个视图上添加一些渐变的效果，所以总体而言，视图动画只能实现一些简单的动画效果，属性动画功能更强大。 基本使用res/anim目录下创建动画资源文件,存放帧动画和渐变动画，主要tag: set, alpha, scale, tranlate, rotate分别对应动画集合，透明动画，缩放动画，位移动画，旋转动画 格式12345678910111213141516171819202122232425262728293031323334353637&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;set xmlns:android=\"http://schemas.android.com/apk/res/android\" android:interpolator=\"@[package:]anim/interpolator_resource\" android:shareInterpolator=[\"true\" | \"false\"] &gt;//子元素是否共享这个插值器 &lt;!--[0.0 , 1.0] --&gt; &lt;alpha android:fromAlpha=\"float\" android:toAlpha=\"float\" /&gt; &lt;!--[0.0, ？] --&gt; &lt;!-- pivotX,pivotY用来控制缩放的中心点--&gt; &lt;scale android:fromXScale=\"float\" android:toXScale=\"float\" android:fromYScale=\"float\" android:toYScale=\"float\" android:pivotX=\"float\" android:pivotY=\"float\" /&gt; &lt;!-- in pixels relative to the normal position (such as \"5\"), in percentage relative to the element width (such as \"5%\"), or in percentage relative to the parent width (such as \"5%p\")--&gt; &lt;translate android:fromXDelta=\"float\" android:toXDelta=\"float\" android:fromYDelta=\"float\" android:toYDelta=\"float\" /&gt; &lt;!-- android:pivotX, android:pivotY n pixels relative to the object's left edge (such as \"5\"), in percentage relative to the object's left edge (such as \"5%\"), or in percentage relative to the parent container's left edge (such as \"5%p\") --&gt; &lt;rotate android:fromDegrees=\"float\" android:toDegrees=\"float\" android:pivotX=\"float\" android:pivotY=\"float\" /&gt; &lt;set&gt; ... &lt;/set&gt;&lt;/set&gt; Scale1234567891011&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;set xmlns:android=\"http://schemas.android.com/apk/res/android\"&gt; &lt;scale android:duration=\"2000\"//时常(运行代码不要在这里做注释) android:pivotX=\"50%\" android:pivotY=\"50%\"//缩放中心点为视图的中心 android:fromXScale=\"1.0\"//起点大小 android:fromYScale=\"1.0\" android:toXScale=\"2.0\"//目标大小 android:toYScale=\"2.0\" /&gt;&lt;/set&gt; Alpha12345678&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;set xmlns:android=\"http://schemas.android.com/apk/res/android\"&gt; &lt;alpha android:duration=\"2000\"//时常 android:fromAlpha=\"1.0\"//起始透明度 android:interpolator=\"@android:anim/accelerate_decelerate_interpolator\"//插值 android:toAlpha=\"0.0\" /&gt;//目标透明度&lt;/set&gt; Rotate12345678910&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;set xmlns:android=\"http://schemas.android.com/apk/res/android\"&gt; &lt;rotate android:duration=\"2000\"//时常 android:fromDegrees=\"0\"//起始角度 android:interpolator=\"@android:anim/decelerate_interpolator\"//插值 android:pivotX=\"50%\" android:pivotY=\"50%\"//旋转中心点为视图中心 android:toDegrees=\"180\" /&gt;//目标角度&lt;/set&gt; Translate12345678910&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;set xmlns:android=\"http://schemas.android.com/apk/res/android\"&gt; &lt;translate android:duration=\"2000\"//时常 android:fromXDelta=\"0\" android:fromYDelta=\"0\"//起始位置相对于视图的位移 android:interpolator=\"@android:anim/accelerate_interpolator\" android:toXDelta=\"300\" android:toYDelta=\"300\" /&gt;//目标位置相对于视图的位移&lt;/set&gt; Set将上面的代码各种渐变动画全部防止在&lt; set &gt;tag下，实现共同效果 备注代码中加载动画，例如旋转动画： 12rotateAnim = AnimationUtils.loadAnimation(this, R.anim.rotate_anim);imageView.startAnimation(rotateAnim);","link":"/2016/10/16/《Android 基础（二十五）》 View Animation/"},{"title":"《Android 基础（二十二）》 EditText 无法显示完全以及尝鲜Android  N","text":"简介最近将Android Studio更新到了2.2 ,模拟器的Android版本也来到了最新的Nougat。 问题最近遇到一个问题，EditText只读的情况下，在ScrollView下无法滚动，原因应该就是滑动事件优先被ScrollView消耗，导致EditText并没有收到滚动事件，导致如是问题 解决办法123456789101112131415EditText editText = (EditText) findViewById(R.id.EditText01);EtOne.setOnTouchListener(new OnTouchListener() { @Override public boolean onTouch(View v, MotionEvent event) { if (v.getId() == R.id.comment1) { v.getParent().requestDisallowInterceptTouchEvent(true);//组织父节点消耗滑动事件 switch (event.getAction() &amp; MotionEvent.ACTION_MASK) { case MotionEvent.ACTION_UP: v.getParent().requestDisallowInterceptTouchEvent(false); break; } } return false; }}); 这种情况下，EditText应该是可编辑状态，但是我们的要求是只读，也就是无法编辑，这种情况下，如果用户点击到了文本区域内，会弹出输入法，用户便可以直接输入，这个问题如何解决 解决办法阻止输入法弹出123456789101112editText = (EditText) findViewById(R.id.editText);editText.setOnTouchListener(new View.OnTouchListener() { public boolean onTouch(View v, MotionEvent event) { // TODO Auto-generated method stub int inType = editText.getInputType(); // backup the input type editText.setInputType(InputType.TYPE_NULL); // disable soft input editText.onTouchEvent(event); // call native handler editText.setInputType(inType); // restore input type editText.setSelection(editText.getText().length()); return true; }}); 阻止输入法弹出1edittext.setKeyListener(null); Sets the key listener to be used with this TextView. This can be nullto disallow user input. Note that this method has significant andsubtle interactions with soft keyboards and other input method:see {@link KeyListener#getInputType() KeyListener.getContentType()}for important details. Calling this method will replace the currentcontent type of the text view with the content type returned by thekey listener. Android Nougat模拟器 Android Studio2.2上的模拟器速度还是比较快的。 Google原生的内容依然是那么的干净，清晰，功能强大。模拟器的功能也是比较健全的。 N版本具体更新内容，请关注官网： https://developer.android.com/about/versions/nougat/android-7.0.html Android Studio 2.2整体界面风格没有很大的变化，图标有变化，给我印象最深的是UI编辑器 编辑器中多了一个视图，上方多了一些按钮，右侧的属性可能更丰富了吧，之前我都是全部手写的，真是浪费好的开发工具。具体的更新内容请关注官网： https://developer.android.com/studio/releases/index.html","link":"/2016/09/22/《Android 基础（二十二）》 EditText 无法显示完全以及尝鲜Android  N/"},{"title":"《Android 基础（二十四）》 EditText","text":"简介 A text field allows the user to type text into your app. It can be either single line or multi-line. Touching a text field places the cursor and automatically displays the keyboard. In addition to typing, text fields allow for a variety of other activities, such as text selection (cut, copy, paste) and data look-up via auto-completion.You can add a text field to you layout with the EditText object. You should usually do so in your XML layout with a &lt; EditText &gt; element. 文本区域给用户输入文字提供了方便，它可以是单行的也可以是多行的。触摸一个文本区域获取光标并且自动弹出键盘。除了可以输入文字，文本区域还可以用来执行如文本选中（剪切，复制和粘贴）和通过自动补全实现的数据查询等功能。你可以通过在布局中添加一个EditText对象来实现文本区域，当然也可以在布局文件中添加EditText Tag. 指定键盘类型Text fields can have different input types, such as number, date, password, or email address. The type determines what kind of characters are allowed inside the field, and may prompt the virtual keyboard to optimize its layout for frequently used characters. You can specify the type of keyboard you want for your EditText object with the android:inputType attribute. For example, if you want the user to input an email address, you should use the textEmailAddress input type: 文本区域有不同的输入类型，如数字，日期，密码或者邮箱地址。输入类型决定了文本区域内允许输入的字符类型，同时也提示着虚拟键盘给用户展示更加常用的字符集合。我们可以通过使用 android:inputType 属性来明确我们的输入框想要的键盘类型。例如，如果你想要输入邮箱地址，你可以使用textEmailAddress输入类型。 123456&lt;EditText android:id=\"@+id/email_address\" android:layout_width=\"fill_parent\" android:layout_height=\"wrap_content\" android:hint=\"@string/email_hint\" android:inputType=\"textEmailAddress\" /&gt; android:inputType 解释 “none” 不弹出键盘 “text” 普通文本键盘 “textEmailAddress” 普通文本键盘，”@” “textUri” 普通文本键盘，”/“ “number” 数字键盘 “phone” Phone-Style键盘 控制其他行为android:inputType属性不仅可以用来控制显示特定的键盘类型，而且还可以用来明确一些键盘的行为，例如是否大写，自动补全或者是拼写建议等。android:inputType使用按位与的方式，所以可以指定多种行为 android:inputType 解释 “textCapSentences” 正常的文本键盘但是每一句话第一个字母大写 “textCapWords” 正常文本键盘但是每一个单词的第一个字母大写 “textAutoCorrect” 自动提示拼写错误 “textPassword” 输入的文字都变成点点 “textMultiLine” 允许输入多行文本，可以换行 关于android:inputType属性有很多，上面都只是一些例子，感觉应该很全了，大家可以自行研究。 指定键盘行为除了改变键盘的输入类型,Android允许当用户完成输入指定一个动作，出现的操作指定按钮的回车键和动作,如“搜索”或“发送”键。例如： 1234567&lt;EditText android:id=\"@+id/search\" android:layout_width=\"fill_parent\" android:layout_height=\"wrap_content\" android:hint=\"@string/search_hint\" android:inputType=\"text\" android:imeOptions=\"actionSearch\" /&gt; 键盘会显示出“搜索”按钮，横屏之后不仅键盘会出现搜索按钮，右侧还会出现对应的字串 主要是对 android:imeOptions 属性的使用这么多的行为可供选择，上面只是举例说明 对键盘中定义的行为的响应通过android:imeOptions 定义的行为，我们可以对它定义的行为作出响应.我们可以使用TextView.OnEditorActionListener来进行事件的监听和处理。通过如 IME_ACTION_SEND 或者IME_ACTION_SEARCH等事件ID来针对不同的事件行为做出不同的处理。例如 123456789101112EditText editText = (EditText) findViewById(R.id.search);editText.setOnEditorActionListener(new OnEditorActionListener() { @Override public boolean onEditorAction(TextView v, int actionId, KeyEvent event) { boolean handled = false; if (actionId == EditorInfo.IME_ACTION_SEND) { sendMessage(); handled = true; } return handled; }}); 自定义输入完成后键盘行为的标签android:imeActionLabel属性就是用来设置这个内容的 1234567&lt;EditText android:id=\"@+id/launch_codes\" android:layout_width=\"fill_parent\" android:layout_height=\"wrap_content\" android:hint=\"@string/enter_launch_codes\" android:inputType=\"number\" android:imeActionLabel=\"启动\" /&gt; 自动补全建议使用AutoCompleteTextView 布局定义123456&lt;AutoCompleteTextView android:completionThreshold=\"1\"//默认是2，这就是为什么默认输入两个字符才能显示出提示信息的原因 android:id=\"@+id/autocomplete_country\" android:layout_width=\"match_parent\" android:text=\"@android:string/dialog_alert_title\" android:layout_height=\"wrap_content\" /&gt; 代码实现1234567891011121314@Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); // Get a reference to the AutoCompleteTextView in the layout AutoCompleteTextView textView = (AutoCompleteTextView) findViewById(R.id.autocomplete_country); // Get the string array String[] countries = getResources().getStringArray(R.array.countries_array); // Create the adapter and set it to the AutoCompleteTextView ArrayAdapter&lt;String&gt; adapter = new ArrayAdapter&lt;String&gt;(this, android.R.layout.simple_list_item_1, countries); textView.setAdapter(adapter);//设置提示内容 } 提示数组12345678910&lt;string-array name=\"countries_array\"&gt; &lt;item&gt;Afghanistan&lt;/item&gt; &lt;item&gt;Albania&lt;/item&gt; &lt;item&gt;Algeria&lt;/item&gt; &lt;item&gt;American Samoa&lt;/item&gt; &lt;item&gt;Andorra&lt;/item&gt; &lt;item&gt;Angola&lt;/item&gt; &lt;item&gt;Anguilla&lt;/item&gt; &lt;item&gt;Antarctica&lt;/item&gt;&lt;/string-array&gt; 备注内容主要来自于Android官网教程：[https://developer.android.com/guide/topics/ui/controls/text.html(https://developer.android.com/guide/topics/ui/controls/text.html)","link":"/2016/09/28/《Android 基础（二十四）》 EditText/"},{"title":"《Android 基础（二十五）》Frame Animation","text":"简介Frame Animation, 逐帧动画，通过定义一系列的Drawable对象来实现动画效果，可以用来作为视图的背景。Frame Animation在代码中体现为AnimationDrawable对象，可以通过xml文件快创建，放在在/res/drawable/目录下，设置为视图背景后，调用start()方法即可执行逐帧动画。 XML文件Tags: &lt; animation-list &gt; 作为父节点，代表Animation Drawable &lt; item &gt;作为子节点，代表逐帧动画内容，一张一张图片 Attributes: 属性 含义 android:oneshot=”false true” android:variablePadding=”false true” android:visible=”false true” android:drawable=”@drawable/xxxxx” item图片资源 android:duration=“xxxxx” drawable播放时间，单位ms Res:/res/drawable/{folder} 1234567891011121314&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;animation-list xmlns:android=\"http://schemas.android.com/apk/res/android\" android:id=\"@+id/selected\" android:oneshot=\"true\" android:variablePadding=\"false\" android:visible=\"true\"&gt; &lt;item android:drawable=\"@drawable/ic_action_add\" android:duration=\"500\"/&gt; &lt;item android:drawable=\"@drawable/ic_action_anchor\" android:duration=\"500\"/&gt; &lt;item android:drawable=\"@drawable/ic_action_alarm\" android:duration=\"500\"/&gt; &lt;item android:drawable=\"@drawable/ic_action_amazon\" android:duration=\"500\"/&gt; &lt;item android:drawable=\"@drawable/ic_action_ac\" android:duration=\"500\"/&gt;&lt;/animation-list&gt; Coding使用XML资源12345imageView.setBackgroundResource(R.drawable.frame_anim);//设置背景Drawable bgDrawable = imageView.getBackground();//获取背景if(bgDrawable instanceof AnimationDrawable) { ((AnimationDrawable) bgDrawable).start();//如果为AnimationDrawable则执行动画} 纯代码实现1234567891011121314151617181920……imageView.setBackground(createAnimationDrawable());//设置背景Drawable bg = imageView.getBackground();if(bg instanceof AnimationDrawable) { ((AnimationDrawable) bg).start();//开始动画}……private AnimationDrawable createAnimationDrawable() { AnimationDrawable animationDrawable = new AnimationDrawable(); animationDrawable.addFrame(getResources().getDrawable(R.drawable.ic_action_add), 500); animationDrawable.addFrame(getResources().getDrawable(R.drawable.ic_action_anchor), 500); animationDrawable.addFrame(getResources().getDrawable(R.drawable.ic_action_alarm), 500); animationDrawable.addFrame(getResources().getDrawable(R.drawable.ic_action_amazon), 500); animationDrawable.addFrame(getResources().getDrawable(R.drawable.ic_action_ac), 500); animationDrawable.setOneShot(false); animationDrawable.setVisible(true,true); return animationDrawable;} 效果图","link":"/2016/10/24/《Android 基础（二十五）》Frame Animation/"},{"title":"《Android 基础（二十八）》 Fragment (1)","text":"简介Fragment，碎片，常用的内容，但是一直没有系统的学习下它的使用方法，花几天抽空看看随便记录一下。 生命周期 来自官网的图片一目了然。 自测试结果： 基本使用自定义一个Fragment：BaseFragment1234567891011121314151617181920212223/*带参数构造方法*/public static BaseFragment newInstance(String content) { Bundle args = new Bundle(); args.putString(\"CONTENT\", content); BaseFragment fragment = new BaseFragment(); fragment.setArguments(args);//传递参数，设置内容文本 return fragment;}@Nullable@Overridepublic View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) { Log.i(TAG, \"onCreateView\"); View view = inflater.inflate(R.layout.content_fragment , container, false); Bundle args = getArguments();//获取参数并设置文本内容 if (args != null) { String content = args.getString(\"CONTENT\"); tv = (TextView) view.findViewById(R.id.tv_content); tv.setText(content); } return view;} 对应布局文件12345678910&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;TextView android:id=\"@+id/tv_content\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:layout_gravity=\"center\" android:gravity=\"center\" android:textColor=\"@color/colorAccent\" android:textSize=\"30sp\" android:textStyle=\"italic|bold\" /&gt; 主Activity布局文件123456789101112131415161718192021&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:tools=\"http://schemas.android.com/tools\" android:id=\"@+id/activity_main\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:orientation=\"vertical\" tools:context=\"jzfp.gs.com.animationdemo.MainActivity\"&gt; &lt;!-- 工具栏--&gt; &lt;android.support.v7.widget.Toolbar android:id=\"@+id/toolbar\" android:layout_width=\"match_parent\" android:layout_height=\"?attr/actionBarSize\" android:background=\"@color/colorPrimary\"&gt;&lt;/android.support.v7.widget.Toolbar&gt; &lt;!-- 内容区域--&gt; &lt;FrameLayout android:id=\"@+id/fl_content\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\"&gt;&lt;/FrameLayout&gt;&lt;/LinearLayout&gt; Fragment切换1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465public class MainActivity extends AppCompatActivity { BaseFragment leftFragment = null;//左侧fragment BaseFragment rightFragment = null;//右侧Fragment BaseFragment defaultFragment= null;//默认Fragment @TargetApi(Build.VERSION_CODES.LOLLIPOP) @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); Toolbar toolbar = (Toolbar) findViewById(R.id.toolbar); toolbar.setNavigationIcon(R.drawable.left); setSupportActionBar(toolbar);//设置ActionBar toolbar.setNavigationOnClickListener(new View.OnClickListener() { @Override public void onClick(View v) { showLeftFragment(); } }); defaultFragment = BaseFragment.newInstance(\"This is default fragment\"); FragmentManager fm = getSupportFragmentManager(); FragmentTransaction transaction = fm.beginTransaction(); transaction.replace(R.id.fl_content, defaultFragment); transaction.commit();//显示默认碎片 } @Override public boolean onCreateOptionsMenu(Menu menu) { getMenuInflater().inflate(R.menu.toolbar, menu); return true; } @Override public boolean onOptionsItemSelected(MenuItem item) { int id = item.getItemId(); switch(id){ case R.id.right: showRightFragment();break; default:break; } return true; } public void showLeftFragment(){ FragmentManager fm = getSupportFragmentManager(); FragmentTransaction transaction = fm.beginTransaction(); if(leftFragment == null) { leftFragment = BaseFragment.newInstance(\"This is Left Fragment\"); } transaction.replace(R.id.fl_content, leftFragment); transaction.commit(); } public void showRightFragment(){ FragmentManager fm = getSupportFragmentManager(); FragmentTransaction transaction = fm.beginTransaction(); if(rightFragment == null) { rightFragment = BaseFragment.newInstance(\"This is Right Fragment\"); } transaction.replace(R.id.fl_content, rightFragment); transaction.commit(); }} 结果点击左右按钮切换fragment","link":"/2016/11/08/《Android 基础（二十八）》 Fragment (1)/"},{"title":"《Android 基础（五）》MVVM","text":"介绍 MVVM，Model-View-ViewModel，与上次讲的MVP模式比较的类似，MVP中需要大量的接口文件，而MVVM模式下，View和ViewModel直接关联，使用上比较方便，简化了代码.大致的结构图如下：可以看待View和ViewModel是双向的交互，这一点很关键 DataBinding Data Binding Library是Google推出的，可以说是针对MVVM模式的支持库，通过在Layout中进行数据的访问，来实现View和Data的双向绑定。不仅使用灵活，用法丰富，而且支持也是相当的广泛，很大程度上降低了代码量和耦合性，减少了开发者的压力。 build.gradle123dataBinding { enabled= true} 这样使用比较的方法，当然这个需要当前的Gradle版本支持这个属性 Layout Data1234567891011121314&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;layout xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:app=\"http://schemas.android.com/apk/res-auto\" xmlns:tools=\"http://schemas.android.com/tools\"&gt; &lt;data&gt; &lt;import type=\"com.example.mraz.mvvmdemo.Model.User\"&gt;&lt;/import&gt; &lt;variable name=\"user\" type=\"User\"&gt; &lt;/variable&gt; &lt;/data&gt; &lt;LinearLayout ... &lt;/LinearLayout&gt;&lt;/layout&gt; 最完成使用Layout属性，通过data属性值，添加需要在布局文件中使用的变量和对应的变量类型，也可以先import文件，然后直接使用，不然就需要在type中使用类型的完整路径，当遇到相同的类名的时候，DataBinding支持别名的定义，alias Layout Access Data布局文件文件中如何实现对绑定数据的访问 1234567891011&lt;TextView android:id=\"@+id/tv_username\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:text=\"@{user.getUsername()}\" /&gt;&lt;TextView android:id=\"@+id/tv_password\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:text=\"@{user.getPassword()}\" /&gt; 使用格式为“@{ }”，大括号中的使用方式与代码中的基本无差别，可以使用方法，也可以使用对应的成员变量，当然如果权限允许的话，如果要直接访问private变量或者方法，显然是不现实的。 Activity Set Data123456789101112131415161718192021222324252627282930313233public class MainActivity extends AppCompatActivity { User user = new User(\"\", \"\"); @Bind(R.id.et_username) EditText etUsername; @Bind(R.id.et_password) EditText etPassword; @Bind(R.id.tv_username) TextView tvUsername; @Bind(R.id.tv_password) TextView tvPassword; ActivityMainBinding activityMainBinding; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); activityMainBinding = DataBindingUtil.setContentView(this, R.layout.activity_main); ButterKnife.bind(this);} @OnTextChanged(value = R.id.et_username, callback = OnTextChanged.Callback.TEXT_CHANGED) void onUserNameChanged(CharSequence s,int start,int before,int count) { user.setUsername(s.toString()); activityMainBinding.setUser(user); } @OnTextChanged(value = R.id.et_password, callback = OnTextChanged.Callback.TEXT_CHANGED) void onPasswordChangedps(CharSequence s,int start,int before,int count) { user.setPassword(s.toString()); activityMainBinding.setUser(user); }} 几个关键点： ActivityMainBinding activityMainBinding这里定义的变量类型ActivityMainBinding 与布局文件对应activity_main ——-&gt; ActivityMainBindingfirst_second ——-&gt; FirstSecondingBindingBinding类的命名是基于所述layout文件的名称，用大写开头，除去下划线（）以及（）后的第一个字母大写，然后添加“Binding”后缀。这个类将被放置在一个模块封装包里的databinding封装包下 Binding类可通过调整data元素中的class属性来重命名或放置在不同的包中。例如： 123&lt;data class=\"UserBinding\"&gt; ...&lt;/data&gt; activityMainBinding = DataBindingUtil.setContentView(this, R.layout.activity_main);获取ActivityMainBinding对象，用于后面设置变量activityMainBinding.setUser(user);设置数据，User变量 表达式常用的表达式和正常的java代码比较类似 数学 + - / * % 字符串连接 +; 逻辑 &amp;&amp; || 二进制 &amp; | ^ 一元运算 + - ! ~ 移位 &gt;&gt; &gt;&gt;&gt; &lt;&lt; 比较 == &gt; &lt; &gt;= &lt;= instanceof 分组 () null Cast 方法调用 数据访问 [] 三元运算 ?: 不支持的操作 this super new 显式泛型调用 实际效果图 备注： 关于DataBinding，这里有一篇文章讲得很清晰，推荐一下 https://segmentfault.com/a/1190000002876984 效果图对应的代码贴了一部分，实现相对比较容易，这里就不赘述了，如果有需要的留言，我再附上。","link":"/2016/06/05/《Android 基础（五）》MVVM/"},{"title":"《Android 基础（二十六）》 渐变色圆角Button","text":"简介总结下之前看的自定义View的内容，结合一个简单的例子，阐述下基本用法和大致的使用流程，这个例子比较简单，更复杂的自定义View，随着自己的学习，后面再慢慢添加。作为一个Android开发者，这部分应该是不可或缺的。 自定义属性位置：res/values/attrs.xml格式： 123456&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;resources&gt; &lt;declare-styleable name=\"name_of_style\"&gt; &lt;attr name=\"name_of_attr\" format=\"reference|string|color|boolean|dimension|enum|flag|float|fraction|integer\"/&gt; &lt;/declare-styleable&gt;&lt;/resources&gt; format 意义 reference 参考某一资源ID, 如R.drawable.xxx string 字符串 color 颜色 boolean 布尔值 dimension 尺寸值 enum 枚举值 flag 位或运算 float 浮点数 fraction 百分数，例如pivotX,pivotY这一类属性 integer 整数 获取自定义属性1234TypedArray typedArray = context.obtainStyledAttributes(attrs, R.styleable.name_of_style);Color mColor = typedArray.getColor(R.styleable.name_of_style_name_of_attr, Color.BLUE);//其他的属性获取类似typedArray.recycle();//记得回收 名字： R.styleable.{name_of_style} R.styleable.{name_of_style}_{name_of_attr} 举例说明举个例子，实现一个背景为渐变色的圆角按钮，圆角半径，开始颜色，中心颜色，结束颜色，渐变方向用户可自定义。 attrs.xml12345678910111213141516171819&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;resources&gt; &lt;declare-styleable name=\"CornerButton\"&gt; &lt;attr name=\"corner_radius\" format=\"dimension\" /&gt; &lt;attr name=\"background_start_color\" format=\"color\" /&gt; &lt;attr name=\"background_center_color\" format=\"color\" /&gt; &lt;attr name=\"background_end_color\" format=\"color\" /&gt; &lt;attr name=\"backgrouund_gradient_orientation\"&gt; &lt;enum name=\"TOP_BOTTOM\" value=\"0\" /&gt; &lt;enum name=\"TR_BL\" value=\"1\" /&gt; &lt;enum name=\"RIGHT_LEFT\" value=\"2\" /&gt; &lt;enum name=\"BR_TL\" value=\"3\" /&gt; &lt;enum name=\"BOTTOM_TOP\" value=\"4\" /&gt; &lt;enum name=\"BL_TR\" value=\"5\" /&gt; &lt;enum name=\"LEFT_RIGHT\" value=\"6\" /&gt; &lt;enum name=\"TL_BR\" value=\"7\" /&gt; &lt;/attr&gt; &lt;/declare-styleable&gt;&lt;/resources&gt; CornerButton123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354public class CornerButton extends Button { private GradientDrawable mBg; private float mRandius; private int mStartColor; private int mCenterColor; private int mEndColor; private int mOrientation; public CornerButton(Context context, AttributeSet attrs) { super(context, attrs); TypedArray typedArray = context.obtainStyledAttributes(attrs, R.styleable.CornerButton); mRandius = typedArray.getDimension(R.styleable.CornerButton_corner_radius, 10); mStartColor = typedArray.getColor(R.styleable.CornerButton_background_start_color, Color.BLUE); mCenterColor = typedArray.getColor(R.styleable.CornerButton_background_center_color, Color.GREEN); mEndColor = typedArray.getColor(R.styleable.CornerButton_background_end_color, Color.BLACK); mOrientation = typedArray.getInt(R.styleable.CornerButton_backgrouund_gradient_orientation, 0); typedArray.recycle(); int[] colors = {mStartColor, mCenterColor, mEndColor}; mBg = new GradientDrawable(); mBg.setCornerRadius(mRandius); mBg.setOrientation(Orientation.TR_BL); mBg.setColors(colors); switch (mOrientation) { case 0: mBg.setOrientation(Orientation.TOP_BOTTOM); break; case 1: mBg.setOrientation(Orientation.TR_BL); break; case 2: mBg.setOrientation(Orientation.RIGHT_LEFT); break; case 3: mBg.setOrientation(Orientation.BR_TL); break; case 4: mBg.setOrientation(Orientation.BOTTOM_TOP); break; case 5: mBg.setOrientation(Orientation.BL_TR); break; case 6: mBg.setOrientation(Orientation.LEFT_RIGHT); break; case 7: mBg.setOrientation(Orientation.TL_BR); break; } this.setBackground(mBg); }} activity_main.xml1234567891011121314151617181920212223&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;RelativeLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:yidong=\"http://schemas.android.com/apk/res-auto\" xmlns:tools=\"http://schemas.android.com/tools\" android:id=\"@+id/activity_main\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:paddingBottom=\"@dimen/activity_vertical_margin\" android:paddingLeft=\"@dimen/activity_horizontal_margin\" android:paddingRight=\"@dimen/activity_horizontal_margin\" android:paddingTop=\"@dimen/activity_vertical_margin\" tools:context=\"gs.com.customview.MainActivity\"&gt; &lt;gs.com.customview.CornerButton android:id=\"@+id/cb_content\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" yidong:background_start_color=\"#CCFF0000\" yidong:background_center_color=\"#CCAADD00\" yidong:background_end_color=\"#CC00EEFF\" yidong:corner_radius=\"100dp\" yidong:backgrouund_gradient_orientation=\"BOTTOM_TOP\" /&gt;&lt;/RelativeLayout&gt; xmlns:yidong=“http://schemas.android.com/apk/res-auto” 和yidong:corner_radius=“100dp”XML命名空间和属性的Tag对应。 效果","link":"/2016/10/25/《Android 基础（二十六）》 渐变色圆角Button/"},{"title":"《Android 基础（十一）》 Snackbar","text":"简介 Snackbars provide lightweight feedback about an operation. They show a brief message at thebottom of the screen on mobile and lower left on larger devices. Snackbars appear above all otherelements on screen and only one can be displayed at a time. They automatically disappear after a timeout or after user interaction elsewhere on the screen,particularly after interactions that summon a new surface or activity. Snackbars can be swipedoff screen. Snackbars can contain an action which is set via{@link #setAction(CharSequence, android.view.View.OnClickListener)}.To be notified when a snackbar has been shown or dismissed, you can provide a {@link Callback} via {@link #setCallback(Callback)}. 翻译：Snackbar为用户的一个操作提供轻量级的反馈，他会在手机屏幕的底部或者是大设备的左下方显示一个简洁的消息。Snackbar出现在屏幕所有元素的上面，显示一小会。Snackbar显示一会后会自动消失，用户点击其他地方的时候也会消失，尤其，当显示一个新的界面的时候，Snackbar会滑出界面。Snackbar 可以通过setAction(CharSequence, android.view.View.OnClickListener) 来设置一个点击事件，同时也可以通过setCallback(Callback)来监听snackbar的显示和消失。 类结构Snackbar中Public属性列表 方法或接口 意义 Callback 抽象函数用来设置SnackBar显示和消失的回调 make 创建SnackBar setAction 设置ActionView的响应事件 show 显示SnackBar dismiss 收起SnackBar setActionTextColor 设置ActionView的字体颜色 setText 设置TextView的显示内容 setDuration 设置SnackBar的显示时间 getDuration 获取SnackBar的显示时间 getView 获取SnackBar的View视图 setCallback 设置显示和消失的事件监听 isShown 是否已经显示 shownOrQueued 是否已经显示或者在队列中等待显示 整理而言的话，感觉Snackbar就是Toast的一个升级版本，使用的方式和Toast也比较相似。 创建Snackbar之后一定要记得调用show()方法 基础使用代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667package mraz.com.snackdemo;import android.os.Bundle;import android.support.design.widget.Snackbar;import android.support.v7.app.AppCompatActivity;import android.view.View;import android.widget.Button;import android.widget.RelativeLayout;import android.widget.Toast;public class MainActivity extends AppCompatActivity implements View.OnClickListener { RelativeLayout rootLayout; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); rootLayout = (RelativeLayout) findViewById(R.id.root_layout); Button shortButton = (Button) findViewById(R.id.short_button); Button longButton = (Button) findViewById(R.id.long_button); shortButton.setOnClickListener(this); longButton.setOnClickListener(this); } @Override public void onClick(View view) { switch (view.getId()) { case R.id.short_button: final Snackbar shortSnackbar = Snackbar.make(rootLayout, \" Short SnackBar\", Snackbar.LENGTH_SHORT); shortSnackbar.setAction(\"Click\", new View.OnClickListener() { @Override public void onClick(View view) { Toast.makeText(rootLayout.getContext(), \"Shoort Snackbar onClick\", Toast.LENGTH_SHORT).show(); } } ); shortSnackbar.setActionTextColor(getResources().getColor(R.color.colorPrimaryDark)); shortSnackbar.show(); break; case R.id.long_button: Snackbar longSnackbar = Snackbar.make(rootLayout, \" Long SnackBar\", Snackbar.LENGTH_LONG); longSnackbar.setCallback(new SnackCallback()); longSnackbar.show(); break; } } class SnackCallback extends Snackbar.Callback { @Override public void onDismissed(Snackbar snackbar, int event) { super.onDismissed(snackbar, event); Toast.makeText(rootLayout.getContext(), \"SnackBar onDismissed\", Toast.LENGTH_SHORT).show(); } @Override public void onShown(Snackbar snackbar) { super.onShown(snackbar); Toast.makeText(rootLayout.getContext(), \"SnackBar onShown\", Toast.LENGTH_SHORT).show(); } }} 效果","link":"/2016/07/03/《Android 基础（十一）》 Snackbar/"},{"title":"《Android 基础（十二）》 TextInputLayout，让输入框更有灵性","text":"介绍 Layout which wraps an {@link android.widget.EditText} (or descendant) to show a floating labelwhen the hint is hidden due to the user inputting text. Also supports showing an error via {@link #setErrorEnabled(boolean)} and{@link #setError(CharSequence)}, and a character counter via{@link #setCounterEnabled(boolean)} 翻译：TextInputLayout需要包裹一个EditText来实现当用户输入文本的时候，将hint作为一个浮动的标签显示的效果。使用比较多大的两个方法：setError(CharSequence) - &gt; 使能错误消息提示对应属性值：app:errorEnabled=“true”setCounterEnabled(boolean) -&gt; 使能字符长度显示对应属性值：app:counterEnabled=“true” 类介绍TextInputLayout的父类是LinearLayout，源码位置frameworks/support/design/src/android/support/design/widget/TextInputLayout.java类结构视图 方法 意义 setTypeface 设置tf字体 getEditText 获取EditText视图 setHint 设置Hint内容 setHintEnabled 使能hint setHintTextAppearance 设置hint的Text Style setErrorEnabled 使能错误提示 setError 设置错误提示消息 setCounterEnabled 使能计数 setCounterMaxLength 设置输入框最大长度 setHintAnimationEnabled 使能Hint浮动动画，默认为true 总体来看，用的比较多的就是错误消息提示和计数功能，对字体的一些设置和TextView和EditText使用方法类似，这个布局的特点就是视觉感受和用户体验比简单的输入框文本框提升很多。符合google的导向，但是很多apk中很少看到人使用，应该大家有更炫酷的方法。 基本使用布局文件activity_main.xml 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:app=\"http://schemas.android.com/apk/res-auto\" xmlns:tools=\"http://schemas.android.com/tools\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:focusable=\"true\" android:focusableInTouchMode=\"true\" android:orientation=\"vertical\" android:paddingBottom=\"@dimen/activity_vertical_margin\" android:paddingLeft=\"@dimen/activity_horizontal_margin\" android:paddingRight=\"@dimen/activity_horizontal_margin\" android:paddingTop=\"@dimen/activity_vertical_margin\" tools:context=\"mraz.com.tabdemo.MainActivity\"&gt; &lt;android.support.design.widget.TextInputLayout android:id=\"@+id/til_username\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" app:errorEnabled=\"true\"&gt; &lt;android.support.design.widget.TextInputEditText android:id=\"@+id/et_username\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:hint=\"Username...\" /&gt; &lt;/android.support.design.widget.TextInputLayout&gt; &lt;android.support.design.widget.TextInputLayout android:id=\"@+id/til_password\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" app:counterEnabled=\"true\" app:counterMaxLength=\"40\"&gt; &lt;EditText android:id=\"@+id/et_password\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:hint=\"Password...\" /&gt; &lt;/android.support.design.widget.TextInputLayout&gt; &lt;Button android:id=\"@+id/bt_showerror\" android:layout_width=\"200dp\" android:layout_height=\"wrap_content\" android:text=\"ShowError\" android:textAllCaps=\"false\" /&gt; &lt;Button android:id=\"@+id/bt_clearerror\" android:layout_width=\"200dp\" android:layout_height=\"wrap_content\" android:text=\"ClearError\" android:textAllCaps=\"false\" /&gt;&lt;/LinearLayout&gt; 代码内容MainActivity.java 12345678910111213141516171819202122232425262728293031323334353637package mraz.com.tabdemo;import android.os.Bundle;import android.support.design.widget.TextInputLayout;import android.support.v7.app.AppCompatActivity;import android.view.View;import android.widget.Button;public class MainActivity extends AppCompatActivity { @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); final TextInputLayout userTextInputLayout = (TextInputLayout) findViewById(R.id.til_username); TextInputLayout passTextInputLayout = (TextInputLayout) findViewById(R.id.til_password); Button showErrorBtn = (Button) findViewById(R.id.bt_showerror); showErrorBtn.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View view) { userTextInputLayout.setError(\"UserName is not correct!\"); } }); Button clearErrorBtn = (Button) findViewById(R.id.bt_clearerror); clearErrorBtn.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View view) { userTextInputLayout.setError(\"\"); } }); }} 代码上就不上注释了，如果有疑问请提出来，不过代码很简洁，应该问题不大。 效果","link":"/2016/07/03/《Android 基础（十二）》 TextInputLayout，让输入框更有灵性/"},{"title":"《Android 基础（十八）》 XLIFF","text":"介绍 XLIFF ，XML Localization Interchange File Format，XML本地化数据交换格式。 基本使用布局文件activity_main.xml 12345678910111213141516171819202122232425&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;ScrollView xmlns:android=\"http://schemas.android.com/apk/res/android\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\"&gt; &lt;LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:tools=\"http://schemas.android.com/tools\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:orientation=\"vertical\" android:paddingBottom=\"@dimen/activity_vertical_margin\" android:paddingLeft=\"@dimen/activity_horizontal_margin\" android:paddingRight=\"@dimen/activity_horizontal_margin\" android:paddingTop=\"@dimen/activity_vertical_margin\" tools:context=\"mraz.com.uiwidgetdemo.MainActivity\"&gt; &lt;TextView android:id=\"@+id/tv_hello\" android:textSize=\"10pt\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:text=\"@string/hello\" /&gt; &lt;/LinearLayout&gt;&lt;/ScrollView&gt; String资源文件12345&lt;resources xmlns:xliff=\"http://schemas.android.com/tools\"&gt; &lt;string name=\"hello\"&gt;your name is &lt;xliff:g id=\"NAME\"&gt;%1$s&lt;/xliff:g&gt;, and your age is&lt;xliff:g id=\"AGE\"&gt;%2$s&lt;/xliff:g&gt;&lt;/string&gt; &lt;string name=\"hello_simple\"&gt;your name is %1$s, and your age is %2$s&lt;/string&gt;&lt;/resources&gt; 两种，一种是直接使用%1$s类似的格式，另外一种就是使用 xliff:g 给需要替换的内容加了个名字而已，效果是相同的。属性id可以随便命名%n$ms：代表输出的是字符串，n代表是第几个参数，设置m的值可以在输出之前放置空格%n$md：代表输出的是整数，n代表是第几个参数，设置m的值可以在输出之前放置空格，也可以设为0m,在输出之前放置m个0%n$mf：代表输出的是浮点数，n代表是第几个参数，设置m的值可以控制小数位数，如m=2.2时，输出格式为00.00 代码12345TextView textView= (TextView) findViewById(R.id.tv_hello);String hello = getString(R.string.hello_simple, \"android\", \"28\");textView.setText(hello); 效果","link":"/2016/08/03/《Android 基础（十八）》 XLIFF/"},{"title":"《Android 基础（二）》 BroadcastReceiver","text":"介绍BroadcastReceiver：广播接收者，很形象，广播发送，类比生活中的广播，有能力听得到的都可以介绍到这个信息，然后在大脑中反映。对应到Android中就是SendBroadcast和onReceive。广播之间信息的传递是通过Intent对象来传递的，Intent调用分为显示调用的隐式调用两种。 使用方法广播接收者1234567891011121314public class MyReceiver extends BroadcastReceiver { public static final String HELLOACTION = \"com.example.mraz.learnbroadcastreceiver.android.intent.action.HELLO\"; public MyReceiver() { } @Override public void onReceive(Context context, Intent intent) { String str = intent.getStringExtra(\"message\"); System.out.println(\"on Reveiver\" + str); }} 静态注册AndroidManifest.xml 123456789&lt;receiver android:name=\".MyReceiver\" android:enabled=\"true\" android:exported=\"true\" &gt; &lt;intent-filter&gt; &lt;action android:name=\"com.example.mraz.learnbroadcastreceiver.android.intent.action.HELLO\"/&gt; &lt;/intent-filter&gt;&lt;/receiver&gt; 动态注册123IntentFilter intentFilter = new IntentFilter();intentFilter.addAction(MyReceiver.HELLOACTION);registerReceiver(myReceiver, intentFilter); 1unregisterReceiver(myReceiver);//解除注册 结果 Demo界面 静态注册方式下： 发送广播-&gt;取消注册 -&gt;发送广播 动态注册方式下： 发送广播-&gt;注册广播-&gt;发送广播-&gt; 取消注册 -&gt; 发送广播","link":"/2016/05/25/《Android 基础（二）》 BroadcastReceiver/"},{"title":"《Android 基础（十四）》 selector","text":"介绍 A StateListDrawable is a drawable object defined in XML that uses a several different images to represent the same graphic, depending on the state of the object. For example, a Button widget can exist in one of several different states (pressed, focused, or niether) and, using a state list drawable, you can provide a different background image for each state. You can describe the state list in an XML file. Each graphic is represented by an “item” element inside a single “selector” element. Each “item” uses various attributes to describe the state in which it should be used as the graphic for the drawable.During each state change, the state list is traversed top to bottom and the first item that matches the current state is used—the selection is not based on the “best match,” but simply the first item that meets the minimum criteria of the state. 翻译：StateListDrawable 是一种通过XML文件来定义的drawable，使用几个不同的图片来呈现同一个图形，通过object的状态来实现切换。例如，一个Button有几个不同的状态（按压，获取焦点等等），这种情况下，通过使用 state list drawable，你就可以实现在不同的状态下使用不同的背景图片。你可以在一个XML文件中描述state list。通过在根节点selector下定义一个item元素来添加每个图形。每一各item中使用不同的状态属性来定义不用的drawable。当每一次状态改变的时候，state list都会从上到下被遍历一遍，第一个与当前state相匹配的item将会被使用—- 这个选择并不是作出“最匹配”结果，而是简单的找到第一个匹配的状态。 selector一般都是用来作为有状态改变的View的背景，以此来达到当用户对View进行操作，导致View状态改变时，作出改变，让用户感知View的状态变化。 官方说明文件位置：res/drawable/filename.xml 编译资源类型：StateListDrawable 资源引用：In Java: R.drawable.filenameIn XML: @[package:]drawable/filename 语法： 1234567891011121314151617&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;selector xmlns:android=\"http://schemas.android.com/apk/res/android\" android:constantSize=[\"true\" | \"false\"] android:dither=[\"true\" | \"false\"] android:variablePadding=[\"true\" | \"false\"] &gt; &lt;item android:drawable=\"@[package:]drawable/drawable_resource\" android:state_pressed=[\"true\" | \"false\"] android:state_focused=[\"true\" | \"false\"] android:state_hovered=[\"true\" | \"false\"] android:state_selected=[\"true\" | \"false\"] android:state_checkable=[\"true\" | \"false\"] android:state_checked=[\"true\" | \"false\"] android:state_enabled=[\"true\" | \"false\"] android:state_activated=[\"true\" | \"false\"] android:state_window_focused=[\"true\" | \"false\"] /&gt;&lt;/selector&gt; 更多详细说明，请查阅xsoftlab 基本使用下面做一个简单的实例，对Button的背景根据状态做一下处理 XML文件selector_ts.xml 1234567&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;selector xmlns:android=\"http://schemas.android.com/apk/res/android\"&gt; &lt;item android:drawable=\"@color/pink\" android:state_pressed=\"true\" /&gt; &lt;item android:drawable=\"@color/yellow\" android:state_selected=\"true\" /&gt; &lt;item android:drawable=\"@drawable/shaperect\" android:state_enabled=\"false\" /&gt; &lt;item android:drawable=\"@color/stone\" android:state_enabled=\"true\" /&gt;&lt;/selector&gt; 主布局文件（activity_main.xml） 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:tools=\"http://schemas.android.com/tools\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:focusable=\"true\" android:focusableInTouchMode=\"true\" android:orientation=\"vertical\" android:padding=\"10dp\" tools:context=\"mraz.com.tabdemo.MainActivity\"&gt; &lt;Button android:id=\"@+id/bt_content\" android:layout_width=\"match_parent\" android:layout_height=\"300dp\" android:background=\"@drawable/selector_ts\" /&gt; &lt;LinearLayout android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:layout_marginTop=\"50dp\" android:orientation=\"horizontal\"&gt; &lt;Button android:id=\"@+id/bt_selected\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:layout_weight=\"1\" android:text=\"Select\" android:textAllCaps=\"false\" /&gt; &lt;Button android:id=\"@+id/bt_disable\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:layout_weight=\"1\" android:text=\"Disable\" android:textAllCaps=\"false\" /&gt; &lt;Button android:id=\"@+id/bt_pressed\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:layout_weight=\"1\" android:text=\"Press\" android:textAllCaps=\"false\" /&gt; &lt;/LinearLayout&gt;&lt;/LinearLayout&gt; 代码部分比较简单，这里就不占用过多的篇幅了，看下简单的效果，大家应该就知道如何编写小小的Activity了。 效果 更多的内容等待着挖掘机的到来~","link":"/2016/07/05/《Android 基础（十四）》 selector/"},{"title":"《Android 基础（十六）》Toast","text":"介绍 A toast provides simple feedback about an operation in a small popup. It only fills the amount of space required for the message and the current activity remains visible and interactive. For example, navigating away from an email before you send it triggers a “Draft saved” toast to let you know that you can continue editing later. Toasts automatically disappear after a timeout. 翻译：Toast以一种小弹框的方式来给予用户反馈，它只需要消息可以显示出来的那小部分空间，同时Activity依然可见可交互。例如，当你写邮件的时候退出，会触发“草稿已保存”的Toast来让你知道你以后可以继续编辑这封邮件。Toast会在一段时间后自己消失。 类结构Toast成员 成员介绍 成员 含义 Toast(Context) 构造函数 show() 显示Toast cancel() 取消Toast setMargin(float,float) 设置横向的margin和纵的margin setGravity(int ,int, int) 设置toast的位置重心相对的XOffset, YOffset makeText(Context, CharSequence, int) 利用字符串创建Toast makeText(Context, int, int) 利用字符串资源创Toast setView(View) 设置自定义Toast显示View setDuration(int) 设置Toast的显示时间 setText 设置Message文本内容 基本使用布局文件activity_main.xml 123456789101112131415161718192021222324252627&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:tools=\"http://schemas.android.com/tools\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:orientation=\"vertical\" android:paddingBottom=\"@dimen/activity_vertical_margin\" android:paddingLeft=\"@dimen/activity_horizontal_margin\" android:paddingRight=\"@dimen/activity_horizontal_margin\" android:paddingTop=\"@dimen/activity_vertical_margin\" tools:context=\"mraz.com.toastdemo.MainActivity\"&gt; &lt;Button android:id=\"@+id/bt_simple\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:background=\"@color/colorAccent\" android:text=\"Simple Toast\" /&gt; &lt;Button android:id=\"@+id/bt_custom\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:layout_marginTop=\"30dp\" android:background=\"@color/colorPrimary\" android:text=\"Custom Toast\" /&gt;&lt;/LinearLayout&gt; 自定义的Toast布局custom_toast.xml 123456789101112131415161718192021&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" android:layout_width=\"match_parent\" android:layout_height=\"40dp\" android:background=\"@drawable/shape_bg\" android:orientation=\"horizontal\"&gt; &lt;ImageView android:layout_width=\"40dp\" android:layout_height=\"40dp\" android:src=\"@drawable/ic_account_circle_black_24dp\" /&gt; &lt;TextView android:layout_width=\"wrap_content\" android:layout_height=\"40dp\" android:layout_marginLeft=\"10dp\" android:layout_marginRight=\"10dp\" android:gravity=\"center\" android:text=\"This is a Custom Toast !\" android:textStyle=\"italic\" /&gt;&lt;/LinearLayout&gt; 代码内容12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849package mraz.com.toastdemo;import android.content.Context;import android.os.Bundle;import android.support.v7.app.AppCompatActivity;import android.view.Gravity;import android.view.LayoutInflater;import android.view.View;import android.widget.Button;import android.widget.Toast;public class MainActivity extends AppCompatActivity implements View.OnClickListener { Context mContext; Button btSimple, btCustom; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); mContext = this; btSimple = (Button) findViewById(R.id.bt_simple); btCustom = (Button) findViewById(R.id.bt_custom); btSimple.setOnClickListener(this); btCustom.setOnClickListener(this); } @Override public void onClick(View view) { switch (view.getId()) { case R.id.bt_simple: Toast.makeText(mContext, \" This is a simple toast\", Toast.LENGTH_SHORT).show(); break; case R.id.bt_custom: LayoutInflater layoutInflater = LayoutInflater.from(mContext); View custToast = layoutInflater.inflate(R.layout.custom_toast, null); Toast toast = new Toast(mContext); toast.setView(custToast); toast.setDuration(Toast.LENGTH_SHORT); toast.setGravity(Gravity.CENTER_VERTICAL, 0, 0); toast.show(); break; } }} 实际效果 备注Toast的内容比较简单，但是开发过程中应该会经常用到，说不定偶尔还会碰到显示不出来的情况，不要忘记执行show()方法，当然，还有可能是其他的原因导致你的Toast无法显示~","link":"/2016/07/06/《Android 基础（十六）》Toast/"},{"title":"《Android 基础（十）》FloatingActionButton","text":"简介 Source Code中的介绍如下： Floating action buttons are used for a special type of promoted action. They are distinguishedby a circled icon floating above the UI and have special motion behaviors related to morphing,launching, and the transferring anchor point. Floating action buttons come in two sizes: the default and the mini. The size can becontrolled with the {@code fabSize} attribute. As this class descends from {@link ImageView}, you can control the icon which is displayedvia {@link # setImageDrawable(Drawable)}.The background color of this view defaults to the your theme’s {@code colorAccent}. If youwish to change this at runtime then you can do so via{@link # setBackgroundTintList(ColorStateList)}. @attr ref android.support.design.R.styleable#FloatingActionButton_fabSize 属性值 属性值 含义 app:backgroundTint 设置背景颜色 app:fabSize 设置FAB的大小，主要有两个取值normal,mini android:src 设置FAB的图标内容 app:rippleColor 设置FAB点击过程中的颜色 app:elevation 设置FAB正常情况下的阴影效果 app:pressedTranslationZ 设置FAB点击时的阴影大小 app:borderWidth 设置边框宽度 android:clickable 是否可点击true or false app:layout_anchor 设置FAB的锚点，即以哪个控件为参照点设置位置 app:layout_anchorGravity 设置FAB相对锚点的位置，取值:topbottom.left,right,center_vertical,fill_vertical,center_horizontal,fill_horizontal,center,fill,clip_verticalclip_horizontal,start,end 基本使用布局文件activity_main.xml 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;android.support.design.widget.CoordinatorLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:app=\"http://schemas.android.com/apk/res-auto\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\"&gt; &lt;android.support.v7.widget.Toolbar android:id=\"@+id/toolbar\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:background=\"?attr/colorPrimaryDark\" android:minHeight=\"?attr/actionBarSize\" app:navigationIcon=\"@drawable/ic_account_balance_black_24dp\" app:title=\"Mraz FAB Demo\"&gt;&lt;/android.support.v7.widget.Toolbar&gt; &lt;android.support.design.widget.FloatingActionButton android:id=\"@+id/fab_left\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:layout_gravity=\"left|bottom\" android:layout_marginBottom=\"@dimen/activity_vertical_margin\" android:layout_marginLeft=\"@dimen/activity_horizontal_margin\" android:clickable=\"true\" android:onClick=\"leftClick\" android:src=\"@drawable/ic_arrow_back_black_24dp\" app:backgroundTint=\"@color/colorPrimary\" app:fabSize=\"mini\" app:rippleColor=\"@color/colorPress\" /&gt; &lt;android.support.design.widget.FloatingActionButton android:id=\"@+id/fab_right\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:layout_gravity=\"right|bottom\" android:layout_marginBottom=\"@dimen/activity_vertical_margin\" android:layout_marginRight=\"@dimen/activity_horizontal_margin\" android:clickable=\"true\" android:onClick=\"rightClick\" android:src=\"@drawable/ic_arrow_forward_black_24dp\" app:backgroundTint=\"@color/colorLight\" app:borderWidth=\"0dp\" app:elevation=\"20dp\" app:fabSize=\"normal\" app:pressedTranslationZ=\"50dp\" app:rippleColor=\"@color/colorPress\" /&gt; &lt;android.support.design.widget.FloatingActionButton android:id=\"@+id/fab_anchor\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:layout_gravity=\"right|bottom\" android:layout_marginRight=\"10dp\" android:layout_marginTop=\"20dp\" android:clickable=\"true\" android:onClick=\"topClick\" android:src=\"@drawable/ic_arrow_forward_black_24dp\" app:backgroundTint=\"#ff87ffeb\" app:borderWidth=\"0dp\" app:elevation=\"6dp\" app:fabSize=\"normal\" app:layout_anchor=\"@+id/toolbar\" app:layout_anchorGravity=\"right\" app:pressedTranslationZ=\"12dp\" app:rippleColor=\"#33728dff\" /&gt;&lt;/android.support.design.widget.CoordinatorLayout&gt; 布局中一共设置了3个FAB，一个在左下角，一个在右下角，一个设置了锚点，颜色可以自己调整，简单的用法就是这个样子，对应的onClick事件在MainActivity中实现。 代码MainActivity.java 123456789101112131415161718192021222324252627282930313233343536package mraz.com.appbardemo;import android.annotation.TargetApi;import android.os.Build;import android.os.Bundle;import android.support.v7.app.AppCompatActivity;import android.support.v7.widget.Toolbar;import android.view.View;public class MainActivity extends AppCompatActivity { Toolbar toolbar; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); toolbar = (Toolbar) findViewById(R.id.toolbar); setSupportActionBar(toolbar); } @TargetApi(Build.VERSION_CODES.LOLLIPOP) public void leftClick(View view) { toolbar.setTitle(\"Left FAB onClick\"); } public void rightClick(View view) { toolbar.setTitle(\"Right FAB onClick\"); } public void topClick(View view) { toolbar.setTitle(\"Top FAB onClick\"); }} 效果","link":"/2016/07/02/《Android 基础（十）》FloatingActionButton/"},{"title":"《Android 基础（四十二）》 MultiDex","text":"版权声明：本文为博主原创文章，未经博主允许不得转载。 https://blog.csdn.net/poorkick/article/details/77946572 1. 前言 最近做项目开发的时候，遇到一个问题，NoClassDef,NoMethod之类的错误，但是把log往前看，会发现一些Dalvik的一些报错，看到这些log之后，就会觉得后面的什么方法找不到，类没有定义什么的错误真是的应该出现，那么这些Dalvik的错误怎么解释呢？ 因为类似的报错只出现在了一个同事的手机上，而且是KK版本，比较老。介绍下我的分析思路： 确定问题发生位置，注释掉（并解决因注释引起的编译错误）—&gt; Defeat 因为是KK版本，调整minSDK到19 —&gt; Defeat 删除或者更新引起问题的jar包 —&gt; Defeat 考虑到MultiDex在Android5.0 以后默认支持，为兼容旧版本，手动兼容一下 ————————&gt;Victory 2. 配置MultiDexAndroid5.0及以上版本默认支持MultiDex 2.1 修改build.gradle1234567891011121314151617android { compileSdkVersion 21 buildToolsVersion &quot;21.1.0&quot; defaultConfig { ... minSdkVersion 14 targetSdkVersion 21 ... // Enabling MultiDex support. multiDexEnabled true } ... } dependencies { compile &apos;com.android.support:multidex:1.0.1&apos;} 2.2 修改application 三种方法 2.2.1 在AndroidManifest.xml的application中声明android.support.MultiDex.MultiDexApplication2.2.2 让自己的application类继承MultiDexApplication；2.2.3 重写attachBaseContext()方法12345@Override protected void attachBaseContext(Context base) { super.attachBaseContext(base); MultiDex.install(this);} 3. 推荐文章 更多关于MultiDex可以查阅 美团技术沙龙关于分包的博客 或者直接查看MultiDex源码。","link":"/2017/09/12/《Android 基础（四十二）》 MultiDex/"},{"title":"《Android 基础（零)》 Android知识框架梳理","text":"1. 前言 最近想梳理一下Android的基础知识，让知识有一些体系的概念。 2. Android 基础知识体系","link":"/2017/09/23/《Android 基础（零)》 Android知识框架梳理/"},{"title":"《Android 基础（四十六）》 LayerDrawable & layer-list","text":"介绍 LayerDrawable 是管理其他可绘制对象阵列的可绘制对象。列表中的每个可绘制对象按照列表的顺序绘制，列表中的最后一个可绘制对象绘于顶部。 每个可绘制对象由单一 &lt; layer-list &gt; 元素内的 &lt; item &gt; 元素表示。 语法1234567891011&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;layer-list xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; &gt; &lt;item android:drawable=&quot;@[package:]drawable/drawable_resource&quot; android:id=&quot;@[+][package:]id/resource_name&quot; android:top=&quot;dimension&quot; android:right=&quot;dimension&quot; android:bottom=&quot;dimension&quot; android:left=&quot;dimension&quot; /&gt;&lt;/layer-list&gt; 作用 layer-list，图层列表，可以帮助我们绘制一些特殊的图形。 部分实践Line &amp; Dotlayer-list12345678910111213141516171819&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;layer-list xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt; &lt;item android:bottom=&quot;2dp&quot; android:right=&quot;2dp&quot; android:top=&quot;2dp&quot;&gt; &lt;shape android:shape=&quot;rectangle&quot;&gt; &lt;solid android:color=&quot;#1750ff&quot; /&gt; &lt;/shape&gt; &lt;/item&gt; &lt;item android:gravity=&quot;right&quot;&gt; &lt;shape android:shape=&quot;oval&quot;&gt; &lt;solid android:color=&quot;#1750ff&quot; /&gt; &lt;size android:width=&quot;5dp&quot; android:height=&quot;5dp&quot; /&gt; &lt;/shape&gt; &lt;/item&gt;&lt;/layer-list&gt; use in layout123456&lt;View android:layout_width=&quot;100dp&quot; android:layout_height=&quot;5dp&quot; android:layout_marginLeft=&quot;50dp&quot; android:layout_marginTop=&quot;50dp&quot; android:background=&quot;@drawable/horizontal_line_dot&quot; /&gt; result 代码修改Drawable颜色 通过LayerDrawable类中的部分方法，我们可以拿到每一层的Drawable，这样针对不通层级的Drawable，我们可以根据自己的需要，在用户交互过程中执行修改等操作。 1234567bt_change_color.setOnClickListener({ var background: LayerDrawable = horizontal_line_dot.background as LayerDrawable for (index in 0..(background.numberOfLayers - 1)) { var drawable: GradientDrawable = background.getDrawable(index) as GradientDrawable drawable.setColor(Color.BLACK) }}) Shape 关于Shape的用法，请阅Shape","link":"/2018/06/09/《Android 基础（四十六）》 LayerDrawable & layer-list/"},{"title":"《Android 安全（一）》AndroidManifest.xml之allowBackup属性","text":"前言 “ android:allowBackup”是一个是否允许备份系统和用户数据的属性。 当这个标志被设置为true时应用程序数据可以在手机未获取 ROOT 的情况下通过adb调试工具来备份和恢复。 案例分析 从应用商城里下载一个“密码本”之类的应用。 1. 使用AndroidStudio分析应用 “Build” 》“Analyze APK…”，选择对应的应用进行分析，关注包名和allowBackup属性 若“allowBackup”属性为true，才能继续往下进行。 2. 安装应用3. 使用adb命令导出该应用数据，过程中手机会要求设置密码，设置密码后点击”备份我的数据“ 4. 使用abe工具解压ab文件 使用abe-all.jar文件解析ab文件为rar文件，jar包下载地址为：abe-all.jar 5. 查看备份文件 解压文件，查看里面有很多有用的数据文件，如数据库db文件和SharedPreference文件 查看一下数据库文件,里面有一条我之前保存的测试数据 查看一下sp文件中的xml，里面有我设置的数字密码虽然是加过密的 6. 修改内容并恢复数据 数据库文件稍作修改“pwd”字段修改为“23456789”并保存。恢复过程中要求输入密码，和之前一样就行 7. 恢复结果 使用adb restore恢复数据后，应用内显示的数据依然是“234567”，也就是我们修改后的数据没有被接受。两方面认证： 重新导出数据（依然是“234567”） 将用于恢复数据的ab文件解析成rar文件（是我们修改后的“23456789”） 判断，恢复数据的时候，系统或者应用本身做了处理。 8. 结论 虽然我们最后修改数据并恢复，结果没有成功，但是作为一个“密码本”类的应用，可以知道看到用户储存的账号密码信息已经是相当恐怖了，并且此应用下载量还是挺高的。并且经过多个应用测试，好多应用的“allowBackup”属性均为true。可能是因为新建工程默认为true的原因吧。","link":"/2018/12/29/《Android 安全（一）》AndroidManifest.xml之allowBackup属性/"},{"title":"《Android 安全（三）》动态调试Smali","text":"环境 Android Studio 3.3.2 SmaliIdea Plugin 自己随手写一个Android应用 baksmali 操作 安装SmaliIdea插件 SmaliIDEA 插件 在线安装 编制测试应用 1234567891011121314151617public class MainActivity extends AppCompatActivity { private int count = 0; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); TextView textView = findViewById(R.id.tv_content); Button button = findViewById(R.id.bt_change_text); button.setOnClickListener(v -&gt; { count++; textView.setText(String.format(Locale.CHINESE, &quot;Tap %d&quot;, count)); }); }} 打包成Apk文件 为了保证 android:debuggable=&quot;true&quot; ，我们打包成debug版本即可。或者手动在AndroidManifest.xml文件中设置也行。 反编译 baksmali d app-debug.apk -o ~/projects/myapp/src 启动程序并转发端口 启动测试程序主界面 adb shell am start -D -n cn.onlyloveyd.smali/cn.onlyloveyd.smali.MainActivity 启动“Android Device Monitor”，记住pid和后面8700端口，然后一定关闭Android Device Monitor 转发端口 导入工程至Android Studio “New” -》“import Project”，选择刚才创建的工程目录 选择”Create project from existing sources” 一直继续直到“Finish” 设置“src”文件加为源文件 “Edit Configurations”并配置JDK 调试 执行“Run” -》 “Debug XXX” 跳转到断点处，可执行单步调试","link":"/2019/03/22/《Android 安全（三）》动态调试Smali/"},{"title":"《Android 应用 之路》 JuheNews For aNdroid (改进版)","text":"简介 最新版应用已经上线，欢迎下载使用，提出宝贵意见： http://shouji.baidu.com/software/10720907.html 上一篇介绍的是最开始自己制作的一个采用聚合数据免费接口制作的一个头条类新闻应用，最近对其在界面上做了很大的改动，结合之前介绍的TabHost作为底部仿微信菜单，然后新闻内容丰富到10种分类，搜索功能放在ToolBar上，整体效果个人感觉还是比较OK。 代码开源： https://github.com/onlyloveyd/JuheNews 觉得不错的话，给我一个小红星吧， 有意见的话可以在博文下留言，会及时改正 使用到的开源内容 主要用到的开源库有以下一些 12345678910compile &apos;com.squareup.okhttp3:okhttp:3.5.0&apos;compile &apos;com.android.support:recyclerview-v7:25.0.1&apos;compile &apos;com.google.code.gson:gson:2.8.0&apos;compile &apos;io.reactivex:rxandroid:1.2.1&apos;compile &apos;com.android.support:design:25.0.1&apos;compile &apos;com.github.bumptech.glide:glide:3.7.0&apos;compile &apos;com.android.support:cardview-v7:25.0.1&apos;compile &apos;com.jakewharton:butterknife:8.4.0&apos;annotationProcessor &apos;com.jakewharton:butterknife-compiler:8.4.0&apos;compile &apos;com.astuetz:pagerslidingtabstrip:1.0.1&apos; 主要涉及到网络通信，响应式编程，注解，RecyclerView,CardView和PageIndicator等方面，站在巨人的肩膀上，减低了不少开发的难度 使用到的聚合数据接口 新闻头条 主要分为头条，社会，国内，娱乐，体育，军事，科技，财经，时尚等新闻信息 新闻 这个和上面的新闻头条不太一样，这个是用来搜索热点信息的 笑话大全 趣图 趣图和上面的笑话大全是一个接口，只是请求数据的内容不同而已 历史上的今天 具体的使用方式和接口介绍，有兴趣的朋友可以去聚合数据官网上去了解，这里不做赘述。 具体效果 由于模拟器上没有一些中文输入法，为了方便引用下Github上的Gif 备注 具体代码内容请移步Github,谢谢！ 一直想借这个机会写一个万能的RecyclerView.Adapter，但是目前还没完成，后面接着看下怎么写比较合适。","link":"/2016/12/19/《Android 应用 之路》 JuheNews For aNdroid (改进版)/"},{"title":"《Android 应用 之路》 MPAndroidChart~BarChart","text":"版权声明：本文为博主原创文章，未经博主允许不得转载。 https://blog.csdn.net/poorkick/article/details/52424333 简介 MPAndroidChart是PhilJay大神给Android开发者带来的福利。MPAndroidChart是一个功能强大并且使用灵活的图表开源库，支持Android和IOS两种，这里我们暂时只关注Android版本。 Wiki https://github.com/PhilJay/MPAndroidChart/wiki Javadoc https://jitpack.io/com/github/PhilJay/MPAndroidChart/v3.0.0-beta1/javadoc/ 今日之图~BarChart 先看图，压压惊 布局文件 1234567891011121314151617&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;RelativeLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:tools=&quot;http://schemas.android.com/tools&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:paddingBottom=&quot;@dimen/activity_vertical_margin&quot; android:paddingLeft=&quot;@dimen/activity_horizontal_margin&quot; android:paddingRight=&quot;@dimen/activity_horizontal_margin&quot; android:paddingTop=&quot;@dimen/activity_vertical_margin&quot; tools:context=&quot;mapdemo.example.com.mpandroidchartdemo.MainActivity&quot;&gt; &lt;!-- 主布局中添加BarChart--&gt; &lt;com.github.mikephil.charting.charts.BarChart android:id=&quot;@+id/barchart&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:text=&quot;Hello World!&quot; /&gt;&lt;/RelativeLayout&gt; 对于Chart,可以采用布局文件添加方式，也可以采用代码添加方式。 代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061public class MainActivity extends AppCompatActivity { @Bind(R.id.barchart) BarChart barchart; private Random random;//用于产生随机数字 @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); ButterKnife.bind(this); random = new Random(); initBarChart(); } private void initBarChart() { ArrayList&lt;BarEntry&gt; yVals = new ArrayList&lt;&gt;();//Y轴方向第一组数组 ArrayList&lt;BarEntry&gt; yVals2 = new ArrayList&lt;&gt;();//Y轴方向第二组数组 ArrayList&lt;BarEntry&gt; yVals3 = new ArrayList&lt;&gt;();//Y轴方向第三组数组 ArrayList&lt;String&gt; xVals = new ArrayList&lt;&gt;();//X轴数据 for (int i = 0; i &lt; 12; i++) {//添加数据源 xVals.add((i + 1) + &quot;月&quot;); yVals.add(new BarEntry(random.nextInt(10000), i)); yVals2.add(new BarEntry(random.nextInt(10000), i)); yVals3.add(new BarEntry(random.nextInt(10000), i)); } BarDataSet barDataSet = new BarDataSet(yVals, &quot;小明每月支出&quot;); barDataSet.setColor(Color.RED);//设置第一组数据颜色 BarDataSet barDataSet2 = new BarDataSet(yVals2, &quot;小花每月支出&quot;); barDataSet2.setColor(Color.GREEN);//设置第二组数据颜色 BarDataSet barDataSet3 = new BarDataSet(yVals3, &quot;小蔡每月支出&quot;); barDataSet3.setColor(Color.YELLOW);//设置第三组数据颜色 ArrayList&lt;IBarDataSet&gt; threebardata = new ArrayList&lt;&gt;();//IBarDataSet 接口很关键，是添加多组数据的关键结构，LineChart也是可以采用对应的接口类，也可以添加多组数据 threebardata.add(barDataSet); threebardata.add(barDataSet2); threebardata.add(barDataSet3); BarData bardata = new BarData(xVals, threebardata); barchart.setData(bardata); barchart.getLegend().setPosition(Legend.LegendPosition.ABOVE_CHART_LEFT);//设置注解的位置在左上方 barchart.getLegend().setForm(Legend.LegendForm.CIRCLE);//这是左边显示小图标的形状 barchart.getXAxis().setPosition(XAxis.XAxisPosition.BOTTOM);//设置X轴的位置 barchart.getXAxis().setDrawGridLines(false);//不显示网格 barchart.getAxisRight().setEnabled(false);//右侧不显示Y轴 barchart.getAxisLeft().setAxisMinValue(0.0f);//设置Y轴显示最小值，不然0下面会有空隙 barchart.getAxisLeft().setDrawGridLines(false);//不设置Y轴网格 barchart.setDescription(&quot;No Deal&quot;);//设置描述 barchart.setDescriptionTextSize(20.f);//设置描述字体 barchart.animateXY(1000, 2000);//设置动画 }} 这里，一些使用方式可以具体去看看对应的类机构，比如BarChart 通过查看它对应的源码，可以更好的使用功能，AS会自动的帮我们反编译一些内容，能借助AS很好的学习一些开源Jar包。 在上面这个例子中，如何让现实的数值为“xxx元”呢？ MPAndroidChart中存在ValueFormatter这个东西，通过这个还做一个转换，如实现“xxx元”的效果 123456bardata.setValueFormatter(new ValueFormatter() { @Override public String getFormattedValue(float v, Entry entry, int i, ViewPortHandler viewPortHandler) { return entry.getVal() + &quot;元&quot;;//只用拿到对应Entry的值然后加个“元”即可，传入的这几个参数，v就是Y轴的value, entry为数据入口，i就是X轴方向的位置，viewPortHandler应该就是对应View的操作手，控制视图的移动缩放什么的 } });","link":"/2016/09/03/《Android 应用 之路》 MPAndroidChart~BarChart/"},{"title":"《Android 应用 之路》 MPAndroidChart~LineChart","text":"###简介 MPAndroidChart是PhilJay大神给Android开发者带来的福利。MPAndroidChart是一个功能强大并且使用灵活的图表开源库，支持Android和IOS两种，这里我们暂时只关注Android版本。 ###Wiki https://github.com/PhilJay/MPAndroidChart/wiki ###Javadoc https://jitpack.io/com/github/PhilJay/MPAndroidChart/v3.0.0-beta1/javadoc/ ###今日之图~LineChart 先看下效果压压惊，右边的图为左边的图横向拉伸后的效果 布局文件 123456789101112&lt;RelativeLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:tools=&quot;http://schemas.android.com/tools&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:paddingBottom=&quot;@dimen/activity_vertical_margin&quot; android:paddingTop=&quot;@dimen/activity_vertical_margin&quot; tools:context=&quot;com.example.mpandroidchartdemo.MainActivity&quot; &gt; &lt;com.github.mikephil.charting.charts.LineChart android:id=&quot;@+id/chart&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; /&gt;&lt;/RelativeLayout&gt; 对于Chart,可以采用布局文件添加方式，也可以采用代码添加方式。 代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253requestWindowFeature(Window.FEATURE_NO_TITLE);//no title，去掉actionbarsetContentView(R.layout.activity_main);//设置主视图chart = (LineChart) findViewById(R.id.chart);xVals = new ArrayList&lt;&gt;();yVals = new ArrayList&lt;&gt;();random = new Random();//产生随机数字for(int i = 0 ; i&lt;12; i++) { float x = random.nextInt(10000);//获取value值 yVals.add(new Entry(x, i));//创建Entry并且添加到Y值的list中，Y轴的值，一个entry代表一个显示的值 xVals.add( (i+1) + &quot;月&quot;);//横坐标显示xxx月}dataSet = new LineDataSet(yVals, &quot;金额&quot;);//创建数据集并设置标签dataSet.setColors(ColorTemplate.COLORFUL_COLORS);//设置数据集显示的颜色，预支颜色模版ColorTemplate，也可以设置单一颜色和colorsdataSet.setHighlightEnabled(true);//设置高亮dataSet.setValueTextColor(Color.BLUE);//设置Value值的显示文字颜色，字体大小和字体种类，这里我没有添加对应字体可以自己修改dataSet.setValueTextSize(10.0f);dataSet.setValueTypeface(null);data = new LineData(xVals, dataSet);//创建LineData,x轴List和Y轴数据集为参数chart.setData(data);//给图表添加数据chart.setDescription(&quot;收支状态&quot;);//设置图表描述的内容位置，字体等等chart.setDescriptionColor(Color.YELLOW);chart.setDescriptionTextSize(15f);chart.setDescriptionPosition(540, 40);chart.getXAxis().setPosition(XAxisPosition.BOTTOM);//设置X轴的显示位置，通过XAxisPosition枚举类型来设置chart.getXAxis().setAxisMinValue(0.0f);//设置X轴的最小值chart.getAxisRight().setEnabled(false);//关闭右边的Y轴，因为默认有两条，左边一条，右边一条，MPAndroidChart中有setEnabled方法的元素基本上都是使能的作用chart.animateY(3000);//动画效果，MPAndroidChart中还有很多动画效果可以挖掘//当值被选中的时候，执行操作显示一个Toastchart.setOnChartValueSelectedListener(new OnChartValueSelectedListener() { @Override public void onValueSelected(Entry e, int dataSetIndex, Highlight h) { // TODO Auto-generated method stub Toast.makeText(MainActivity.this, String.valueOf(e.getVal()), Toast.LENGTH_SHORT).show(); } @Override public void onNothingSelected() { // TODO Auto-generated method stub } }); ###备注 中午抽空看下MPAndroidChart并记录下简单的入门，刚开始，有兴趣的可以直接去GitHub上看下Wiki，当然也有人翻译了这篇英文Wiki，直接搜索MPAndroidChart应该就都可以看到了。至于使用方式，大家应该都很清楚，引用jar包或者下载源码编译吧，我是懒人，前者可选。 世界牛人太多，跟不上脚步了。","link":"/2016/09/02/《Android 应用 之路》 MPAndroidChart~LineChart/"},{"title":"《Android 应用 之路》 MPAndroidChart~PieChart","text":"###简介 MPAndroidChart是PhilJay大神给Android开发者带来的福利。MPAndroidChart是一个功能强大并且使用灵活的图表开源库，支持Android和IOS两种，这里我们暂时只关注Android版本。 ###Wiki https://github.com/PhilJay/MPAndroidChart/wiki ###Javadoc https://jitpack.io/com/github/PhilJay/MPAndroidChart/v3.0.0-beta1/javadoc/ ###今日之图~PieChart 先看下效果压压惊，右边的图为左边的图横向拉伸后的效果 实际静态效果，上面那个是因为加了动画，录制Gif的时候不小心弄成了一直旋转的效果 布局文件 1234567891011121314151617&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;RelativeLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:tools=&quot;http://schemas.android.com/tools&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:paddingBottom=&quot;@dimen/activity_vertical_margin&quot; android:paddingLeft=&quot;@dimen/activity_horizontal_margin&quot; android:paddingRight=&quot;@dimen/activity_horizontal_margin&quot; android:paddingTop=&quot;@dimen/activity_vertical_margin&quot; tools:context=&quot;mapdemo.example.com.mpandroidchartdemo.MainActivity&quot;&gt; &lt;com.github.mikephil.charting.charts.PieChart android:id=&quot;@+id/piechart&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:text=&quot;Hello World!&quot; /&gt;&lt;/RelativeLayout&gt; 对于Chart,可以采用布局文件添加方式，也可以采用代码添加方式。 代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263public class MainActivity extends AppCompatActivity { @Bind(R.id.piechart) PieChart piechart; private Random random;//用于产生随机数字 @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); ButterKnife.bind(this); random = new Random(); initPieChart();//初始化饼图 } private void initPieChart() { ArrayList&lt;Entry&gt; yVals = new ArrayList&lt;&gt;(); //值坐标 ArrayList&lt;String&gt; xVals = new ArrayList&lt;&gt;();//对应的Lable,可以理解成X轴 for (int i = 0; i &lt; 5; i++) { xVals.add((i + 1) + &quot;月&quot;); yVals.add(new BarEntry(random.nextInt(10000), i)); } PieDataSet pieDataSet = new PieDataSet(yVals, &quot;小明每月支出&quot;);//创建饼图的一个数据集 pieDataSet.setColors(ColorTemplate.COLORFUL_COLORS); //设置成丰富多彩的颜色 DisplayMetrics metrics = getResources().getDisplayMetrics(); float px = 10 * (metrics.densityDpi / 160f); pieDataSet.setSelectionShift(px); //点击后延伸出来的长度 PieData piedata = new PieData(xVals, pieDataSet);//生成PieData piechart.setData(piedata);//给PieChart填充数据 piechart.getLegend().setPosition(Legend.LegendPosition.ABOVE_CHART_LEFT); piechart.getLegend().setForm(Legend.LegendForm.CIRCLE);//设置注解的位置和形状 piechart.setOnChartValueSelectedListener(new OnChartValueSelectedListener() {//设置值选择时的Listener @Override public void onValueSelected(Entry entry, int i, Highlight highlight) { Toast.makeText(MainActivity.this, &quot;Something selected value = &quot; + entry.getVal(), Toast.LENGTH_SHORT).show();//单纯地显示一个Toast } @Override public void onNothingSelected() { } }); piechart.setCenterText(&quot;收支明细&quot;);//中间写的文字 piechart.setCenterTextColor(Color.RED);//设置中间文字的颜色 piechart.setCenterTextRadiusPercent(0.5f);//设置文字显示的角度，180横着，默认是竖着 piechart.setCenterTextSize(12f);//设置中心文字的字体大小 piechart.setCenterTextTypeface(null);//设置字体 piechart.setDrawCenterText(true);//中心字使能开关，false时中间无法显示文字 piechart.setTransparentCircleAlpha(100);//透明圈的透明度，分3圈，一个是外面的值，然后是这个，然后就是下面的那个Hole piechart.setTransparentCircleColor(Color.RED); //设置颜色 piechart.setTransparentCircleRadius(50f);//设置半径 piechart.setDrawHoleEnabled(true);//基本同上 piechart.setHoleColor(Color.GREEN); piechart.setHoleRadius(30f); piechart.setDescription(&quot;No Deal&quot;);//设置描述文字 piechart.setDescriptionTextSize(20.f);//设置描述文字的字体 piechart.animateXY(1000, 1000); }} 值选择时的事件处理 上面的例子中其实已经有了 123456789piechart.setOnChartValueSelectedListener(new OnChartValueSelectedListener() {//设置值选择时的Listener @Override public void onValueSelected(Entry entry, int i, Highlight highlight) { Toast.makeText(MainActivity.this, &quot;Something selected value = &quot; + entry.getVal(), Toast.LENGTH_SHORT).show();//单纯地显示一个Toast } @Override public void onNothingSelected() { }}); 选中和啥都没干的回调，利用这个回调我们可以做一些跳转操作，比如从国家级报表，跳转到省级，然后市级 and so on.","link":"/2016/09/05/《Android 应用 之路》 MPAndroidChart~PieChart/"},{"title":"《Android 应用 之路》 MPAndroidChart~BubbleChart(气泡图) and RadarChart(雷达图)","text":"###简介 MPAndroidChart是PhilJay大神给Android开发者带来的福利。MPAndroidChart是一个功能强大并且使用灵活的图表开源库，支持Android和iOS两种，这里我们暂时只关注Android版本。 ###Wiki https://github.com/PhilJay/MPAndroidChart/wiki ###Javadoc https://jitpack.io/com/github/PhilJay/MPAndroidChart/v3.0.0-beta1/javadoc/ ###今日之图~BubbleChart 气泡图 参照上一篇文章的代码，稍作修改，得出气泡图 ###今日之图~RadarChart 雷达图 ###注解 BubbleChart没什么好说的，基本上和前几篇文章相似的内容，关于RadarChart，讲几个方法 12345678//特有radarchart.setWebLineWidth(3f);//设置直径方向上那条线的宽度radarchart.setDrawWeb(true);//是否画蜘蛛网，包括圈线和直径线radarchart.setSkipWebLineCount(3); //设置过滤掉几个直径线，如图，省略了3根就是这里设置的radarchart.setWebLineWidthInner(1f);//设置权限的宽度radarchart.setWebColor(Color.GREEN);//设置直径线的颜色radarchart.setWebColorInner(Color.YELLOW);//设置圈线的颜色radarchart.setWebAlpha(240);//设置颜色的透明度 ###备注 关于其他的什么CandleStickChart，Horizontal-BarChart，Combined-Chart and so on 基本上都是大同小异，基本的使用方式比较的简单，深入的使用方式都是需要结合自己的实践来一点一点的探索。MPAndroidChart基本使用情况就是这样子。","link":"/2016/09/13/《Android 应用 之路》 MPAndroidChart~BubbleChart(气泡图) and RadarChart(雷达图)/"},{"title":"《Android 应用 之路》 MPAndroidChart~ScatterChart","text":"###简介 MPAndroidChart是PhilJay大神给Android开发者带来的福利。MPAndroidChart是一个功能强大并且使用灵活的图表开源库，支持Android和IOS两种，这里我们暂时只关注Android版本。 ###Wiki https://github.com/PhilJay/MPAndroidChart/wiki ###Javadoc https://jitpack.io/com/github/PhilJay/MPAndroidChart/v3.0.0-beta1/javadoc/ ###今日之图~ScatterChart 布局文件 1234567891011121314151617&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;RelativeLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:tools=&quot;http://schemas.android.com/tools&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:paddingBottom=&quot;@dimen/activity_vertical_margin&quot; android:paddingLeft=&quot;@dimen/activity_horizontal_margin&quot; android:paddingRight=&quot;@dimen/activity_horizontal_margin&quot; android:paddingTop=&quot;@dimen/activity_vertical_margin&quot; tools:context=&quot;mapdemo.example.com.mpandroidchartdemo.MainActivity&quot;&gt; &lt;com.github.mikephil.charting.charts.ScatterChart android:id=&quot;@+id/scatterchart&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:text=&quot;Hello World!&quot; /&gt;&lt;/RelativeLayout&gt; 代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051public class MainActivity extends AppCompatActivity { @Bind(R.id.scatterchart) ScatterChart scatterChart; private Random random; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); ButterKnife.bind(this); random = new Random(); initScatterChart(); } private void initScatterChart() { ArrayList&lt;Entry&gt; yVals = new ArrayList&lt;&gt;(); ArrayList&lt;String&gt; xVals = new ArrayList&lt;&gt;();//初始化横纵坐标内容 for (int i = 0; i &lt; 5; i++) { xVals.add((i + 1) + &quot;月&quot;); yVals.add(new Entry(random.nextInt(1000), i));//产生数据 } ScatterDataSet scatterDataSet = new ScatterDataSet(yVals, &quot;小明每月支出&quot;); scatterDataSet.setColors(ColorTemplate.COLORFUL_COLORS);//设置丰富多彩的颜色 ScatterData scatterData = new ScatterData(xVals, scatterDataSet);//生成Scatterdata对象 scatterChart.setData(scatterData);//设置对应数据 scatterChart.getLegend().setPosition(Legend.LegendPosition.ABOVE_CHART_LEFT); scatterChart.getLegend().setForm(Legend.LegendForm.CIRCLE); scatterChart.setOnChartValueSelectedListener(new OnChartValueSelectedListener() { @Override public void onValueSelected(Entry entry, int i, Highlight highlight) { Toast.makeText(MainActivity.this, &quot;Something selected value = &quot; + entry.getVal(), Toast.LENGTH_SHORT).show(); } @Override public void onNothingSelected() { } }); scatterChart.getXAxis().setPosition(XAxis.XAxisPosition.BOTTOM);//设置X轴位置 scatterChart.getAxisRight().setEnabled(false);//右侧Y轴关闭 scatterChart.getAxisLeft().setAxisMinValue(0.0f);//设置最小Y值 scatterChart.getXAxis().setGridColor(Color.RED);//设置纵向网格线条颜色 scatterChart.getAxisLeft().setGridColor(Color.GREEN);//设置横向网格颜色 scatterChart.setDescription(&quot;No Deal&quot;);//设置描述内容 scatterChart.setDescriptionTextSize(20.f);//设置描述文字的字体颜色 scatterChart.animateXY(1000, 1000);//动画效果 }} ###备注 ScatterChart和LineChart，BarChart很相似，使用方式也基本相同，基本用法就是这样，后面遇到问题在解决对应的问题，碰到新的需求再解决新的需求。任何问题肯定会有解决办法。","link":"/2016/09/09/《Android 应用 之路》 MPAndroidChart~ScatterChart/"},{"title":"《Android 应用 之路》 天气预报（三）","text":"昨天介绍了基本的载入界面，今天介绍下天气信息显示界面的代码 基本ListView显示 搜索框，查询城市 上一篇文章中，载入界面通过showWeatherInfo()方法跳转到天气信息显示界面 123456789private void showWeatherInfo() { Bundle bundle = new Bundle();//bundle用来传递weatherinfolist bundle.putSerializable(Utils.WEATHERINFO, (Serializable) weatherInfoList); Intent intent = new Intent(MyActivity.this, MainActivity.class); //跳转到MainActivity intent.putExtra(Utils.WEATHERINFO, bundle); startActivity(intent); finish();//结束当前Activity} 如下是用于显示天气信息的MainActivity的内容，注意注释 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465public class MainActivity extends Activity { //定义TAG是用来打Log的 private static final String TAG = &quot;MyActivity&quot;; private ListView mListView;//ListView用来显示天气信息 private WeatherAdapter mWeatherAdapter;//ListView对应的Adapter private EditText mSearchEt;//搜索框 private ArrayList&lt;WeatherInfo&gt; weatherInfoList;//全部天气信息List private ArrayList&lt;WeatherInfo&gt; resultList;//根据搜索框输入的内容显示的结果List /** * Called when the activity is first created. */ @Override public void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); requestWindowFeature(Window.FEATURE_NO_TITLE); setContentView(R.layout.main); resultList = new ArrayList&lt;WeatherInfo&gt;(); Intent intent = getIntent(); Bundle bundle = intent.getBundleExtra(Utils.WEATHERINFO);//获取Intent中携带的信息 weatherInfoList = (ArrayList&lt;WeatherInfo&gt;) bundle.getSerializable(Utils.WEATHERINFO); Log.e(TAG, &quot;weatherinfo = &quot; + weatherInfoList.toString()); mSearchEt = (EditText) findViewById(R.id.et_search); mListView = (ListView) findViewById(R.id.lvView); mWeatherAdapter = new WeatherAdapter(this, weatherInfoList); mListView.setAdapter(mWeatherAdapter); //设置TextWathcer()根据输入框的文本变化显示不同的list mSearchEt.addTextChangedListener(new TextWatcher() { @Override public void beforeTextChanged(CharSequence charSequence, int i, int i1, int i2) { } @Override public void onTextChanged(CharSequence charSequence, int i, int i1, int i2) { } @Override public void afterTextChanged(Editable editable) { resultList.clear(); String searchstr = mSearchEt.getText().toString(); if(searchstr==null) { mWeatherAdapter.setWeatherInfoList(weatherInfoList); mWeatherAdapter.notifyDataSetChanged(); } else { for (int i = 0; i &lt; weatherInfoList.size(); i++) { String cityname = weatherInfoList.get(i).getCity(); if (cityname.contains(searchstr) || searchstr.contains(cityname)) { resultList.add(weatherInfoList.get(i)); } } //更新Adatper对应的数据 mWeatherAdapter.setWeatherInfoList(resultList); mWeatherAdapter.notifyDataSetChanged(); } } }); }} 看看WeatherAdapter的代码，WeatherAdapter继承BaseAdapter 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263//继承BaseAdapter，需要复写几个方法public class WeatherAdapter extends BaseAdapter { private static final String TAG = &quot;WeatherAdapter&quot;; private Context context; private List&lt;WeatherInfo&gt; weatherInfoList; public WeatherAdapter(Context context, List&lt;WeatherInfo&gt; weatherInfoList) { this.context = context; this.weatherInfoList = weatherInfoList; } @Override public int getCount() { return weatherInfoList.size(); }//list的size @Override public WeatherInfo getItem(int i) { return weatherInfoList.get(i); }//获取天气信息 @Override public long getItemId(int i) { return i; }//获取Item的id @Override public View getView(int i, View view, ViewGroup viewGroup) { //这个方法比较关键，返回Item view if (view == null) { view = LayoutInflater.from(context).inflate(R.layout.listviewitem, null); } ImageView weatherimage = (ImageView) view.findViewById(R.id.weatherimage); TextView cityname = (TextView) view.findViewById(R.id.cityname); TextView temp = (TextView) view.findViewById(R.id.temp); TextView weather = (TextView) view.findViewById(R.id.weather); WeatherInfo weatherInfo = weatherInfoList.get(i); cityname.setText(weatherInfo.getCity()); temp.setText(weatherInfo.getTemp1() + &quot; ~ &quot; + weatherInfo.getTemp2()); String weatherstr = weatherInfo.getWeather(); weather.setText(weatherstr); //这里大致使用几个图片，具体做法，不同的json数据查询api中应该可以查询到支持的天气种类，根据查询到的种类设置不用的图片，这里暂且只分为4种，避免我的apk界面太丑 不忍直视 if(weatherstr.contains(&quot;雨&quot;)) { weatherimage.setImageResource(R.drawable.rain); } else if(weatherstr.contains(&quot;阴&quot;)) { weatherimage.setImageResource(R.drawable.yin); } else if(weatherstr.contains(&quot;云&quot;)) { weatherimage.setImageResource(R.drawable.cloud); } else if(weatherstr.contains(&quot;雪&quot;)) { weatherimage.setImageResource(R.drawable.snow); } else { weatherimage.setImageResource(R.drawable.sun); } return view; } //方便替换List public void setWeatherInfoList(List&lt;WeatherInfo&gt; list) { this.weatherInfoList = list; }} 基本效果图：（录屏大师录屏） 源代码下载路径： http://download.csdn.net/detail/poorkick/9510243 缺陷： 每次进入需要载入数据，可以替换成根据时间戳判断是否数据有更新,当然这个对查询借口有点依赖，本地通过数据库存储当前信息 天气信息由于使用的是气象台的，数据更新自己本身无法掌握，可以替换成其他查询接口 后续可能会再做一个更完善的天气预报应用，采用新的查询接口和UI界面 界面简陋，代码不完善，见谅，工作之余练手之作。","link":"/2016/05/04/《Android 应用 之路》 天气预报（三）/"},{"title":"《Android 应用 之路》 天气预报（一）","text":"###Android天气预报客户端### ####设计思路#### 欢迎界面，版本号，应用名 + 数据后台加载（所有城市的信息获取） 数据加载完成后跳转到显示界面，显示所有查询到的城市的天气信息 欢迎界面和天气显示界面分别为单独的Activity Activity数据传递使用Bundle 网络请求采用Google原始的Volley包 后台数据请求采用异步AsyncTask的方式以及实时的进度条的更新 天气显示界面采用简单的ListView ####使用的Android内容#### Activity的跳转以及数据的传递 网络数据请求以及Json数据的解析 Volley的初级使用 ListView的初级使用 AsyncTask的初级使用 ProgressBar的初级使用 ####如何获取天气信息####采用www.weather.com.cn提供给我们的接口例如请求，北京的天气预报http://www.weather.com.cn/data/cityinfo/101010100.html获取的信息{“weatherinfo”:{“city”:“北京”,“cityid”:“101010100”,“temp1”:”-2℃”,“temp2”:“16℃”,“weather”:“晴”,“img1”:“n0.gif”,“img2”:“d0.gif”,“ptime”:“18:00”}}JSon数据格式 支持的城市还是比较多的 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465private int[] mCityCodeList = {101010100, 101010300, 101010400, 101010500, 101010600, 101010700, 101010800, 101010900, 101011000, 101011100, 101011200, 101011300, 101011400, 101011500, 101011600, 101011700, 101011800, 101011900, 101012000, 101012100, 101012200, 101010200, 101030100, 101030300, 101030400, 101030500, 101030600, 101031400, 101030800, 101030900, 101031000, 101031100, 101031200, 101030200, 101030700, 101020100, 101020300, 101020500, 101020600, 101021300, 101020800, 101020900, 101021000, 101021100, 101021200, 101020200, 101020700, 101090101, 101090301, 101090402, 101090501, 101091101, 101090701, 101090801, 101090901, 101091001, 101090201, 101090601, 101180101, 101180301, 101180401, 101180501, 101180601, 101180701, 101180801, 101180901, 101181001, 101181101, 101181201, 101181301, 101181401, 101181501, 101181601, 101181701, 101181801, 101180201, 101220101, 101220301, 101220401, 101220501, 101220601, 101220701, 101220801, 101220901, 101221001, 101221101, 101221201, 101221301, 101221401, 101221501, 101221601, 101221701, 101220201, 101210101, 101211101, 101210201, 101210301, 101210901, 101210501, 101210601, 101210701, 101210801, 101211001, 101210401, 101040100, 101040300, 101040400, 101040500, 101040600, 101040700, 101040800, 101040900, 101041000, 101041100, 101041200, 101041300, 101041400, 101041500, 101041600, 101041700, 101041800, 101041900, 101042000, 101042100, 101042200, 101042300, 101042400, 101042500, 101042600, 101042700, 101042800, 101042900, 101043000, 101043100, 101043200, 101043300, 101043400, 101043600, 101043700, 101040200, 101230101, 101230501, 101230601, 101230701, 101230509, 101230901, 101230201, 101230301, 101230401, 101230801, 101160101, 101160301, 101160401, 101160501, 101160601, 101161401, 101160801, 101160901, 101161001, 101161101, 101161201, 101161301, 101160201, 101160701, 101280101, 101280301, 101280401, 101280501, 101280601, 101280701, 101280800, 101280901, 101281001, 101281101, 101281201, 101281301, 101281401, 101281501, 101281601, 101281701, 101281801, 101281901, 101282001, 101282101, 101280201, 101300101, 101300301, 101300401, 101300501, 101300601, 101301401, 101300801, 101300901, 101301001, 101301101, 101301201, 101301301, 101300201, 101300701, 101260101, 101260301, 101260401, 101260906, 101260601, 101260701, 101260801, 101260201, 101260501, 101290101, 101290301, 101290601, 101290701, 101290801, 101290901, 101291001, 101291101, 101291201, 101291301, 101291401, 101291501, 101291601, 101290201, 101290401, 101290501, 101080101, 101080301, 101080401, 101080501, 101081201, 101080701, 101080801, 101080901, 101081000, 101081101, 101080201, 101080601, 101240101, 101240301, 101240401, 101240501, 101241101, 101240701, 101240801, 101240901, 101241001, 101240201, 101240601, 101200101, 101200501, 101200801, 101200901, 101201001, 101201101, 101201201, 101201301, 101201401, 101201501, 101201601, 101201701, 101200201, 101200301, 101200401, 101200601, 101200701, 101270101, 101270301, 101270401, 101270501, 101270601, 101270701, 101270801, 101270901, 101271001, 101271101, 101271201, 101271301, 101271401, 101271501, 101271601, 101271701, 101271801, 101271901, 101272001, 101272101, 101270201, 101170101, 101170501, 101170401, 101170201, 101170301, 101150101, 101150301, 101150801, 101150501, 101150601, 101150701, 101150201, 101150401, 101120101, 101120601, 101120901, 101121001, 101121101, 101121201, 101121301, 101121401, 101121501, 101121601, 101121701, 101120201, 101120301, 101120401, 101120501, 101120701, 101120801, 101110101, 101110300, 101110401, 101111001, 101110601, 101110701, 101110801, 101110901, 101110200, 101110501, 101100101, 101100701, 101100801, 101100901, 101101001, 101100501, 101100201, 101100301, 101100401, 101100601, 101101100, 101130101, 101130301, 101130401, 101130501, 101130601, 101130701, 101130801, 101130901, 101131001, 101131101, 101131201, 101131301, 101131401, 101131501, 101131601, 101130201, 101140101, 101140301, 101140701, 101140501, 101140601, 101140201, 101140401, 101340101, 101340201, 101340401, 101310101, 101310201, 101310202, 101310203, 101310204, 101310205, 101310206, 101310207, 101310208, 101310209, 101310210, 101310211, 101310212, 101310214, 101310215, 101310216, 101310217, 101310220, 101310221, 101310222, 101310102, 101250101, 101250301, 101250401, 101250501, 101250601, 101250700, 101250801, 101250901, 101251001, 101251101, 101251201, 101251301, 101251401, 101251501, 101250201, 101190101, 101190301, 101190401, 101190501, 101190601, 101191301, 101190801, 101190901, 101191001, 101191101, 101191201, 101190201, 101190701, 101050101, 101050301, 101050401, 101050501, 101050601, 101051301, 101050801, 101050901, 101051002, 101051101, 101051201, 101050201, 101050701, 101060101, 101060301, 101060401, 101060901, 101060601, 101060701, 101060801, 101060201, 101060501, 101070101, 101070301, 101070401, 101070501, 101070601, 101071401, 101070801, 101070901, 101071001, 101071101, 101071201, 101071301, 101070201, 101070701}; 大概就是这么多，具体对应的内容，由于这个简单的天气预报主要是为了练手，直接遍历获取对应的信息，然后使用ListView展示，没有做UI优化。 后面的博客会不断优化，继续更新！","link":"/2016/04/25/《Android 应用 之路》 天气预报（一）/"},{"title":"《Android 应用 之路》 天气预报（四）","text":"####前言 第二次尝试完成天气预报应用，与上次不同的是，个人感觉这次的Ui不那么丑陋，整体的实用性和界面效果，用户体验相较上一次有所提升，但是还是有很多地方需要完善。 这次使用到的内容比较丰富，包括聚合数据Sdk，ButterKnife,Gson,fastjson,其实还想用一下volley的，但是聚合数据中已经有对网络请求的处理，就没有深究，顺带的看了下Material Design的内容，这么早出来的内容，现在才去了解，感觉要看的东西有很多，先在这里Marking一下，后面会继续学习对应的内容。 ####成果展示 ####开发过程中遇到的问题 ButterKnife注入后，报空指针异常 解决办法： 设置–&gt;搜索Annotation Processor，保证Enable Annotation Processing打上勾 圆角编译框的Shape 123456789101112131415161718&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;shape xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:shape=&quot;rectangle&quot;&gt; &lt;solid android:color=&quot;#ffffff&quot;/&gt; &lt;stroke android:width=&quot;2dip&quot; android:color=&quot;#A0A0A0&quot;/&gt; &lt;padding android:bottom=&quot;10dp&quot; android:left=&quot;10dp&quot; android:right=&quot;10dp&quot; android:top=&quot;10dp&quot;/&gt; &lt;corners android:radius=&quot;10dp&quot;/&gt;&lt;/shape&gt; 然后采用android:background=”@drawable/shape”使用 3.已经使用了shape文件作为background的View如何设置背景色 GradientDrawable myGrad = (GradientDrawable)XXXView.getBackground(); myGrad.setColor(getResources().getColor(R.color.choosecitysearchbackground));","link":"/2016/05/14/《Android 应用 之路》 天气预报（四）/"},{"title":"《Android 应用 之路》 干货集中营～技术船","text":"技术船 每日提供技术干货的 App 下载 fir 酷安 干货数据源 应用中的所有干货数据均来自干货集中营。 App设计 色调：远州鼠、落栗、苏芳、石竹、枯草、柳煤竹茶、锖青磁、鸠羽紫八种淡雅的颜色，分别对应不同的干货数据。 布局：简约风格，极简主义，去繁就简。 排版：最简单的Toolbar + RecyclerView UI设计 黑白灰 圆角 材料设计 代码设计 Retrofit+RxJava 的组合获取网络数据; FlycoTabLayout作为主界面结构，配合Fragment，实现“每日干货”，“分类数据”，“妹纸图片”和关于四个界面; BGARefreshLayout配合RecyclerView和自定义多类型Item结构实现干货数据的展示; MaterialAbout作为“关于”界面的基础； Glide作为图片加载框架； RxJava+Retrofit配合fir.im的接口实现版本更新功能； Share功能全部采用系统自带，基本可以满足需求。 ButterKnife注解库 Gson作为json数据解析库 依赖库 Glide RxAndroid RxJava Retrofit okhttp3 Gson ButterKnife BGARefreshLayout-Android FlycoTabLayout MaterialAbout Author CSDN Website 掘金 效果图","link":"/2017/04/13/《Android 应用 之路》 干货集中营～技术船/"},{"title":"《Android 应用 之路》 每日一文简单版","text":"1. 简介 前段时间学习Kotlin，准备找个东西下手，复杂的内容暂时也处理不了，所以选了“每日一文”的接口作为测试，主要是为了熟悉Kotlin的语法和anko中的数据库操作。 2. 内容 Kotlin基本语法 anko-common使用 anko-sqlite使用 Navigation+DrawerLayout实现左右抽屉菜单 Retrofit + Okhttp + Rxjava2 + Gson 处理网络请求 Material Design 3. 思路 启用开发者模式，打开“显示边界布局”，你可以看到应用唯一的一个主界面采用是一体的，没有控件的分离，猜测采用的是混合式开发，所以呢，对我们没有什么帮助。只能按照自己的方式，实现它的功能。毕竟是为了熟悉语言，不深究。 4. 依赖库12ext.kotlin_version = &apos;1.1.2-5&apos;ext.anko_version = &apos;0.10.0&apos; 123456789101112131415161718192021compile fileTree(include: [&apos;*.jar&apos;], dir: &apos;libs&apos;)compile &quot;org.jetbrains.kotlin:kotlin-stdlib:$kotlin_version&quot;compile &quot;org.jetbrains.anko:anko-common:$anko_version&quot;compile &quot;org.jetbrains.anko:anko-sqlite:$anko_version&quot;compile &quot;org.jetbrains.kotlin:kotlin-stdlib-jre7:$kotlin_version&quot;compile &apos;com.android.support:appcompat-v7:25.3.1&apos;compile &apos;com.android.support:design:25.3.1&apos;compile &apos;com.android.support:recyclerview-v7:25.3.1&apos;compile &apos;com.android.support:cardview-v7:25.3.1&apos;compile &apos;com.android.support:support-v13:25.3.1&apos;compile &apos;com.google.code.gson:gson:2.7&apos;compile &apos;com.squareup.retrofit2:retrofit:2.2.0&apos;compile &apos;com.squareup.retrofit2:converter-gson:2.1.0&apos;compile &apos;com.squareup.retrofit2:adapter-rxjava2:2.2.0&apos;compile &apos;io.reactivex.rxjava2:rxandroid:2.0.1&apos;compile &apos;io.reactivex.rxjava2:rxjava:2.x.y&apos;compile &apos;com.squareup.okhttp3:logging-interceptor:3.4.1&apos;compile &apos;com.squareup.okhttp3:okhttp:3.4.1&apos;compile &apos;com.android.support:support-vector-drawable:25.3.1&apos;compile &apos;info.hoang8f:android-segmented:1.0.6&apos;compile &apos;com.kyleduo.switchbutton:library:1.4.6&apos; 5. 效果 6. Github OneArticle 7. 备注 每日一文接口采用非正式方式获取，仅供学习，若有侵权请告知，即刻删除。","link":"/2017/07/31/《Android 应用 之路》 每日一文简单版/"},{"title":"《Android 应用 之路》 百度地图API使用（1）","text":"###简介 详情请看百度地图官方网站 http://lbsyun.baidu.com/index.php?title=androidsdk/guide/introduction ###使用方式 申请密钥，针对移动平台和服务器，存在不同的AK，针对移动平台，需要填写包名和SHA1 获取SHA1的方法： 执行完成后就会出现对应的SHA1密钥 配置环境 参考官网：http://lbsyun.baidu.com/index.php?title=androidsdk/guide/buildproject ###官网Hello BaiduMapAndroidManifest.xml处理 12345&lt;application&gt; &lt;meta-data android:name=&quot;com.baidu.lbsapi.API_KEY&quot; android:value=&quot;开发者 key&quot; /&gt; &lt;/application&gt; 添加对应权限 123456789&lt;uses-permission android:name=&quot;android.permission.ACCESS_NETWORK_STATE&quot;/&gt;&lt;uses-permission android:name=&quot;android.permission.INTERNET&quot;/&gt;&lt;uses-permission android:name=&quot;com.android.launcher.permission.READ_SETTINGS&quot; /&gt;&lt;uses-permission android:name=&quot;android.permission.WAKE_LOCK&quot;/&gt;&lt;uses-permission android:name=&quot;android.permission.CHANGE_WIFI_STATE&quot; /&gt;&lt;uses-permission android:name=&quot;android.permission.ACCESS_WIFI_STATE&quot; /&gt;&lt;uses-permission android:name=&quot;android.permission.GET_TASKS&quot; /&gt;&lt;uses-permission android:name=&quot;android.permission.WRITE_EXTERNAL_STORAGE&quot;/&gt;&lt;uses-permission android:name=&quot;android.permission.WRITE_SETTINGS&quot; /&gt; 布局文件 12345678910111213&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;FrameLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:tools=&quot;http://schemas.android.com/tools&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; tools:context=&quot;mapdemo.example.com.selfbaidumap.MainActivity&quot;&gt; &lt;!--这家伙就是神奇所在 --&gt; &lt;com.baidu.mapapi.map.MapView android:id=&quot;@+id/bmapView&quot; android:layout_width=&quot;fill_parent&quot; android:layout_height=&quot;fill_parent&quot; android:clickable=&quot;true&quot; /&gt;&lt;/FrameLayout&gt; 代码修改 123456789101112131415161718192021222324252627282930313233343536373839404142434445package mapdemo.example.com.selfbaidumap;import android.os.Bundle;import android.support.v7.app.AppCompatActivity;import com.baidu.mapapi.SDKInitializer;import com.baidu.mapapi.map.MapView;public class MainActivity extends AppCompatActivity { private MapView mMapView = null; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); SDKInitializer.initialize(getApplicationContext()); setContentView(R.layout.activity_main); mMapView = (MapView) findViewById(R.id.bmapView); } @Override protected void onResume() { if (mMapView != null) { mMapView.onResume(); } super.onResume(); } @Override protected void onPause() { if (mMapView != null) { mMapView.onPause(); } super.onPause(); } @Override protected void onDestroy() { if (mMapView != null) { mMapView.onDestroy(); } super.onDestroy(); }} 官网示例效果 ###备注 刚开始，后面应该会把百度地图的一些内容慢慢学习一下，最近开始学习JS，希望自己能坚持学习，坚持博文，坚持自己的事情，加油。","link":"/2016/08/25/《Android 应用 之路》 百度地图API使用（1）/"},{"title":"《Android 应用 之路》 百度地图API使用（2）","text":"###简介 上一篇只是大致的提一下百度地图API的Android SDK的基本内容，然后抄袭一个官网上的Demo，今天看一下百度地图的第一部分，地图类型和基本的显示。 ###简单实战 不同类型地图的显示 123456789//设置地图类型//public static final int MAP_TYPE_NORMAL = 1; 普通地图//public static final int MAP_TYPE_SATELLITE = 2; 卫星地图//public static final int MAP_TYPE_NONE = 3; 空白地图private void setMapType(int type) { if (mBaiduMap != null) { mBaiduMap.setMapType(type); }} 空白地图 正常地图 卫星地图 实时交通图和百度城市热力图 123456789101112131415161718192021/* 实时交通图 false- &gt; 不开启 true -&gt; 开启 */private void setTrafficMap(boolean enabled) { if (mBaiduMap != null) { mBaiduMap.setTrafficEnabled(enabled); }}/* 百度城市热力图 false- &gt; 不开启 true -&gt; 开启*/private void setHeatMap(boolean enabled) { if (mBaiduMap != null) { mBaiduMap.setBaiduHeatMapEnabled(enabled); }} 实时交通图 ![这里写图片描述](https://img-blog.csdn.net/20160827220439569) (此图是在地图类型为空白地图时显示的) 百度城市交通热力图 ![这里写图片描述](https://img-blog.csdn.net/20160827220640947) 地图控制和手势 地图控制 地图Logo 默认在左下角显示，不可以移除。 通过mMapView.setLogoPosition(LogoPosition.logoPostionleftBottom);方法，使用枚举类型控制显示的位置，共支持6个显示位置(左下，中下，右下，左上，中上，右上)。 地图Logo不允许遮挡，可通过mBaiduMap.setPadding(paddingLeft, paddingTop, paddingRight, paddingBottom);方法可以设置地图边界区域，来避免UI遮挡。 其中参数paddingLeft、paddingTop、paddingRight、paddingBottom参数表示距离屏幕边框的左、上、右、下边距的距离，单位为屏幕坐标的像素密度。 指南针 指南针默认为开启状态，可以关闭显示 。 比例尺 比例尺默认为开启状态，可以关闭显示。同时支持设置MaxZoomLevel和minZoomLevel，可通过mMapView.getMapLevel获取当前地图级别下比例尺所表示的距离大小。 具体的显示位置和内容如下 备注：指南针旋转地图的时候才会出现，一开始加载的时候是不会出现的 地图平移 控 制是否启用或禁用平移的功能，默认开启。如果启用，则用户可以平移地图 地图缩放 控制是否启用或禁用缩放手势，默认开启。如果启用，用户可以双指点击或缩放地图视图。 地图俯视（3D） 控制是否启用或禁用俯视（3D）功能，默认开启。如果启用，则用户可使用双指 向下或向上滑动到俯视图。 地图旋转 控制是否启用或禁用地图旋转功能，默认开启。如果启用，则用户可使用双指 旋转来旋转地图。 禁止所有手势 控制是否一并禁止所有手势，默认关闭。如果启用，所有手势都将被禁用。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566mUiSettings = mBaiduMap.getUiSettings();setSizeByBoolean(fabZoom, mUiSettings.isZoomGesturesEnabled());setSizeByBoolean(fabZoom, mUiSettings.isZoomGesturesEnabled());setSizeByBoolean(fabScroll, mUiSettings.isScrollGesturesEnabled());setSizeByBoolean(fabOverlook, mUiSettings.isOverlookingGesturesEnabled());setSizeByBoolean(fabRotate, mUiSettings.isRotateGesturesEnabled());setSizeByBoolean(fabCompass, mUiSettings.isCompassEnabled());private void setSizeByBoolean(FloatingActionButton fab , boolean bl) { if(bl) { fab.setButtonSize(FloatingActionButton.SIZE_NORMAL); } else { fab.setButtonSize(FloatingActionButton.SIZE_MINI); }}public void onClick(View view) {...case R.id.fab_zoom: if (mUiSettings.isZoomGesturesEnabled()) { mUiSettings.setZoomGesturesEnabled(false); fabZoom.setButtonSize(FloatingActionButton.SIZE_MINI); } else { mUiSettings.setZoomGesturesEnabled(true); fabZoom.setButtonSize(FloatingActionButton.SIZE_NORMAL); } break; case R.id.fab_scroll: if (mUiSettings.isScrollGesturesEnabled()) { mUiSettings.setScrollGesturesEnabled(false); fabScroll.setButtonSize(FloatingActionButton.SIZE_MINI); } else { mUiSettings.setScrollGesturesEnabled(true); fabScroll.setButtonSize(FloatingActionButton.SIZE_NORMAL); } break; case R.id.fab_rotate: if (mUiSettings.isRotateGesturesEnabled()) { mUiSettings.setRotateGesturesEnabled(false); fabRotate.setButtonSize(FloatingActionButton.SIZE_MINI); } else { mUiSettings.setRotateGesturesEnabled(true); fabRotate.setButtonSize(FloatingActionButton.SIZE_NORMAL); } break; case R.id.fab_overlook: if (mUiSettings.isOverlookingGesturesEnabled()) { mUiSettings.setOverlookingGesturesEnabled(false); fabOverlook.setButtonSize(FloatingActionButton.SIZE_MINI); } else { mUiSettings.setOverlookingGesturesEnabled(true); fabOverlook.setButtonSize(FloatingActionButton.SIZE_NORMAL); } break; case R.id.fab_compass: if (mUiSettings.isCompassEnabled()) { mUiSettings.setCompassEnabled(false); fabCompass.setButtonSize(FloatingActionButton.SIZE_MINI); } else { mUiSettings.setCompassEnabled(true); fabCompass.setButtonSize(FloatingActionButton.SIZE_NORMAL); } break;...} 实际结果 (好像并不能从图里看出什么呵 - - !)","link":"/2016/08/27/《Android 应用 之路》 百度地图API使用（2）/"},{"title":"《Android 应用 之路》 百度地图API使用（3）","text":"###前言 上一篇讲解并实践了百度地图基本显示，地图类型，实时交通图，热力图，地图控制和手势控制，今天看下在地图上添加view和覆盖物。 地图Logo不允许遮挡，可通过mBaiduMap.setPadding(paddingLeft, paddingTop, paddingRight, paddingBottom);方法可以设置地图边界区域，来避免UI遮挡。 其中参数paddingLeft、paddingTop、paddingRight、paddingBottom参数表示距离屏幕边框的左、上、右、下边距的距离，单位为屏幕坐标的像素密度。 —————–&gt;利用这个来添加自定义的内容 标注覆盖物 几何图形覆盖物 文字覆盖物 弹出窗覆盖物 ###内容 地图上添加View 由于地图的Logo不允许被遮挡，百度自然会想办法针对一些开发者场景作出自己的调整，比如上面所说的setPadding()或者setViewPadding()一样好使，具体的使用分为两步： 第一步， 1mBaiduMap.setPadding(0, 0, 0, 200); 第二步， 123456789101112private void addView() { TextView textView = new TextView(this); textView.setText(&quot;这是用户自定义的View,这个时候logo和底部的一些内容会向上移动，因为MapView设置了底部Padding&quot;); textView.setBackgroundResource(R.color.colorPrimary); //创建一个TextView然后往底部放置，官方Demo如是操作 MapViewLayoutParams.Builder builder = new MapViewLayoutParams.Builder(); builder.layoutMode(MapViewLayoutParams.ELayoutMode.absoluteMode); builder.width(bmapView.getWidth()); builder.height(200); builder.point(new Point(0, bmapView.getHeight())); builder.align(MapViewLayoutParams.ALIGN_LEFT, MapViewLayoutParams.ALIGN_BOTTOM); bmapView.addView(textView, builder.build());} 这样子就在底部添加了一个TextView，当然想添加其他的View自然也是可行的，具体效果图往下看。 地理编码，标注覆盖物和弹出窗覆盖物 利用标注覆盖物在地图上的特定位置添加标注，然后给标注覆盖物设置点击监听展示弹出覆盖物 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071//这个是“打点”按钮的点击事件，点击事件发生后，地理编码对象执行Address-&gt;location的解析，解析结果返回之后，拿到对应的点的经纬度，也就是LatLng实例和对应的地址信息，然后执行addMarker操作private void addPointByEditText() { String placename = etPoint.getText().toString(); final GeoCoder geo = GeoCoder.newInstance(); geo.setOnGetGeoCodeResultListener(new OnGetGeoCoderResultListener() { @Override public void onGetGeoCodeResult(GeoCodeResult geoCodeResult) { if (geoCodeResult.getLocation() != null) { addMarker(geoCodeResult.getLocation() , geoCodeResult.getAddress()); //addText(geoCodeResult.getLocation(), &quot;看过来 :&quot; + geoCodeResult.getAddress());//这个是后面添加文字覆盖物的时候使用到的 } else { Toast.makeText(MainActivity.this, &quot; No Result of GeoCoder! Sorry&quot;, Toast.LENGTH_SHORT).show(); } } @Override public void onGetReverseGeoCodeResult(ReverseGeoCodeResult reverseGeoCodeResult) { } }); geo.geocode(new GeoCodeOption().address(placename).city(placename));}......//添加标注物private void addMarker(LatLng point, String address) { //定义Maker坐标点 //LatLng point = new LatLng(39.963175, 116.400244); //构建MarkerOption，用于在地图上添加Marker Bundle bundle = new Bundle(); bundle.putParcelable(&quot;LATLNG&quot;, point);//传递Bundle对象，方便后面读取对应的info来创建pop window bundle.putString(&quot;ADDRESS&quot;, address); OverlayOptions option = new MarkerOptions() .position(point) .icon(bitmap).extraInfo(bundle); //在地图上添加Marker，并显示 mBaiduMap.addOverlay(option);}//设置标注覆盖物的点击事件监听mBaiduMap.setOnMarkerClickListener(new BaiduMap.OnMarkerClickListener() { @Override public boolean onMarkerClick(Marker marker) { //这里是MarkerOption创建的时候传入的点坐标和对应的地址信息 if (marker.getExtraInfo() != null) { LatLng point = marker.getExtraInfo().getParcelable(&quot;LATLNG&quot;); String address = marker.getExtraInfo().getString(&quot;ADDRESS&quot;); addPop(point, address); } return false; }});......//添加弹出窗覆盖物private void addPop(LatLng point, String message) { //创建InfoWindow展示的view Button button = new Button(getApplicationContext()); button.setBackgroundResource(R.drawable.marker_info_bg); button.setTextColor(Color.WHITE); button.setText(message); //创建InfoWindow , 传入 view， 地理坐标， y 轴偏移量 InfoWindow mInfoWindow = new InfoWindow(button, point, -47); //显示InfoWindow mBaiduMap.showInfoWindow(mInfoWindow);} 实际效果图： 文字覆盖物 文字覆盖物主要就是在地图上添加一些字串， 用上面的代码，将标注覆盖物改成文字覆盖物 1234567891011121314//设置文字覆盖物private void addText(LatLng point, String message) { //构建文字Option对象，用于在地图上添加文字 OverlayOptions textOption = new TextOptions() .bgColor(0xAAFFFF00) .fontSize(35) .fontColor(0xFFFF00FF) .text(message) .rotate(-30) .position(point); //在地图上添加该文字对象并显示 mBaiduMap.addOverlay(textOption);} 实际效果图： 行政区边界搜索和多边形覆盖物 利用DistrictSearch和PolyOverlay，实现圈出行政区域的效果 12345678910111213141516171819202122232425262728293031323334mDistrictSearch = DistrictSearch.newInstance();//创建行政区域查询的实例......//添加多边形区域private void addPoly(String cityname) { //建立搜索条件 DistrictSearchOption option = new DistrictSearchOption().cityName(cityname).districtName(cityname); //设置搜索监听事件 mDistrictSearch.setOnDistrictSearchListener(new OnGetDistricSearchResultListener() { @Override public void onGetDistrictResult(DistrictResult districtResult) { if (districtResult.error == SearchResult.ERRORNO.NO_ERROR) { List&lt;List&lt;LatLng&gt;&gt; pointsList = districtResult.getPolylines(); if (pointsList == null) return; //地理边界对象 LatLngBounds.Builder builder = new LatLngBounds.Builder(); for (List&lt;LatLng&gt; polyline : pointsList) { OverlayOptions ooPolyline11 = new PolylineOptions().width(10) .points(polyline).dottedLine(true).color(Color.RED); mBaiduMap.addOverlay(ooPolyline11);//添加OverLay OverlayOptions ooPolygon = new PolygonOptions().points(polyline) .stroke(new Stroke(5, 0xAA00FF88)).fillColor(0xAAFFFF00); mBaiduMap.addOverlay(ooPolygon);//添加OverLay for (LatLng latLng : polyline) { builder.include(latLng);//包含这些点 } } } } }); mDistrictSearch.searchDistrict(option);//执行行政区域的搜索} 实际效果图： ###备注 今天先看到这里，有时间接着跟~","link":"/2016/08/29/《Android 应用 之路》 百度地图API使用（3）/"},{"title":"《Android 应用 之路》 聚合数据SDK","text":"版权声明：本文为博主原创文章，未经博主允许不得转载。 https://blog.csdn.net/poorkick/article/details/51335247 ####聚合数据介绍 聚合数据是一个为智能手机开发者，网站站长，移动设备开发人员及图商提供原始数据API服务的综合性云数据平台。包含手机聚合，网站聚合，LBS聚合三部分，其功能类似于Google APIS。【来自百度百科】 首页：https://www.juhe.cn/ ####聚合数据SDK 这里我们只关注Android SDK，如果有其他的平台需要请查阅对应的内容 https://www.juhe.cn/juhesdk/sdk 聚合数据SDK——Android平台 https://www.juhe.cn/juhesdk/adocs/v/2 网页中有对应的使用方法和过程，这里就不做过多的累述。 这里写这篇博客是因为后面自己在开发过程中会使用到这个数据平台中的数据。具体使用方式请浏览聚合数据官网查看","link":"/2016/05/06/《Android 应用 之路》 聚合数据SDK/"},{"title":"《Android 应用 之路》一个类似今日头条的APP","text":"##简介 最近花了一两天的时间完成一个简易的新闻头条客户端的应用，引用到了SwipeRefreshLayout，CircleImageView，RxAndroid，Picasso，PhotoPicker等开源库，GsonFormat等插件，主要是用来锻炼自己独立完成APK的能力。 ##数据接口 使用的数据接口和之前的一样，聚合数据的免费接口：新闻头条，笑话大全和历史上的今天等等。这种方式就避免了自己写服务器来传递json数据的麻烦，注意力全部集中在Android应用的开发上。 ##应用地址 https://github.com/onlyloveyd/JuheNews ##效果图 ##备注 后续应用修改内容会直接更新到Github上，欢迎交流。","link":"/2016/12/07/《Android 应用 之路》一个类似今日头条的APP/"},{"title":"《Android 应用 之路》干货集中营 GankIOClient","text":"##简介 利用干货集中营 , daimajia和他的小伙伴给我们开发者带来的福利开发的一个干货集中营客户端，主要功能在阅读干货上。 Github地址： https://github.com/onlyloveyd/GankIOClient ##接口 分类接口&lt;使用方法如下&gt; ##开源库 主要用到如下开源库 1234567891011121314compile &apos;com.github.bumptech.glide:glide:3.7.0&apos;compile &apos;io.reactivex:rxandroid:1.2.1&apos;compile &apos;io.reactivex:rxjava:1.1.6&apos;compile &apos;com.squareup.retrofit2:retrofit:2.1.0&apos;compile &apos;com.squareup.retrofit2:converter-gson:2.1.0&apos;compile &apos;com.squareup.retrofit2:adapter-rxjava:2.1.0&apos;compile &apos;com.squareup.okhttp3:okhttp:3.5.0&apos;compile &apos;com.android.support:cardview-v7:25.1.0&apos;compile &apos;com.google.code.gson:gson:2.8.0&apos;compile &apos;com.jakewharton:butterknife:8.4.0&apos;annotationProcessor &apos;com.jakewharton:butterknife-compiler:8.4.0&apos;compile &apos;com.astuetz:pagerslidingtabstrip:1.0.1&apos;compile &apos;cn.bingoogolapple:bga-refreshlayout:1.1.7@aar&apos;compile &apos;cn.bingoogolapple:bga-banner:2.1.4@aar&apos; 大部分大家都很熟悉，值得一提的是bingoogolapple大神的几个开源库，使用起来很方便，有兴趣的同学可以去瞅瞅。 ##具体效果 ##写在最后 搜索功能暂时还未加上，还存在一些bug，慢慢完善，先Mark一下~ 虽然网上干货集中营的应用已经有一箩筐了，但是还是忍不住的想练下手~","link":"/2016/12/26/《Android 应用 之路》干货集中营 GankIOClient/"},{"title":"《Android 应用之路》 聚闻","text":"前言 聚闻，使用聚合新闻数据而成的新闻资讯客户端。聚合数据给用户提供了部分免费的数据接口，当然是存在请求次数限制的。学习Android应用开发后第一个小应用采用的就是聚合数据。最近把代码重构（也就是重新写，因为没有结构）了一遍。 Github地址 JuehNews 下载 fir.im 数据源 数据来源于：聚合数据，接口每天请求数量受限 App设计 黑白红，红色采用的是今日头条的红色 UI设计 黑白红 圆角 材料设计 —– (我的审美我自己是拒绝的) 代码设计 Retrofit + RxJava2 的组合获取网络数据; TabHost + Fragment 作为主界面结构,实现“资讯”，“笑话”，“趣图”，“历史上的今天”四个模块 BGARefreshLayout配合RecyclerView和自定义多类型Item结构实现数据的展示; Glide作为图片加载框架； Share功能全部采用系统自带，基本可以满足需求。 ButterKnife注解库 Gson作为json数据解析库 Pagerslidingtabstrip丰富标签页的显示 依赖库 Glide RxAndroid RxJava Retrofit okhttp3 Gson ButterKnife BGARefreshLayout-Android PagerSlidingTabStrip 效果截图","link":"/2017/06/29/《Android 应用之路》 聚闻/"},{"title":"《Android 开源库》 Matisse，来自知乎的PhotoPicker","text":"简介 Matisse，是一款由知乎开源的媒体选择器。 在Activity和Fragment中使用 支持JPEG，PNG，GIF的图片选择和MPEG，MP4格式的视频选择。不能同时选择图片和视频 两种主题可供选择，因为知乎也是两种主题 图片Loader 自定义过滤条件 使用方法Gradle1234567repositories { jcenter()}dependencies { compile &apos;com.zhihu.android:matisse:0.4.3&apos;} ProGuard 如果使用Glide作为图片加载开源库 12345678-keep public class * implements com.bumptech.glide.module.GlideModule-keep public enum com.bumptech.glide.load.resource.bitmap.ImageHeaderParser$** { **[] $VALUES; public *;}# for DexGuard only-keepresourcexmlelements manifest/application/meta-data@value=GlideModule 如果使用Picasso作为图片加载开源库 1-dontwarn com.squareup.okhttp.** 代码使用 知乎主题 1234567891011Matisse.from(MainActivity.this) .choose(MimeType.ofAll()) .countable(true) .maxSelectable(9) .addFilter(new GifSizeFilter(320, 320, 5 * Filter.K * Filter.K)) .gridExpectedSize( getResources().getDimensionPixelSize(R.dimen.grid_expected_size)) .restrictOrientation(ActivityInfo.SCREEN_ORIENTATION_PORTRAIT) .thumbnailScale(0.85f) .imageEngine(new GlideEngine()) .forResult(REQUEST_CODE_CHOOSE); Dracula主题 1234567Matisse.from(MainActivity.this) .choose(MimeType.of(MimeType.JPEG, MimeType.PNG)) .theme(R.style.Matisse_Dracula) .countable(false) .maxSelectable(9) .imageEngine(new PicassoEngine()) .forResult(REQUEST_CODE_CHOOSE); 结果处理 12345678910List&lt;Uri&gt; mSelected;@Overrideprotected void onActivityResult(int requestCode, int resultCode, Intent data) { super.onActivityResult(requestCode, resultCode, data); if (requestCode == REQUEST_CODE_CHOOSE &amp;&amp; resultCode == RESULT_OK) { mSelected = Matisse.obtainResult(data); Log.d(&quot;Matisse&quot;, &quot;mSelected: &quot; + mSelected); }} 更多详细内容请查阅官方Wiki. 效果 图片来源项目Github Zhihu Style | Dracula Style | Preview ----------- | ------------- | ------- | | 源码分析代码结构 类分析类名 | 描述 ---------------------- | ------------------------------------------------------------------------------ ImageEngine | 图片加载接口，方便后面根据Glide和Picasso分别实现 GlideEngine | Glide实现ImageEngine PicassoEngine | Picasso实现ImageEngine Filter | 过滤条件抽象类，我们可以通过集成Filter实现对应的过滤条件来对图片进行筛选，可以添加多个Filter,具体参考官方Demo中的GifSizeFilter Album | 相册Entity CaptureStrategy | 拍照相关，媒体处理authority IncapableCause | 信息处理，toast和dialog Item | 选择媒体界面的Item SelectionSpec | 选择参数类 AlbumLoader | 相册CursorLoader AlbumMediaLoader | 图片和视频CursorLoader AlbumCollection | AlbumLoader回调 AlbumMediaCollection | AlbumMediaLoader回调 SelectedItemCollection | 被选中项集合 internal/ui包 | 界面显示的Adapter,自定义视图，Fragment和Activity internal/utils包 | 工具类 MatisseActivity | 关键类，执行选择媒体操作的时候展示出来的Activity Matisse | 开源库的入口和出口，用来传递Activity和Fragment，创建SelectionSpecBuilder和返回结果 MimeType | 媒体类型 SelectionSpecBuilder | Build构造类，用来传递参数 设计思路与PhotoPicker比较 从MatisseActivity来看的话，大致的设计思路和PhotoPicker相似，都是以单独的Activity为载体，传递参数的方式和PhotoPicker不同，PhotoPicker使用的是bundle, 而Matisse使用的是SelectionSpec单例，启动应用之前，参数全部设置完毕，然后在MatisseActivity通过SelectionSpec.getInstance()拿到单例，获取参数。选择结果和PhotoPicke实现比较相似，都是通过Bundle保存结果通过setResult返回给调用的Activity或者Fragment. SelectedPreviewActivity就是PhotoPicker中的预览Activity，只是没有通过SelectionSpecBuilder对外暴露，要使用的话，我们只能自己显式的调用。 与PhotoPicker一样，都是采用Android Loader机制作为数据加载的方式，大致原理清楚，自己在平时的开发中还没有用到过，找个机会尝试一下。 Build设计模式，链式代码编写方式。 PhotoPicker使用的是Glide作为图片加载框架，而Matisse支持Glide和Picasso，但是Picasso支持的功能Glide全都有，选择一个即可（Picasso不支持Gif） Matisse，支持视频文件的选择，PhotoPicker从名字上看就不支持。 PhotoPicker支持自定义样式，主要是颜色；Matisse，支持两种主题模式，与知乎呼应。","link":"/2017/05/04/《Android 开源库》 Matisse，来自知乎的PhotoPicker/"},{"title":"《Android 开源库》Android OpenCSV","text":"OpenCSV https://sourceforge.net/projects/opencsv/ 使用参考 http://stackoverflow.com/questions/16672074/import-csv-file-to-sqlite-in-android 导出123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172public class ExportDatabaseToCSV extends AsyncTask&lt;Void, Boolean, Boolean&gt; { Context context; ProgressDialog dialog; public ExportDatabaseToCSV(Context context) { this.context = context; } @Override protected void onPreExecute() { dialog = new ProgressDialog(context); dialog.setTitle(&quot;导出CSV文件&quot;); dialog.setMessage(&quot;请稍后...&quot;); dialog.setCancelable(false); dialog.setIcon(android.R.drawable.ic_dialog_info); dialog.show(); } @Override protected Boolean doInBackground(Void... params) { File exportDir = new File(Environment.getExternalStorageDirectory(), &quot;&quot;); if (!exportDir.exists()) { exportDir.mkdirs(); } Date date = new Date(System.currentTimeMillis()); String filename = new SimpleDateFormat(&quot;yyyy-MM-dd hh:mm:ss&quot;).format(date); File file = new File(exportDir, filename + &quot;.csv&quot;); try { file.createNewFile(); CSVWriter csvWrite = new CSVWriter(new FileWriter(file)); StringBuffer check = new StringBuffer(); check.append(&quot;SELECT * FROM NOTE&quot;); DataBaseHelper db = DataBaseHelper.getInstance(GlobalField.getApplicationContext()); db.openDataBase(); Cursor curCSV = db.queryData(check.toString()); //key -&gt; get the cursor and then using opencsv csvWrite.writeNext(curCSV.getColumnNames()); while (curCSV.moveToNext()) { //Which column you want to export you can add over here... List&lt;String&gt; list = new ArrayList&lt;&gt;(); for (int i = 0, length = curCSV.getColumnCount(); i &lt; length; i++) { list.add(curCSV.getString(i)); } String[] arrStr = list.toArray(new String[list.size()]); csvWrite.writeNext(arrStr); } csvWrite.close(); curCSV.close(); return true; } catch (Exception sqlEx) { System.err.println(sqlEx.getMessage()); } return false; } @Override protected void onPostExecute(Boolean result) { if (dialog.isShowing()) { dialog.dismiss(); } if (result) { Toast.makeText(context, &quot;SqLite Data has been Exported!&quot;, Toast.LENGTH_LONG).show(); } else { Toast.makeText(context, &quot;SqLite Data has not Exported&quot;, Toast.LENGTH_LONG).show(); } }} 导入12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273public class ImportCVSToSQLiteDataBase extends AsyncTask&lt;String, String, String&gt; { Activity activity; Context context; File file=null; private ProgressDialog dialog; public ImportCVSToSQLiteDataBase(Context context, Activity activity,File file) { this.context=context; this.activity=activity; this.file=file; } @Override protected void onPreExecute() { dialog=new ProgressDialog(context); dialog.setTitle(&quot;Importing Data into SecureIt DataBase&quot;); dialog.setMessage(&quot;Please wait...&quot;); dialog.setCancelable(false); dialog.setIcon(android.R.drawable.ic_dialog_info); dialog.show(); }@Overrideprotected String doInBackground(String... params) { String data=&quot;&quot;; Log.d(getClass().getName(), file.toString()); try{ CSVReader reader = new CSVReader(new FileReader(file)); String [] nextLine; //here I am just displaying the CSV file contents, and you can store your file content into db from while loop... while ((nextLine = reader.readNext()) != null) { // nextLine[] is an array of values from the line String accId=nextLine[0]; String acc_name=nextLine[1]; data=data+&quot;AccId:&quot;+accId +&quot; Account_name:&quot;+acc_name+&quot;\\n&quot;;//change to save to datebase instead of showing } return data; } catch (Exception e) { Log.e(&quot;Error&quot;, &quot;Error for importing file&quot;); } return data=&quot;&quot;; }protected void onPostExecute(String data) { if (dialog.isShowing()) { dialog.dismiss(); } if (data.length()!=0) { Toast.makeText(context, &quot;File is built Successfully!&quot;+&quot;\\n&quot;+data, Toast.LENGTH_LONG).show(); }else{ Toast.makeText(context, &quot;File fail to build&quot;, Toast.LENGTH_SHORT).show(); } }} 问题 导出的CSV文件如果使用Excel直接打开，可能出现中文乱码 解决办法： 使用记事本打开CSV文件，“文件”-&gt;“另存为”，编码方式选择ANSI，保存完毕后，用EXCEL打开这个文件就不会出现乱码的情况。","link":"/2017/04/08/《Android 开源库》Android OpenCSV/"},{"title":"《Android 源码分析（0）》 Android 8.0 源码下载编译","text":"1. 介绍 最近打算利用工作之余，学习Android源码。自从开始接触应用开发之后，这一块就一直被忽略了。今天从Ubuntu系统安装开始，到Android8.0的代码编译完成，参照别人的经验，过程还算比较顺利。 2. 步骤 参考官网文档： https://source.android.com/source/initializing 或者博文： http://www.jianshu.com/p/367f0886e62b 基本上依照这篇博文，基本上就可以在Ubuntu环境下快速的完成Android源码的下载和编译。注意切换分支到自己想要的branch上。 3. 编译结果","link":"/2017/09/23/《Android 源码分析（0）》 Android 8.0 源码下载编译/"},{"title":"《Android 进阶（ 六）》Simple SlideToggleView For Android","text":"SlideToggleView 🍎A simple SlideToggleView for Android. InstallationGradle Step 1. Add it in your root build.gradle at the end of repositories: 123456allprojects { repositories { ... maven { url &apos;https://jitpack.io&apos; } }} Step 2. Add the dependency 123dependencies { iimplementation &apos;com.github.onlyloveyd:SlideToggleView:1.0&apos;} Basic Usage Step 1. Add SlideToggleView into your layout 12345678910111213&lt;cn.onlyloveyd.slidetoggleview.SlideToggleView android:id=&quot;@+id/slideToggleView&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;56dp&quot; android:layout_marginTop=&quot;40dp&quot; android:background=&quot;@drawable/slide_bg&quot; app:stv_blockBottomMargin=&quot;2dp&quot; app:stv_blockLeftMargin=&quot;2dp&quot; app:stv_blockRightMargin=&quot;2dp&quot; app:stv_blockTopMargin=&quot;3dp&quot; app:stv_remain=&quot;80dp&quot; app:stv_slideBlock=&quot;@drawable/slide_block&quot; app:stv_text=&quot;Slide To Unlock&quot; /&gt; Step 2.(optional)add SlideToggleListener for SlideToggleView 123456789101112131415mBinding.slideToggleView.setSlideToggleListener(new SlideToggleView.SlideToggleListener() { @Override public void onBlockPositionChanged(SlideToggleView view, int left, int total, int slide) { String content = String.format(Locale.CHINESE, &quot;left: %d - total: %d - slide: %d&quot;, left, total, slide); mBinding.shimmerTextView.setText(content); } @Override public void onSlideOpen(SlideToggleView view) { Toast.makeText(MainActivity.this, &quot;Slide Toggle is Open&quot;, Toast.LENGTH_SHORT).show(); } }); AttributesAttribute | Usage --------------------- | --------- stv_text | 居中文字内容 stv_textSize | 居中文字大小 stv_textColor | 居中文字颜色 stv_slideBlock | 滑块图片 stv_blockLeftMargin | 滑块左间距 stv_blockRightMargin | 滑块左间距 stv_blockTopMargin | 滑块顶部间距 stv_blockBottomMargin | 滑块底部间距 stv_remain | 滑块打开误差范围值Basic Result","link":"/2019/01/12/《Android 进阶（ 六）》Simple SlideToggleView For Android/"},{"title":"《Android 进阶（三）》 自定义View之支持Gravity的ViewGroup","text":"1. 前言 前面两篇博客主要是介绍直接继承View后复写onDraw方法来实现一些不规则图形的绘制，来达到满足不同自定义View的需求，更注重的是图形的绘制变换和效果展示，前两天学习一些自定义ViewGroup的相关内容，分享一下。 2. 目标 支持Gravity的ViewGroup。 支持的Gravity的种类：左上，右上，左下，右下，中心。 3. 实现步骤 自定义属性：custom_gravity 自定义属性的取值范围：1－5(topleft, topright, bottomleft, bottomright, center) 自定义LayoutParam。参考LinearLayout，RelativeLayout等等 复写onMeasure， onLayout 复写LayoutParam相关的几个方法 4. 几点提醒 onMeasure使用来确定子view的大小的，没有那么神秘，就是根据ViewGroup的大小和子View的LayoutParam来确定子View应该有的大小。通过 MeasureSpec.makeMeasureSpec的方式生成MeasureSpec，通过调用子View的measure方法，把数据传递给子View，方便确定大小。 onLayout方法同来确定子View的位置，传入的参数是当前View Group的上下左上角和右下角的位置，通过子View的属性值和一些其他判断条件，来计算子View应该摆放在哪个位置，然后通过调用子View的layout方法来摆放。 自定义LayoutParam。需要复写几个方法 5. 代码实现 5.1 自定义属性1234567891011&lt;declare-styleable name=&quot;CustomViewGroup&quot;&gt; &lt;attr name=&quot;custom_gravity&quot;/&gt;&lt;/declare-styleable&gt;&lt;attr name=&quot;custom_gravity&quot;&gt; &lt;flag name=&quot;topleft&quot; value=&quot;1&quot;/&gt; &lt;flag name=&quot;topright&quot; value=&quot;2&quot;/&gt; &lt;flag name=&quot;bottomleft&quot; value=&quot;3&quot;/&gt; &lt;flag name=&quot;bottomright&quot; value=&quot;4&quot;/&gt; &lt;flag name=&quot;center&quot; value=&quot;5&quot;/&gt;&lt;/attr&gt; 5.2 CustomViewGroup 代码写的比较简单，方便理解，把每个子View的大小全部设置成相同的大小。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121public class CustomViewGroup extends ViewGroup { public CustomViewGroup(Context context) { super(context); } public CustomViewGroup(Context context, AttributeSet attrs) { super(context, attrs); } public CustomViewGroup(Context context, AttributeSet attrs, int defStyleAttr) { super(context, attrs, defStyleAttr); } @Override protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) { super.onMeasure(widthMeasureSpec, heightMeasureSpec); int widthSize = MeasureSpec.getSize(widthMeasureSpec); int heightSize = MeasureSpec.getSize(heightMeasureSpec); /** * 每个子View的大小都设置成相同大小 */ for (int i = 0; i &lt; getChildCount(); i++) { View child = getChildAt(i); int mode = MeasureSpec.EXACTLY; int childWidth = widthSize / 4; int childHeight = heightSize / 4; child.measure(MeasureSpec.makeMeasureSpec(childWidth, mode), MeasureSpec.makeMeasureSpec(childHeight, mode)); } } @Override protected void onLayout(boolean changed, int l, int t, int r, int b) { for (int i = 0; i &lt; getChildCount(); i++) { View child = getChildAt(i); int width = child.getMeasuredWidth(); int height = child.getMeasuredHeight(); final LayoutParams lp = (LayoutParams) child.getLayoutParams(); int gravity = lp.gravity; switch (gravity) { case LayoutParams.TOPLEFT_GRAVITY: child.layout(l, t, width, height); break; case LayoutParams.TOPRIGHT_GRAVITY: child.layout(r - width, t, r, height); break; case LayoutParams.BOTTOMLEFT_GRAVITY: child.layout(l, b - height, width, b); break; case LayoutParams.BOTTOMRIGHT_GRAVITY: child.layout(r - width, b - height, r, b); break; case LayoutParams.CENTER_GRAVITY: child.layout((r - width) / 2, (b - height) / 2, (r + width) / 2, (b + height) / 2); break; default: break; } } } @Override public ViewGroup.LayoutParams generateLayoutParams(AttributeSet attrs) { return new LayoutParams(getContext(), attrs); } @Override protected ViewGroup.LayoutParams generateLayoutParams(ViewGroup.LayoutParams p) { return new LayoutParams(p); } @Override protected ViewGroup.LayoutParams generateDefaultLayoutParams() { return new LayoutParams(ViewGroup.LayoutParams.WRAP_CONTENT, ViewGroup.LayoutParams.WRAP_CONTENT, 1); } @Override protected boolean checkLayoutParams(ViewGroup.LayoutParams p) { return p instanceof LayoutParams; } public static class LayoutParams extends ViewGroup.LayoutParams { public static final int UNSPECIFIED_GRAVITY = -1; public static final int TOPLEFT_GRAVITY = 1; public static final int TOPRIGHT_GRAVITY = 2; public static final int BOTTOMLEFT_GRAVITY = 3; public static final int BOTTOMRIGHT_GRAVITY = 4; public static final int CENTER_GRAVITY = 5; public int gravity = UNSPECIFIED_GRAVITY; public LayoutParams(@NonNull Context c, @Nullable AttributeSet attrs) { super(c, attrs); final TypedArray a = c.obtainStyledAttributes(attrs, R.styleable.CustomViewGroup); gravity = a.getInt(R.styleable.CustomViewGroup_custom_gravity, UNSPECIFIED_GRAVITY); a.recycle(); } public LayoutParams(int width, int height, int gravity) { super(width, height); this.gravity = gravity; } public LayoutParams(@NonNull ViewGroup.LayoutParams source) { super(source); this.gravity = TOPLEFT_GRAVITY; } public LayoutParams(@NonNull LayoutParams source) { super(source); this.gravity = source.gravity; } }} 6. 效果图 7. 源代码 源代码还是上传到Github CustomViewDemo 最后 关注「码道长」，了解最前沿的技术知识，抬高自己的天花板。","link":"/2017/10/20/《Android 进阶（三）》 自定义View之支持Gravity的ViewGroup/"},{"title":"《Android 进阶（三）》 自定义安全键盘-LazyKeyboard","text":"LazyKeyboard LazyKeyboard，利用PopupWindow实现，字母，符号，数字自定义安全键盘 使用Gradle Step 1. 项目根目录下 build.gradle 123456allprojects { repositories { ... maven { url &apos;https://jitpack.io&apos; } }} Step 2. 模块目录下build.gradle添加依赖 123dependencies { implementation &apos;com.github.onlyloveyd:LazyKeyboard:v1.1&apos;} 基本用法 Step 1. 添加 SecurityEditText 至界面布局。 12345678910111213&lt;LinearLayout android:id=&quot;@+id/container&quot; ...&quot;&gt; &lt;com.gs.keyboard.SecurityEditText android:id=&quot;@+id/et_security_keyboard&quot; android:layout_width=&quot;match_parent&quot; ... /&gt; &lt;EditText android:id=&quot;@+id/et_security_keyboard_two&quot; ... /&gt; &lt;/LinearLayout&gt; Step 2. 初始化 SecurityKeyboard 123456//配置部分属性SecurityConfigure configure = new SecurityConfigure() .setDefaultKeyboardType(KeyboardType.NUMBER) .setLetterEnabled(false);//第一个参数为包含SecurityEditText的视图，安全键盘的显示以其为锚点securityKeyboard = new SecurityKeyboard(binding.loginLayout, configure); Step 2. 目前支持自定义选项 自定义选项 | 意义 ------------------- | ------------------------------- selectedColor | 选中键盘类型凸显颜色，默认为0xff66aeff unSelectedColor | 未选中键盘类型凸显颜色，默认为Color.BLACK isNumberEnabled | 是否显示数字键盘，默认为true isLetterEnabled | 是否显示字母键盘，默认为true isSymbolEnabled | 是否显示符号键盘，默认为true defaultKeyboardType | 默认选中的键盘，默认值为KeyboardType.LETTER基础效果","link":"/2018/06/22/《Android 进阶（三）》 自定义安全键盘-LazyKeyboard/"},{"title":"《Android 进阶（五）》应用分享简单实现-LazyApkShare","text":"LazyApkShare 分享当前应用的简单实现。 开源地址 LazyApkShare 添加依赖Gradle 步骤一. 根目录下build.gradle 12345allprojects { repositories { maven { url &apos;https://jitpack.io&apos; } }} 步骤二. 添加依赖 1234dependencies { implementation &apos;com.github.onlyloveyd:LazyApkShare:1.0&apos;} 集成工作 运行时读写存储权限需要开发者自行处理.详细操作可参考示例代码。 12ShareManager shareManager = new ShareManager(this);shareManager.shareApp(getPackageName()); 实际效果 实现原理 代码相对比较简单，不做赘述。关键在于Android应用信息类ApplicationInfo中存在一个sourceDir，通过这个我们可以拿到用户安装过程中使用的安装包。然后对其执行系统分享操作即可。","link":"/2018/10/28/《Android 进阶（五）》应用分享简单实现-LazyApkShare/"},{"title":"《Android 进阶（四）》 自定义View之仿Emui开关控件","text":"1. 简介 使用华为手机，发现设置应用中的开关空间颜色听挺好看，所以自己想写一个类似的，当然不可能完全相同，但是大致的效果差不多。 操作步骤： 截图。PS取色； 判断左右两边的半径； 继承View复写onDraw方法，手动绘制。 控制开关的状态：on／off 2. 效果 3. 实现3.1 自定义属性 没有定义，颜色和半径都是按照自己的效果写成固定的，当然也可以写成自定义属性。 3.2 自定义View代码 涉及到一些动画的使用和View的事件处理 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142public class CustomSwitchView extends View { /** * 开关圆点颜色 */ private final int SWITCH_DOT_COLOR = 0xffffffff; /** * 关闭状态下的背景颜色 */ private final int OFF_BACKGROUND_COLOR = 0xffe2e2e2; /** * 打开状态下的背景颜色 */ private final int ON_BACKGROUND_COLOR = 0xff007dff; /** * 边界和开关圆点的间距 */ private final int BOUND_DOT_GAP = 8; /** * 是否打开 */ private boolean isOn = false; /** * 圆点的半径和坐标位置 */ private int mRadius; private int startX; private int endX; private float centerX; private float centerY; private RectF mRectF; /** * 开关的画笔 */ private Paint mSwitchPaint; public CustomSwitchView(Context context) { this(context, null); } public CustomSwitchView(Context context, @Nullable AttributeSet attrs) { this(context, attrs, 0); } public CustomSwitchView(Context context, @Nullable AttributeSet attrs, int defStyleAttr) { super(context, attrs, defStyleAttr); init(); } /** * 打开或者关闭 * * @param on true 打开， false 关闭 */ public void setOn(boolean on) { isOn = on; ValueAnimator animator; if (on) { animator = ValueAnimator.ofFloat(centerX, endX); } else { animator = ValueAnimator.ofFloat(centerX, startX); } animator.setDuration(200); animator.setRepeatCount(0); animator.setInterpolator(new LinearInterpolator()); animator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() { @Override public void onAnimationUpdate(ValueAnimator animation) { centerX = (Float) animation.getAnimatedValue(); invalidate(); } }); animator.start(); } private void init() { mSwitchPaint = new Paint(); mSwitchPaint.setColor(OFF_BACKGROUND_COLOR); mSwitchPaint.setStrokeWidth(10f); mSwitchPaint.setStrokeCap(Paint.Cap.ROUND); mSwitchPaint.setAntiAlias(true); } @Override protected void onSizeChanged(int w, int h, int oldw, int oldh) { super.onSizeChanged(w, h, oldw, oldh); mRectF = new RectF(getLeft(), getTop(), getRight(), getBottom()); mRadius = h / 2 - BOUND_DOT_GAP; startX = getLeft() + mRadius + BOUND_DOT_GAP / 2; endX = getRight() - mRadius - BOUND_DOT_GAP / 2; centerX = startX; centerY = (getTop() + getBottom()) / 2.0f; } @Override protected void onLayout(boolean changed, int left, int top, int right, int bottom) { super.onLayout(changed, left, top, right, bottom); } @Override protected void onDraw(Canvas canvas) { super.onDraw(canvas); if (isOn) { mSwitchPaint.setColor(ON_BACKGROUND_COLOR); } else { mSwitchPaint.setColor(OFF_BACKGROUND_COLOR); } canvas.drawRoundRect(mRectF, mRadius, mRadius, mSwitchPaint); mSwitchPaint.setColor(SWITCH_DOT_COLOR); canvas.drawCircle(centerX, centerY, mRadius, mSwitchPaint); } @Override public boolean onTouchEvent(MotionEvent event) { int action = event.getAction(); switch (action) { case MotionEvent.ACTION_DOWN: break; case MotionEvent.ACTION_UP: setOn(!isOn); break; case MotionEvent.ACTION_MOVE: { float x = event.getX(); if (x &lt; endX &amp;&amp; x &gt; startX) { centerX = x; invalidate(); } } break; default: break; } return true; }} 4. 源码 源码依然是上传到Github CustomViewDemo 最后 关注「码道长」，了解最前沿的技术知识，抬高自己的天花板。","link":"/2017/11/09/《Android 进阶（四）》 自定义View之仿Emui开关控件/"},{"title":"《Android 进阶（四）》自定义组织机构图-LazyOrgView","text":"LazyOrgView 通过自定义View简单实现组织结构图。在网上搜索并没有发现类似的View，由于项目需要，快速实现一个满足项目需求。另外一种实现方式：Google OrgChart或者其他OrgChart.js。 源码地址 LazyOrgView 添加依赖Gradle 步骤 1. 工程根目录build.gradle 添加如下 12345allprojects { repositories { maven { url &apos;https://jitpack.io&apos; } }} Step 2. 项目build.gradle 添加依赖 1234dependencies { implementation &apos;com.github.onlyloveyd:LazyOrgView:v1.0&apos;} 基本使用 步骤 1. 添加 LazyOrgView 至布局。 12345678910111213&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;FrameLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:tools=&quot;http://schemas.android.com/tools&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; tools:context=&quot;.MainActivity&quot;&gt; &lt;cn.onlyloveyd.lazyorgview.widget.LazyOrgView android:id=&quot;@+id/rv_content&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot;/&gt;&lt;/FrameLayout&gt; 步骤 2. 使用TreeNode构建跟节点以及其他节点，然后使用addChildNode组织节点关系。 123456789101112131415161718192021222324252627282930TreeNode root = new TreeNode(&quot;总经理&quot;);root.isRoot = true;TreeNode A = new TreeNode(&quot;副经理&quot;);TreeNode Aa = new TreeNode(&quot;行政部&quot;);TreeNode Ab = new TreeNode(&quot;财务部&quot;);TreeNode Ac = new TreeNode(&quot;采购部&quot;);TreeNode B = new TreeNode(&quot;副经理&quot;);TreeNode Ba = new TreeNode(&quot;工程部&quot;);TreeNode Bb = new TreeNode(&quot;生产部&quot;);TreeNode C = new TreeNode(&quot;副经理&quot;);TreeNode Ca = new TreeNode(&quot;营销部&quot;);TreeNode Cb = new TreeNode(&quot;方案造价部&quot;);TreeNode Cc = new TreeNode(&quot;售后服务部&quot;);root.addChildNode(A);root.addChildNode(B);root.addChildNode(C);A.addChildNode(Aa);A.addChildNode(Ab);A.addChildNode(Ac);B.addChildNode(Ba);B.addChildNode(Bb);C.addChildNode(Ca);C.addChildNode(Cb); 步骤 3. 给LazyOrgView配置 LazyOrgConfig 以及 rootNode。 1234567lazyOrgView.setRootNode(root);LazyOrgConfig lazyOrgConfig = new LazyOrgConfig();lazyOrgConfig.setLineColor(Color.BLUE).setTextSize(12) .setLineWidth(1) .setTextBgColor(Color.GREEN) .setTextBgRes(R.drawable.rect_shape);lazyOrgView.setLazyOrgConfig(lazyOrgConfig); 基本效果","link":"/2018/08/12/《Android 进阶（四）》自定义组织机构图-LazyOrgView/"},{"title":"《Android应用之路》 Android应用开发资源汇总","text":"简介 个人独立开发Android应用，是一件既简单也复杂的一件事情，不用浪费时间沟通交流，一心码，但是这就代表着你需要了解的知识很全面，你需要指导的工具很犀利~ 视觉效果 ####界面设计 https://dribbble.com/ https://www.uplabs.com/ https://material.io/ http://www.ui.cn/ ####配色 https://color.adobe.com/zh/explore/newest/ https://colordrop.io/ https://www.materialpalette.com/indigo/light-green ####图标库 http://typicons.com/ https://icons8.com/web-app/new-icons/all http://www.iconfont.cn/ https://icomoon.io/ https://material.io/icons/ 开发者助手 ####数据源 聚合数据 Baidu API Store 和风天气 干货集中营 github API 天天数据 当然很多视频网站和资讯网站都有开发API接口供开发者使用，大家可以适当的搜索使用 ####服务 百度地图 高德地图 蒲公英 fir.im Bmob后端云 友盟 七牛云 极光推送 ####完整开源应用示例 从0开始 从开发到上线 知乎日报 新闻段子手 云阅 高仿微信 LookLook Mmaterial Design 极客日报 干货IO","link":"/2017/02/06/《Android应用之路》 Android应用开发资源汇总/"},{"title":"《Android开源库》 Essential介绍（译文）","text":"简介 GreenRobot Essentials为Android和Java项目提供通用的实用工具。 在Android开发的早期，它就已经存在了。整个库很简单，jar包 &lt;100k，在效率和性能上也是独树一帜的。 特性 Essentials是一个通用类的集合，我们发现在许多场合都很有用。 使用要点的主要原因： 在项目中编写较少的代码 专门实现与标准API相比更好的性能 超轻量级：&lt;100k 兼容Android和Java 特征： IO utilities 在IO流（基于字节和字符）和digests（例如MD5和SHA-1）上起到很大的帮助作用。 File utilities 简化了从字符串/字节/对象写入文件或向文件写入字符串/字节/对象。还包括从文件获取哈希和复制文件。 String utilities允许有效分割和连接字符串，hex和MD5创建，以及其他有用的字符串助手。 Better hash functions: ：我们的Murmur3实现提供了优越的散列质量，并且胜过标准的Java散列函数 Specialized Streams: 例如优化的PipedOutputStream替换（基于循环字节缓冲器） Hash set and map for primitive long keys 原始长键的哈希集和映射优于Java集合API的通用版本 Multimaps多映射提供了列表或集合的映射，以简化为单个键存储多个值 Object cache 对象缓存具有强大的配置选项：软/弱/强引用，最大大小和基于时间的到期 Base64实现（从iharder.net捆绑）用于较低版本的Java和Android（包括输入/​​输出流） 集成1. 添加到工程 使用最新版本 1compile &apos;org.greenrobot:essentials:3.0.0-RC1&apos; 或者使用老版本 1compile &apos;de.greenrobot:java-common:2.3.1&apos; 针对Maven 12345&lt;dependency&gt; &lt;groupId&gt;de.greenrobot&lt;/groupId&gt; &lt;artifactId&gt;java-common&lt;/artifactId&gt; &lt;version&gt;2.3.1&lt;/version&gt;&lt;/dependency&gt; 2. 示例代码123456789// Get all bytes from stream and close the stream safelybyte[] bytes = IoUtils.readAllBytesAndClose(inputStream);// Read the contents of an file as a string (use readBytes to get byte[])String contents = FileUtils.readUtf8(file);// How many days until new year&apos;s eve?long time2 = DateUtils.getTimeForDay(2015, 12, 31);int daysToNewYear = DateUtils.getDayDifference(time, time2); 多映射Map（版本v2.2加入） 12345ListMap&lt;String,String&gt; multimap = new ListMap&lt;&gt;();multimap.putElement(&quot;a&quot;, &quot;1&quot;);multimap.putElement(&quot;a&quot;, &quot;2&quot;);multimap.putElement(&quot;a&quot;, &quot;3&quot;);List&lt;String&gt; strings = multimap.get(&quot;a&quot;); //Contains &quot;1&quot;, &quot;2&quot;, and &quot;3&quot; 散列函数实现 java.util.zip.Checksum，所以下面的代码可能看起来很眼熟 123Murmur3A murmur = new Murmur3A();murmur.update(bytes);long hash = murmur.getValue(); 所有散列可以通过多次调用update（…）来逐步计算。 我们的Murmur3A实现更进一步，以非常有效的方式提供原始数据的更新： 123456789101112// reuse the previous instance and start over to calculate a new hashmurmur.reset();murmur.updateLong(42L);// Varargs and arrays are supported natively, too murmur.updateInt(2014, 2015, 2016);murmur.updateUtf8(&quot;And strings, of course&quot;);// Hash for the previous update calls. No conversion to byte[] necessary.hash = murmur.getValue(); 实用程序类是直接的，没有依赖性，所以你应该很好地通过看看他们的源代码来掌握它们。 大多数方法名称应该是自解释的，通常你会在需要的地方找到JavaDocs。","link":"/2017/02/25/《Android开源库》 Essential介绍（译文）/"},{"title":"《Android开源库》 MPAndroidChart Wiki(译文)～Part 6","text":"22. ViewPortHandler ViewPortHandler负责处理图表的视窗。也就是说它负责图表视图中的展示给用户的那部分内容。包括图表位移，缩放级别，图表大小和绘制区域以及当前偏移量。ViewPortHandler允许我们访问以上提到的所有书属性并修改它。 和通过Chart类修改视窗不一样的是，通过ViewPortHandler直接修改可见取悦并不是完全安全的。即使你对API比较熟悉你也需要很小心的使用它。不恰当的使用可能会导致意想不到的结果。然而，ViewPortHandler提供了很多高阶的方法来修改视窗。 22.1 获取实例 可以通过如下方式获取实例： 1ViewPortHandler handler = chart.getViewPortHandler(); 22.2 缩放&amp;位移方法 | 使用 ----------- | ---------- getScaleX() | 返回X轴上的缩放级别 getScaleY() | 返回Y轴上的缩放级别 getTransX() | 返回X轴方向上的位移 getTransY() | 返回Y轴方向上的位移 22.3 图表尺寸&amp;内容方法 | 使用 ---------------- | -------------------- getChartWidth() | 返回图表的宽度 getChartHeight() | 返回图表的高度 getContentRect() | 返回一个RectF对象表示当前的内容区域更多方法请查阅JavaDoc或者学习API 23. FillFormatter FillFormatter接口允许自定义LineDataSet的填充行应该在哪里结束。 所有需要做的都是创建一个新类并实现FillFormatter接口。 使用： 1public float getFillLinePosition(LineDataSet dataSet, LineDataProvider provider) 用于实现自定义逻辑的接口的方法，该自定义逻辑计算单个LineDataSet的填充行的结束点。 创建一个类实现该接口： 1234567891011public class MyCustomFillFormatter implements FillFormatter { @Override public float getFillLinePosition(LineDataSet dataSet, LineDataProvider dataProvider) { float myDesiredFillPosition = ...; // put your logic here... return myDesiredFillPosition; }} 然后把自定义的formatter设置到LineDataSet： 1lineDataSet.setFillFormatter(new MyCustomFillFormatter()); 查看DefaultFillFormatter的实现 24. ProGuard 使用Proguard,需要添加如下配置： 1-keep class com.github.mikephil.charting.** { *; } 如果使用proguard但是不配置以上规则，动画会失效。 Realm.io对应配置： 1-dontwarn io.realm.** 其他ProGuard信息 25. Realm.io数据库集成 请移步官方MPAndroidChart-Realm来了解如何从Realm.io数据库中提取数据填充MPAndroidChart。 具体操作指南请查阅此处 26. 自定义DataSets 从版本v.2.2.0开始，MP AndroidChart允许你创建自定义的DataSets并在图表中使用它们。 26.1 必需操作 创建自定义类（如：CustomDataSet） 继承BaseDataSet&lt; ? extends Entry&gt; 根据需求实现对应的IDataSet接口。如IBarDataSet 实现接口对应的方法并返回你期望的结果 26.2 示例 创建一个BarDataSet供BarChart使用： 123public class CustomBarDataSet extends BaseDataSet&lt;BarEntry&gt; implements IBarDataSet { // implement all by the extended class and interface required methods} 创建CustomBarDataSet后实现所有接口需要实现的方法，然后它就可以像BarDataSet一样在所有的BarChart中使用了。 27. 其他方法27.1 图表内容方法 | 使用 ------------- | ---------------------------------------------- clear() | 清空图表中的所有数据（通过设置数据对象为null实现）。调用invalidate()刷新数据 clearValues() | 清空图表中的数据集，X轴上数据不做修改 isEmpty() | 判断图表中数据是否为空 27.2 好用的Getter方法方法 | 使用 ------------------------------ | --------------------- getData() | 返回图表中的Data对象 getViewPortHandler() | 返回ViewPortHandler对象 getRenderer() | 返回负责绘制图表的DataRender对象 getCenter() | 返回整个图表的中心点. getCenterOffsets() | 返回图表绘制区域的中心点 getPercentOfTotal(float value) | 返回提供的值构成图表内总和的百分比. getYMin() | 返回Y轴最小值 getYMax() | 返回Y轴最大值 getLowestVisibleXIndex() | 返回X轴方向上最小可见索引 getHighestVisibleXIndex() | 返回X轴方向上最大可见索引 27.3 更多Chart类方法方法 | 使用 ----------------------------------------------- | ---------------------------------------------------- saveToGallery(String title) | 将当前图表状态以图片的形式保存到图库。记得添加&quot;WRITE_EXTERNAL_STORAGE&quot;权限. saveToPath(String title, String pathOnSD) | 将当前图表状态以图片的形式保存到指定路径。记得添加&quot;WRITE_EXTERNAL_STORAGE&quot;权限. getChartBitmap() | 将当前图表状态以Bitmap的形式返回. setHardwareAccelerationEnabled(boolean enabled) | 启用／禁用图表绘制硬件加速, 仅针对API级别11+的设备.","link":"/2017/06/25/《Android开源库》 MPAndroidChart Wiki(译文)～Part 6/"},{"title":"《Android开源库》 Realm For Android~ Getting Started（译文）","text":"入门 下载Realm for Android或者在Github realm-java上查看源代码. 原文链接 https://realm.io/docs/java/latest/#getting-started 开发条件 我们目前不支持Android之外的Java。 Android Studio&gt; = 1.5.1 最近版本的Android SDK。 JDK version&gt; = 7。 我们支持所有Android版本自API Level 9（Android 2.3 Gingerbread及以上） 安装 Realm安装为Gradle插件。 将Realm安装为Gradle插件需要两个步骤。 步骤1：将以下类路径依赖项添加到项目级build.gradle文件。 12345678buildscript { repositories { jcenter() } dependencies { classpath &quot;io.realm:realm-gradle-plugin:3.0.0&quot; }} 项目级的build.gradle的位置如下 步骤2：将realm-android插件应用到应用程序级build.gradle文件的顶部。 应用程序级的build.gradle的位置如下 一旦这两个更改完成，只需刷新你的gradle依赖项。 如果你从v0.88之前的版本升级，你可能还需要清洁gradle项目（./gradlew clean）以删除任何遗留的以前的安装。 可以在这里找到两个修改的build.gradle文件的示例： 项目级build.gradle 应用程序级build.gradle 其他构建系统不支持Maven＆Ant构建系统。 如果你希望看到这些构建系统的支持，请表达你对以下问题的兴趣，然后我们会权衡是否需要添加这种支持。 Maven支持 Ant 支持 你的意见将决定我们是否以及何时实现Ant和Maven插件。 从v1.0.0起，不支持Eclipse。 我们建议迁移到Android Studio。 ProGuard ProGuard配置作为Realm库的一部分提供。 这意味着你不需要为Realm配置任何ProGuard规则。 Realm 浏览器 我们提供独立的Realm浏览器，用于读取和编辑Realm数据库 你可以使用菜单项“ Tools &gt; Generate demo database ”生成带有示例数据的测试数据库。 如果你在查你的应用程序的Realm文件上遇到了问题，就去看下StackOverflow答案详细说明。 Realm浏览器可以在Mac App Store上找到，也可以从我们GitHub页面下载。 浏览器目前不能在Windows或Linux上运行。 在这些平台上，你可以使用Stetho-Realm。 Stetho是由Facebook创建的Chrome浏览器的Android调试桥。 API指南 想知道关于类、方法和其他内容，请查阅API指南 示例 看看我们的例子，看看Realm在应用程序中是如何实践。 有关如何运行示例的更多详细信息，请参阅此处。 introExample包含如何使用当前API的简单示例。 gridViewExample是一个简单的应用程序，显示如何使用Realm作为GridView的后台存储。 它还显示了如何使用GSON使用JSON填充数据库，以及如何使用ABI拆分将最终APK的大小最小化。 threadExample是一个简单的应用程序，显示如何在多线程环境中使用Realm。 adapterExample显示了如何使用RealmBaseAdapter和RealmRecyclerViewAdapter来使Realm以优雅的方式与Android ListView和RecyclerView一起工作。 jsonExample说明了如何使用新的Realm JSON功能呢。 encryptionExample显示如何使用加密的Realms。 rxJavaExamples显示了Realm如何与RxJava一起工作。 unitTestExample显示了如何在使用Realm时编写单元测试。","link":"/2017/03/03/《Android开源库》 Realm For Android~ Getting Started（译文）/"},{"title":"《Android开源库》 Realm For Android~ Migrations & Encryption & Working With Android（译文）","text":"迁移（Migrations） 所有数据库都要处理模型改变的情况。Realm 的数据模型用标准 Java 对象来定义，改变Scheme和改变数据RealmObject子类对应的机构一样容易。 如果没有旧 Realm 数据文件存在，那么代码的改变即会反应到相应的 Realm 数据文件改变。但如果已经有旧版本的 Realm 数据文件存在，Realm 会抛出异常提示数据库文件需要迁移。请在相应的 RealmConfiguration 设置 schema 版本和 migration 代码来正确处理并避免该异常抛出。 1234RealmConfiguration config = new RealmConfiguration.Builder() .schemaVersion(2) // Must be bumped when the schema changes .migration(new MyMigration()) // Migration to run instead of throwing an exception .build() 如上示例使得相应的 migration 代码在迁移需要的时候被自动执行。我们提供了相关 API 用来升级已保存的 schema 以及对应之前 schema 的数据。 1234567891011121314151617181920212223242526272829303132333435363738394041// Example migration adding a new classRealmMigration migration = new RealmMigration() { @Override public void migrate(DynamicRealm realm, long oldVersion, long newVersion) { // DynamicRealm exposes an editable schema RealmSchema schema = realm.getSchema(); // Migrate to version 1: Add a new class. // Example: // public Person extends RealmObject { // private String name; // private int age; // // getters and setters left out for brevity // } if (oldVersion == 0) { schema.create(&quot;Person&quot;) .addField(&quot;name&quot;, String.class) .addField(&quot;age&quot;, int.class); oldVersion++; } // Migrate to version 2: Add a primary key + object references // Example: // public Person extends RealmObject { // private String name; // @PrimaryKey // private int age; // private Dog favoriteDog; // private RealmList&lt;Dog&gt; dogs; // // getters and setters left out for brevity // } if (oldVersion == 1) { schema.get(&quot;Person&quot;) .addField(&quot;id&quot;, long.class, FieldAttribute.PRIMARY_KEY) .addRealmObjectField(&quot;favoriteDog&quot;, schema.get(&quot;Dog&quot;)) .addRealmListField(&quot;dogs&quot;, schema.get(&quot;Dog&quot;)); oldVersion++; } }} 请查阅这个数据迁移例子来获取这方面的细节。 如果没有旧 Realm 数据文件存在，那么迁移并不需要，在这种情况下，Realm 会创建一个新的以 .realm 为后缀，基于新的对象模型的数据文件。在开发和调试过程中，假如你需要频繁改变数据模型，并且不介意损失旧数据，你可以直接删除 .realm 文件（这里包含所有的数据！）而不用关心迁移的问题。这在你应用的开发早期阶段非常有用。 1234RealmConfiguration config = new RealmConfiguration.Builder() .deleteRealmIfMigrationNeeded() .build() 加密 请注意我们的许可证的出口合规性部分，因为如果你位于从美国出口限制或禁运的国家，则会限制使用Realm。 Realm 文件可以通过传递一个512位（64字节）的密钥参数给 Realm.getInstance().encryptionKey() 来加密存储在磁盘上。 123456byte[] key = new byte[64];new SecureRandom().nextBytes(key);RealmConfiguration config = new RealmConfiguration.Builder() .encryptionKey(key) .build();Realm realm = Realm.getInstance(config); 这保证了所有永久性存储在磁盘上的数据都是通过标准 AES-256 加密的。每次创建新的 Realm 实例的时候，都需要提供相同的密钥。 参考 examples/encryptionExample。这个例子演示了如何通过 Android KeyStore 来安全地存储密钥。 与 Android 相关 Realm 可以无缝地引入安卓开发。你需要谨记 RealmObject 的线程限制。当你需要跨 activity、service或者 broadcast receiver 传递 Realm 对象的时候，请牢记这一点. 原文地址 https://realm.io/docs/java/latest/#migrations","link":"/2017/03/16/《Android开源库》 Realm For Android~ Migrations & Encryption & Working With Android（译文）/"},{"title":"《Kotlin》 Android Studio3.0 Kotlin工程问题集","text":"问题1: 新建支持Kotlin的Android项目，卡在“Resolve dependency :classpath”解决分析：一般碰到“Resolve dependency :classpath”卡着一动不动的，等一会如果还是没反应，应该就是永远没反应。先重启下Android Studio或者重新gradle sync一下，如果还是不行，看下工程中“gradle-wrapper.properties”中的gradle版本，然后去系统.gradle 目录下看下对应的gradle 是否已经下载OK 我这里是在家目录下的.gradle/wrapper/dists下，可以看到一些Gradle版本，找到你正在使用的版本。进入后可以看到一串很长的文件名，继续进入 如上可以看到一些文件，如果有完整的.zip包和.ok文件就说明对应的gradle版本是下载OK的；如果没有下载完，AS中进行构建的时候，你可以明显的看到目录下有个文件的大小在逐渐增加，这就说明正在执行gradle 版本的下载任务，可以耐心等待下，如果是下载OK的情况下，还是一直卡在“Resolve dependency :classpath”，就是我今天用AS3.0 构建Kotlin项目的时候遇到的问题，你就可以看看你的build.gradle文件中，是否又不常见的dependency。就如Kotlin工程中就是使用到 12345repositories { maven { url \"https://maven.google.com\" }} 这个在墙内是无法访问的。我猜想就是这个导致的，换成aliyun maven或者其他国内可访问的maven后，不会卡住了，关于Android Studio中配置aliyun Maven ,请参考我的另一篇博文。 问题2:“Unable to find method ‘com.android.build.gradle.internal.variant.BaseVariantData.getOutput()Ljava/util/List’”解决办法：kotlin版本调整，之前是1.1.2-3，换成1.1.2-4 1ext.kotlin_version = '1.1.2-4' 问题3:“Declaring custom ‘clean’ task when using the standard Gralde lifecycle plugins is not allowed”解决方法： 把build.gradle中的clean task 无情地注释掉。 123//task clean(type: Delete) {// delete rootProject.buildDir//} 问题4: build.gradle文件中”def outputFile = output.outputFile”报错”Not valid”，如图 出错代码，如下第39行 解决办法：查阅官网：https://developer.android.google.cn/studio/preview/features/new-android-plugin-migration.html#variant_api 修改成如下内容 1234567891011// If you use each() to iterate through the variant objects,// you need to start using all(). That's because each() iterates// through only the objects that already exist during configuration time—// but those object don't exist at configuration time with the new model.// However, all() adapts to the new model by picking up object as they are// added during execution.android.applicationVariants.all { variant -&gt; variant.outputs.all { outputFileName = \"${variant.name}-${variant.versionName}.apk\" }} 参考：https://stackoverflow.com/questions/44239235/android-gradle-3-0-0-alpha2-plugin-cannot-set-the-value-of-read-only-property","link":"/2017/05/21/《Kotlin》 Android Studio3.0 Kotlin工程问题集/"},{"title":"《Kotlin》 Kotlin Android Extensions (译文)","text":"原文链接：http://kotlinlang.org/docs/tutorials/android-plugin.html Kotlin Android Extensions本教程介绍如何使用Kotlin Android Extensions来改进对Android开发的支持。 在本教程中，我们将介绍使用Kotlin Android Extensions插件所需的步骤，增强Android的开发体验。 背景每个Android开发人员都很清楚findViewById()方法。 毫无疑问，这是一个难以阅读与维护，并且存在潜在bug的丑陋代码。 虽然有几个可用的库可以为此问题提供解决方案，但依赖于运行时的库，最让你头疼的是它们需要为每个View添加注释字段。 Kotlin Android Extensions插件允许我们获得与使用这些库后相同的体验，而无需添加任何额外的代码或消耗额外的运行时间。 实质上，下面这段代码时OK的： 1234567891011// Using R.layout.activity_main from the main source setimport kotlinx.android.synthetic.main.activity_main.*class MyActivity : Activity() { override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContentView(R.layout.activity_main) textView.setText(\"Hello, world!\") // Instead of findView(R.id.textView) as TextView }} textView是Activity的扩展属性，并且它的类型和acitvity_main.xml文件中申明的一致。 使用Kotlin Android Extensions配置依赖在这个教程中，我们将使用Gradle作为我们的操作环境，在 IntelliJ IDEA 环境或者Maven下大同小异。更多关于Kotlin的Gradle配置，请查阅Using Gradle. Android Extensions是Kotlin IDEA插件的一部分，你不需要再安装其他的插件。你需要做的就是使用下面的方式在你的项目及build.gradle中启用Android Extensions Gradle插件： 1apply plugin: 'kotlin-android-extensions' 引入生成的属性使用下面的方式，你可以很方便的一键引入特定布局的所有控件的属性： 1import kotlinx.android.synthetic.main.&lt;layout&gt;.* 所以呢，如果我们的布局是activity_main.xml，我们将引入*kotlinx.android.synthetic.main.activity_main. 如果我们想使用声称的View的属性（在适配器类中很好用），我们需要引入*kotlinx.android.synthetic.main.activity_main.view. 一旦我们按照上面的步骤做，我们就可以调用相应的扩展，就是那些在XML文件中的视图之后命名的属性。 例如，对于这个视图： 123456&lt;TextView android:id=\"@+id/hello\" android:layout_width=\"fill_parent\" android:layout_height=\"wrap_content\" android:text=\"Hello World, MyActivity\" /&gt; 然后就会存在一个名为hello 的属性 1activity.hello.setText(\"Hi!\") Android版本Android Extensions 插件支持Android 多渠道版本，假如在你的build.gradle中有一个名为free的版本 1234567android { productFlavors { free { versionName \"1.0-free\" } }} 然后你就可以通过如下方式导入针对free/res/layout/activity_free.xml的所有生成的属性。 1import kotlinx.android.synthetic.free.activity_free.* 内部原理Kotlin Android Extensions 是一个Kotlin编译器插件。它执行下面两个操作： 为每一个Kotlin Activity添加一个隐藏的缓存方法和一个域。这个方法相当之小，基本不会增加APK 的大小。 用方法调用替换每一个属性调用。 那么，这是如何工作的呢？当调用一个生成的属性时，如果接收方时存在于模块源代码中的Kotlin Activity或者Fragment，缓存的方法将会被调用。例如，提供 1234class MyActivity: Activity()fun MyActivity.a() { this.textView.setText(“”)} 一个缓存方法会自动在MyActivity中生成，所有我们可以使用缓存机制。然而在下面这个例子中 123fun Activity.b() { this.textView.setText(“”)} 我们不知道这个方法是否仅在我们的源代码的Activity或普通Java Activity中被调用。 因此，即使上一个示例中的MyActivity实例是接收器，我们也不使用缓存。","link":"/2017/05/18/《Kotlin》 Kotlin Android Extensions (译文)/"},{"title":"《Kotlin》 Getting started with Android and Kotlin (译文)","text":"原文链接http://kotlinlang.org/docs/tutorials/kotlin-android.html 写在前面Kotlin 是一个基于 JVM 的新的编程语言，由 JetBrains 开发。今天凌晨Google I/O 上，Google官方表示了对Kotlin语言的支持。所以决定今天开始入坑，学习Kotlin. Kotlin在Android上的使用入门安装Kotlin插件Kotlin插件从3.0版本开始和Android Studio绑定。如果你使用的是之前的版本，你就需要手动安装Kotlin插件。点击“FIle”-&gt;”Settings”-&gt;”Plugins “-&gt;”Install JetBrains plugin…”, 然后搜索Kotlin并安装。如果你在“Welcome to Android Studio”界面，选择 “Configure“-&gt;”Plugins”-&gt;”Install JetBrains plugin… “,然后搜索Kotlini并安装。安装完成后需要重启IDE。 创建项目开始使用Kotlin进行Android开发是非常容易的。 在本教程中，我们将使用Android Studio进行操作。 如果使用Intellij IDEA开发Android，这个过程几乎是一样的。首先让我们创建一个新的项目。 选择 “Start a new Android Studio project”或者“File”-&gt;”New project”。 以下对话框将引导你完成新项目创建过程。 你需要为项目命名，并选择你安装的Android SDK版本。 大多数选项可以保留其默认值，因此你只需要按几次“Enter”。 命名项目:Android Studio 3.0在上面这个界面上回提供一个启用Kotlin支持的选项。勾选上这个选项你就可以跳过下面的“在项目中配置Kotlin”步骤。 选择Android版本: 选择一个自动生成的Activity: 命名Activity: 在Android Studio3.0中，你可以直接通过菜单选项新建Kotlin Activity,这样的话，你就可以跳过下面“转换Java代码为Kotlin”步骤。低于3.0的版本，需要使用java创建activity，然后用自动转换工具将其转换成 Kotlin。一般来说，开始使用Kotlin的最简单方法是将Java Activity自动转换为Kotlin。 请注意，无论何时，与其通过查阅文档来寻找用Kotlin表单旧的表达式的方式，不如直接先使用Java编写它，然后将Java代码复制粘贴到Kotlin文件中，IntelliJ IDEA（或Android Studio）会建议我们转换，然后就可以自动转换成Kotlin。 转换Java代码为Kotlin打开MainActivity.java文件。然后调用动作将Java文件转换为Kotlin文件。 你可以通过几种方法来实现。 最简单的一个是调用Find Action并开始输入一个动作名称（如下面的截图）。 或者，您可以通过“Code”-&gt;”Convert Java File to Kotlin File”菜单项或者对应的快捷键将Java文件转换为Kotlin。 转换完成后，用Kotlin编写的Activity将出现在你眼前 在项目中配置Kotlin当你开始编辑Kotlin文件时，Android Studio会向显示Kotlin未配置的提示，所以这个时候你需要配置一下。 然后系统提示你输入Kotlin版本。 从安装版本列表中选择最新版本。 配置Kotlin后，应用程序的build.gradle文件应该会被更新一些内容。 现在你可以看到 “apply plugin: ‘kotlin-android’”以及一些依赖项。 最后一件事件就是sync项目。 构建并发布使用Kotlin编写的Android应用程序你现在可以构建应用程序并在模拟器或真机上运行它。 这与Java中的工作方式完全相同。 你可以发布应用程序，并以类似于使用Java编写的Android应用程序的方式进行签名。 Kotlin有一个相当小的运行时文件大小：库大约是859KB（从1.1.2-2开始）。 这意味着Kotlin对.apk文件大小增加了一点。 Kotlin编译器生成字节码，因此Kotlin应用程序与Java编写的应用程序的外观和感觉确实没有差别。","link":"/2017/05/18/《Kotlin》 Getting started with Android and Kotlin (译文)/"},{"title":"《Android开源库》 Realm For Android~ Threading（译文）","text":"线程 其实对于跨线程使用 Realm，你需要知道的事情并不多。关键点是得益于对象和查询的即时更新特性，你不需要担心数据在多线程时的一致性和效率问题。 你可以实时在不同线程中读取和写入 Realm 对象，不用担心其它线程会对同一对象进行操作。你需要在改变对象时使用事务，在另一线程中指向同一对象的数据会被即时更新（更新会在下一次事件循环时进行）。 唯一局限是你不能随意跨线程传递 Realm 对象。如果你在另一线程使用同一对象，请在哪个线程使用查询重新获得该对象。请谨记所有的 Realm 对象都会在不同线程中保持更新——Realm 会在数据改变时通知你。 参考如下实例。 Realm 线程实例 假设我们的应用要展示一个用户列表。我们在一个后台线程中（一个安卓 IntentService）从远端获取新用户并将它们存储到 Realm 中。但后台线程存储新用户时，UI 线程中的数据会被自动更新。UI 线程会通过 RealmChangeListener 得到通知，这时 UI 线程应刷新相应的控件。因为 Realm 的自动更新特性，无需重新查询数据。 12345678910111213141516171819202122232425262728293031323334353637383940414243// in a Fragment or Activity, etc@Overridepublic void onActivityCreated(Bundle savedInstanceState) { // ... boilerplate omitted for brevity realm = Realm.getDefaultInstance(); // get all the customers RealmResults&lt;Customer&gt; customers = realm.where(Customer.class).findAllAsync(); // ... build a list adapter and set it to the ListView/RecyclerView/etc // set up a Realm change listener changeListener = new RealmChangeListener() { @Override public void onChange(RealmResults&lt;Customer&gt; results) { // This is called anytime the Realm database changes on any thread. // Please note, change listeners only work on Looper threads. // For non-looper threads, you manually have to use Realm.waitForChange() instead. listAdapter.notifyDataSetChanged(); // Update the UI } }; // Tell Realm to notify our listener when the customers results // have changed (items added, removed, updated, anything of the sort). customers.addChangeListener(changeListener);}// In a background service, in another threadpublic class PollingService extends IntentService { @Override public void onHandleIntent(Intent intent) { Realm realm = Realm.getDefaultInstance(); try { // go do some network calls/etc and get some data and stuff it into a &apos;json&apos; var String json = customerApi.getCustomers(); realm.beginTransaction(); realm.createObjectFromJson(Customer.class, json); // Save a bunch of new Customer objects realm.commitTransaction(); // At this point, the data in the UI thread is already up to date. // ... } finally { realm.close(); } } // ...} 一旦后台服务添加了新用户，customer 列表会被自动更新，不需要你的任何动作。对于单个的 RealmObject 也是同样。假设你需要管理一个 Realm 对象，只需要在一个线程中更新它的数据，UI 线程会自动得到更新后的数据。如果你需要对数据更新作出回应，只需要添加一个 listener，就像我们在以上代码中所作的一样。 这就是所有啦。 跨线程使用 Realm 请谨记：Realm、RealmObject 和RealmResults 实例都不可以跨线程使用。但是你可以使用异步查询和异步事务来将部分操作放入后台线程进行，待完成时调用线程被通知以获取结果。 当你需要跨线程访问同一部分数据时，只需简单地在该线程重新获取一个 Realm 实例（例如：Realm.getInstance(RealmConfiguration config) 或是其他类似方法），然后通过这个 Realm 实例来查询获得你需要的数据。查询获得的对象会映射到 Realm 中的相同数据，由此方法获得对象在其线程中任何地方都可读写 原文链接 https://realm.io/docs/java/latest/#threading","link":"/2017/03/10/《Android开源库》 Realm For Android~ Threading（译文）/"},{"title":"《LeetCode-0001》 两数之和-TwoSum","text":"https://leetcode-cn.com/problems/two-sum/ 题目给定一个整数数组 nums 和一个目标值 target ，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。 你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。 示例 1234给定 nums = [2, 7, 11, 15], target = 9因为 nums[0] + nums[1] = 2 + 7 = 9所以返回 [0, 1] 思路暴力最简单的一种思路，两层循环，两两相加后与target比较。但是循环的起点不同，第一个元素和后面的每个元素进行比较，第二个元素也是和它之后的元素进行比较，所以外层的循环起点为0，内层的循环起点则是由外层决定，若外层为i，则内层循环起点为i+1，这样也可以保证，不重复利用数组中同样的元素。 1234567891011121314class Solution { public int[] twoSum(int[] nums, int target) { int[] result = new int[2]; for (int i = 0; i &lt; nums.length; i++) { for (int j = i + 1; j &lt; nums.length; j++) { if (nums[i] + nums[j] == target) { result[0] = i; result[1] = j; } } } return result; }} 哈希表暴力方法之所以要循环两次，是因为我们需要找两个数的下标，采用哈希表的方法，在循环过程中存储下标，可以省去嵌套一次循环，但是找结果的方式与暴力方式不太一样。 12345678910111213class Solution { public int[] twoSum(int[] nums, int target) { Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;(); for (int i = 0; i &lt; nums.length; i++) { int complement = target - nums[i]; if (map.containsKey(complement)) { return new int[] { map.get(complement), i }; } map.put(nums[i], i); } throw new IllegalArgumentException(\"No two sum solution\"); }} 上面的暴力方法，是从前往后找另外一半，找到立刻返回，比如 1int nums[] = new int[]{2, 7, 11, 15}; 若target目标值为17，执行过程： i,j 计算结果 是否匹配 0,1 9 NO 0,2 13 NO 0,3 17 YES 若是用哈希表的方式，可以理解为从当前循环点往前找另外一半，利用的是2+3=5，3+2=5，加法的交换律，不管从前往后还是从后往前，都是OK的。 执行过程： i 是否匹配 单次循环结束后map 0 NO (2, 0) 1 NO (2, 0) , (7,1) 2 NO (2,0) , (7,1) , (11,3) 3 YES 总结 某些场景下，暴力方式可能速度更快，但是第二种方式整体时间复杂度低。 第二种采用HashMap 的方式，当然也可以采用其他存储数值和下标的式。","link":"/2019/05/26/《LeetCode-0001》 两数之和-TwoSum/"},{"title":"《Kotlin》 Kotlin For Gank.io (干货集中营Kotlin实现)","text":"介绍Kotlin，现在如火如荼，所以花了一点时间把之前的项目用Kotlin重构一下 原项目地址：https://github.com/onlyloveyd/GankIOClient对应Kotlin版：https://github.com/onlyloveyd/GankIOWithKotlin 干货数据源应用中的所有干货数据均来自干货集中营。 App设计色调：远州鼠、落栗、苏芳、石竹、枯草、柳煤竹茶、锖青磁、鸠羽紫八种淡雅的颜色，分别对应不同的干货数据。布局：简约风格，极简主义，去繁就简。排版：最简单的Toolbar + RecyclerView UI设计 黑白灰 圆角 材料设计 代码设计 Retrofit+RxJava 的组合获取网络数据; FlycoTabLayout作为主界面结构，配合Fragment，实现“每日干货”，“分类数据”，“妹纸图片”和关于四个界面; BGARefreshLayout配合RecyclerView和自定义多类型Item结构实现干货数据的展示 MaterialAbout作为“关于”界面的基础 Glide作为图片加载框架 RxJava+Retrofit配合fir.im的接口实现版本更新功能 Share功能全部采用系统自带，基本可以满足需求 ButterKnife注解库 Gson作为json数据解析库 依赖库 Glide RxAndroid RxJava Retrofit okhttp3 Gson ButterKnife BGARefreshLayout-Android FlycoTabLayout MaterialAbout 效果","link":"/2017/05/20/《Kotlin》 Kotlin For Gank.io (干货集中营Kotlin实现)/"},{"title":"《LeetCode-0002》 两数相加-Add Two Numbers","text":"https://leetcode-cn.com/problems/add-two-numbers/ 题目给出两个 非空 的链表用来表示两个非负的整数。其中，它们各自的位数是按照 逆序 的方式存储的，并且它们的每个节点只能存储 一位 数字。 如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。 您可以假设除了数字 0 之外，这两个数都不会以 0 开头。 示例 123输入：(2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)输出：7 -&gt; 0 -&gt; 8原因：342 + 465 = 807 思路题目中加粗关键字注意下： 非空 逆序 一位 解释：链表从左往右依次是所待变数字的低位到高位， 2 -&gt; 4 -&gt; 3 代表342， 5 -&gt; 6 -&gt; 4 代表465，所以没有必要将链表转成数字再进行相加，也没法那样做，应为如果链表相当之长，会超过整形的范围，所以就从低位往高位挨个算就行了。 针对单次计算x+y=zx+y=zx+y=z，只需要考虑是否向前进位的问题即可。 第一次提交1234567891011121314151617181920212223242526272829303132333435363738/** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode(int x) { val = x; } * } */class Solution { public ListNode addTwoNumbers(ListNode l1, ListNode l2) { ListNode result = new ListNode(0); ListNode current1 = l1, current2 = l2, currentResult = result; int carry = 0; while (current1 != null &amp;&amp; current2 != null) { int val = (current1.val + current2.val + carry) % 10; currentResult.next = new ListNode(val); carry = (current1.val + current2.val + carry) / 10; current1 = current1.next; current2 = current2.next; currentResult = currentResult.next; } while (current1 != null) { int val = (current1.val + carry) % 10; currentResult.next = new ListNode(val); carry = (current1.val + carry) / 10; current1 = current1.next; currentResult = currentResult.next; } while (current2 != null) { int val = (current2.val + carry) % 10; currentResult.next = new ListNode(val); carry = (current2.val + carry) / 10; current2 = current2.next; currentResult = currentResult.next; } return result.next; }} 第一次提交未通过 测试用例 我的结果 预期结果 ［5］,［5］ ［0］ ［0，1］ 忽略了上述这种，结果位数比加数位数多且存在进位的情况 第二次提交1234567891011121314151617181920212223242526272829303132333435363738394041/** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode(int x) { val = x; } * } */class Solution { public ListNode addTwoNumbers(ListNode l1, ListNode l2) { ListNode result = new ListNode(0); ListNode current1 = l1, current2 = l2, currentResult = result; int carry = 0; while (current1 != null &amp;&amp; current2 != null) { int val = (current1.val + current2.val + carry) % 10; currentResult.next = new ListNode(val); carry = (current1.val + current2.val + carry) / 10; current1 = current1.next; current2 = current2.next; currentResult = currentResult.next; } while (current1 != null) { int val = (current1.val + carry) % 10; currentResult.next = new ListNode(val); carry = (current1.val + carry) / 10; current1 = current1.next; currentResult = currentResult.next; } while (current2 != null) { int val = (current2.val + carry) % 10; currentResult.next = new ListNode(val); carry = (current2.val + carry) / 10; current2 = current2.next; currentResult = currentResult.next; } if(carry!=0) { currentResult.next = new ListNode(carry); } return result.next; }} 总结 充足的测试用例很重要; 编写代码的时候，边界条件，特殊情况一定得考虑充分。","link":"/2019/05/26/《LeetCode-0002》 两数相加-Add Two Numbers/"},{"title":"《LeetCode-0003》 无重复字符的最长子串-Longest Substring Without Repeating Characters","text":"https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/ 题目给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。 示例 1: 123输入: \"abcabcbb\"输出: 3 解释: 因为无重复字符的最长子串是 \"abc\"，所以其长度为 3。 示例 2: 123输入: \"bbbbb\"输出: 1解释: 因为无重复字符的最长子串是 \"b\"，所以其长度为 1。 示例 3: 1234输入: \"pwwkew\"输出: 3解释: 因为无重复字符的最长子串是 \"wke\"，所以其长度为 3。 请注意，你的答案必须是 子串 的长度，\"pwke\" 是一个子序列，不是子串。 思路关键点： 无重复字符 最长子串 个人解题思路，最长无重复字符子串必然会有一个起点，这个起点我们通过遍历字符串依次从字串首位到末尾，终点我们通过比较依次添加第i位后字符判断当前子串是否存在重复字符来判断。用一个容器来存储当前正在考察的子串，使用TreeSet来存储分析来每个无重复字符的子串长度，主要是TreeSet可以帮我排序。 解题第一次提交123456789101112131415161718class Solution { public int lengthOfLongestSubstring(String s) { TreeSet&lt;Integer&gt; tempRes = new TreeSet&lt;&gt;(); Stack&lt;Character&gt; result = new Stack&lt;&gt;(); char[] inputs = s.toCharArray(); for (int i = 0; i &lt; inputs.length; i++) { char current = inputs[i]; if (result.contains(current)) { tempRes.add(result.size()); result.clear(); } result.push(current); } tempRes.add(result.size()); tempRes.comparator(); return tempRes.last(); }} 解题错误：测试用例”dvdf”第一次提交，我采用堆栈存储当前正在考察的子串，依次添加字符，若出现与堆栈相同的字符，停止添加字符，保存当前堆栈长度，清空堆栈。然后从当前终点开始寻找下一个子串。这个思路考虑不周全，是有问题的。出现重复字符时，不能清空堆栈并且循环的下一个点应该从当前起点的下一个字符开始。以测试用例“dvdf”为例子，看看问题处在哪里 i 堆栈 长度 push(‘d’) 0 {d} 1 push(‘v’) 1 {d, v} 2 push(‘d’) 出现重复字符串，保存当前长度2，清空堆栈 push(‘d’) 2 {d} 1 push(‘f’) 3 {d,f} 2 循环结束，保存堆栈长度 第二次提交总结第一次提交的问题，重新提交。 1234567891011121314151617181920class Solution { public int lengthOfLongestSubstring(String s) { TreeSet&lt;Integer&gt; tempRes = new TreeSet&lt;&gt;(); Queue&lt;Character&gt; result = new LinkedList&lt;&gt;(); char[] inputs = s.toCharArray(); for (int i = 0; i &lt; inputs.length; i++) { char current = inputs[i]; if (result.contains(current)) { tempRes.add(result.size()); result.remove(); i--; } else { result.add(current); } } tempRes.add(result.size()); tempRes.comparator(); return tempRes.last(); }} 第二次提交，我把存储子串的数据结构改成来队列，这样，当出现重复子串时，可以快速的移除队头，通过索引减1的方式，来保证到下一个字符时，队列中不会有重复字符。这里有个可优化的点，直接找到当前重复的字符在队列中的位置，然后直接处理。同样是以第一次提交报错的测试用例，看看执行步骤： i 队列 长度 add(‘d’) 0 {d} 1 add(‘v’) 1 {d, v} 2 add(‘d’) 出现重复字符串，保存当前长度2，移除队头，–i add(‘d’) 2 {v, d} 2 add(‘f’) 3 {v,d,f} 3 循环结束，保存堆栈长度 第三次提交优化后的算法，采用动态规划的方式设f(i)是从左到右在第i个位置上时 当前最长不重复子串的长度则分两种情况：(1)第i位上的字母在左侧从未出现 f(i)=f(i-1)+1(2)在左侧出现过，此时计算上一次该字母出现位置和i之间的距离 gap第一种：gap&lt;=f(i-1) 时 f(i)=gap，此时上一次出现的位置在上一个最长不重复子串内部第二种：gap&gt;f(i-1) 时 f(i)=f(i-1)+1 1234567891011121314151617181920212223242526272829class Solution { public int lengthOfLongestSubstring(String s) { if (s.isEmpty()) { return 0; } int[] position = new int[256]; for (int i = 0; i &lt; position.length; i++) { position[i] = -1; } int max = 0; int cur = 0; for (int i = 0; i &lt; s.length(); i++) { int pos = s.charAt(i); if (position[pos] &lt; 0) { cur += 1; } else { int gap = i - position[pos]; if (cur &gt;= gap) { cur = gap; } else { cur += 1; } } position[pos] = i; max = Math.max(max, cur); } return max; }} 以 “pwwkew” 为例子，执行步骤： i cur max gap 0 1 1 1 2 2 2 1 2 1 3 2 2 4 3 3 5 3 3 3 总结 合适的数据结构事半功倍 针对字符串操作的题目，边界和特殊情况一定要多考虑。","link":"/2019/06/01/《LeetCode-0003》 无重复字符的最长子串-Longest Substring Without Repeating Characters/"},{"title":"《LeetCode-0004》 寻找两个有序数组的中位数-Median of Two Sorted Arrays","text":"https://leetcode-cn.com/problems/median-of-two-sorted-arrays/ 题目给定两个大小为 m 和 n 的有序数组nums1和 nums2。 请你找出这两个有序数组的中位数，并且要求算法的时间复杂度为 O(log(m + n))。 你可以假设 nums1 和 nums2 不会同时为空。 示例 1: 1234nums1 = [1, 3]nums2 = [2]则中位数是 2.0 示例 2: 1234nums1 = [1, 2]nums2 = [3, 4]则中位数是 (2 + 3)/2 = 2.5 概念 中位数的概念：对于有限的数集，可以通过把所有观察值高低排序后找出正中间的一个作为中位数。如果观察值有偶数个，通常取最中间的两个数值的平均数作为中位数。 复杂度 log(m+n)，参考文章：https://github.com/xitu/gold-miner/blob/master/TODO/what-does-the-time-complexity-o-log-n-actually-mean.md 思路 两个有序数组 中位数 复杂度O(log(m + n)) 解题第一次提交臭不要脸的提交。本着试一试的态度提交。这个答案显然不符合负责度的要求。竟然是通过。 123456789101112131415161718192021class Solution { public double findMedianSortedArrays(int[] nums1, int[] nums2) { List&lt;Integer&gt; nums_a = new ArrayList&lt;&gt;(); List&lt;Integer&gt; nums_b = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; nums1.length; i++) { nums_a.add(nums1[i]); } for (int i = 0; i &lt; nums2.length; i++) { nums_b.add(nums2[i]); } nums_a.addAll(nums_b); Collections.sort(nums_a); if (nums_a.size() % 2 == 0) { int mid = nums_a.size() / 2; return (nums_a.get(mid) + nums_a.get(mid - 1)) / 2.0f; } else { int mid = (nums_a.size() - 1) / 2; return nums_a.get(mid); } }} 第二次提交关于这段代码，看详细题解，得多看几遍。https://leetcode-cn.com/problems/median-of-two-sorted-arrays/solution/4-xun-zhao-liang-ge-you-xu-shu-zu-de-zhong-wei-shu/ 12345678910111213141516171819202122232425262728class Solution { public double findMedianSortedArrays(int[] nums1, int[] nums2) { int n = nums1.length; int m = nums2.length; if (n &gt; m) { return findMedianSortedArrays(nums2, nums1); } int L1 = 0, L2 = 0, R1 = 0, R2 = 0, c1, c2, lo = 0, hi = 2 * n; while (lo &lt;= hi) { c1 = (lo + hi) / 2; c2 = m + n - c1; L1 = (c1 == 0) ? Integer.MIN_VALUE : nums1[(c1 - 1) / 2]; //map to original element R1 = (c1 == 2 * n) ? Integer.MAX_VALUE : nums1[c1 / 2]; L2 = (c2 == 0) ? Integer.MIN_VALUE : nums2[(c2 - 1) / 2]; R2 = (c2 == 2 * m) ? Integer.MAX_VALUE : nums2[c2 / 2]; if (L1 &gt; R2) { hi = c1 - 1; } else if (L2 &gt; R1) { lo = c1 + 1; } else { break; } } return (Math.max(L1, L2) + Math.min(R1, R2)) / 2.0; }} 总结 思考未果可看题解，前提是必须先思考 概念的深入理解很重要","link":"/2019/06/10/《LeetCode-0004》 寻找两个有序数组的中位数-Median of Two Sorted Arrays/"},{"title":"《Linux》CentOS7.3 安装MySql","text":"前言 最近，腾讯云，做活动，购买了一台低配的服务器作为玩具，安装MySql. 操作下载mysql的repo源 $ wget http://repo.mysql.com/mysql-community-release-el7-5.noarch.rpm 安装mysql-community-release-el7-5.noarch.rpm包 $ sudo rpm -ivh mysql-community-release-el7-5.noarch.rpm 安装mysql $ sudo yum install mysql-server 根据提示安装就可以了,不过安装完成后没有密码,需要重置密码 修改owner $ sudo chown -R root:root /var/lib/mysql 重启mysql服务 $ service mysqld restart 登录重置密码： $ mysql -u root //直接回车进入mysql控制台mysql &gt; use mysql;mysql &gt; update user set password=password(‘123456’) where user=’root’;mysql &gt; exit; 配置云服务器安全组，打开3306端口配置数据库可远程连接数据库授权 $ mysql -u root //直接回车进入mysql控制台mysql &gt; use mysql;mysql&gt;GRANT ALL PRIVILEGES ON . TO ‘root’@’%’ IDENTIFIED BY ‘123456’ WITH GRANT OPTION; 远程连接数据库的时候需要输入用户名和密码 用户名：root 密码:123456 指点ip:%代表所有Ip,此处也可以输入Ip来指定Ip","link":"/2018/03/07/《Linux》CentOS7.3 安装MySql/"},{"title":"《Linux》CentOS常用命令","text":"添加用户12useradd -d /home/yidong -m yidongpasswd yidong Oracel启动停止数据库启动： 1234su - oracle sqlplus \"/as sysdba\"startupshutdown immediate; 启动监听 ： 123lsnrctl startlsnrctl statuslsnrctl stop 挂载1mount -o loop XXXX XXX 后台运行1./XXX &amp; 后台运行 删除操作12rm -rf XXX 删除文件夹rm -rf * 删除当前目录下的所有文件 包括文件夹 进程查询1ps -ef | grep cp 所有CP操作 类似的其他命令也是一样 也可以查看使用某个文件夹的进程 端口情况查看1netstat -lnp|grep 8080","link":"/2017/09/27/《Linux》CentOS常用命令/"},{"title":"《微信小程序》Hello 微信小程序","text":"简介微信小程序，最近声音比较大，开始慢慢学习一下这个小东西，从安装开发工具开始吧，不会JS，学起来会不会很吃力呢？ 注册账号 参考官方网站 开发工具 1.微信Web开发工具 2.官方下载地址,针对自己不同的电脑下载不同的版本使用吧 3.打开IDE（不知道这个轻量级的算不算IDE），快速开发 4.没有AppID的不填写，勾选“在当前目录中创建quick start项目”直接创建项目就可以看到”Hello World” APP了 Hello WeChat App 1.初始工程代码结构 2.左侧菜单分为“编辑”，“调试”，“项目”,”编译“和“关闭””五个菜单 3.中间主界面分为预览界面，文件结构界面和编辑界面 4.执行编译后，小程序方可运行，编译错误会在顶部提示并且可以在控制台看到明显的报错信息，应该和网页的调试方式项目（本人没开发过网页，汗颜） 实际效果","link":"/2016/12/12/《微信小程序》Hello 微信小程序/"},{"title":"《微信小程序》微信小程序之头条新闻","text":"简介上一篇文章，主要是介绍下微信小程序的开发环境安装和微信组件什么的一些基础的开发内容，所以最近一直在业余找练手的机会。由于之前没有接触过JS，自己学习起来还算是比较的吃力，一点一点的来吧！要持久。 先看下效果： 代码已经开源： 简易新闻 实现思路 数据全部是采用的本地数据，图片也是本地图片，因为苦逼的个人开发者，无法认证； toolbar四个现象：新闻，笑话，历史上的今天和主页，集中主页采用的是默认的页面，添加自己的一些内容； 数据绑定，列表渲染，条件渲染和事件的使用； 使用一些基础的View和text，部分API的使用； 代码结构 目录 用途 images 存放本地图片 pages 存放页面，history历史上的今天，index主页，joke话，news新闻 utils 工具包 app.js 小程序逻辑 app.json 小程序公共设置 app.wxss 小程序公共样式表 代码内容，主要看下配置app.json 配置项列表123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354{ \"pages\": [ \"pages/news/news\", \"pages/joke/joke\", \"pages/history/history\", \"pages/index/index\" ], \"window\": { \"navigationBarBackgroundColor\": \"#f85959\", \"navigationBarTextStyle\": \"white\", \"navigationBarTitleText\": \"微 看\", \"backgroundColor\": \"#FFFFFF\", \"backgroundTextStyle\": \"dark\", \"enablePullDownRefresh\": true }, \"tabBar\": { \"color\": \"#626567\", \"selectedColor\": \"#f85959\", \"backgroundColor\": \"#FBFBFB\", \"borderStyle\": \"white\", \"position\": \"bottom\", \"list\": [ { \"pagePath\": \"pages/news/news\", \"text\": \"新闻\", \"iconPath\": \"images/discovery.png\", \"selectedIconPath\": \"images/discovery_focus.png\" }, { \"pagePath\": \"pages/joke/joke\", \"text\": \"笑话\", \"iconPath\": \"images/ring.png\", \"selectedIconPath\": \"images/ring_focus.png\" }, { \"pagePath\": \"pages/history/history\", \"text\": \"历史\", \"iconPath\": \"images/chat.png\", \"selectedIconPath\": \"images/chat_focus.png\" }, { \"pagePath\": \"pages/index/index\", \"text\": \"主页\", \"iconPath\": \"images/index.png\", \"selectedIconPath\": \"images/index_focus.png\" } ] }, \"networkTimeout\": { \"request\": 10000, \"downloadFile\": 10000 }, \"debug\": true} 属性 类型 必填 描述 pages String Array 是 设置页面路径 window Object 否 设置默认页面的窗口现 tabBar Object 否 设置底部 tab 的现 networkTimeout Object 否 设置网络超时时间 debug Boolean 否 设置是否开启 debug模式 具体配置使用方法请参考官网： https://mp.weixin.qq.com/debug/wxadoc/dev/framework/config.html?t=201715","link":"/2017/01/05/《微信小程序》微信小程序之头条新闻/"},{"title":"内网环境下安装部署Docker","text":"前言大部分公司都有属于自己的内网环境，大部分的集成开发环境也是在内网下部署。最近面临同样的需求，内网CentOS部署GitLab 和 Nexus。 思路首先确定思路，毫无疑问使用Docker是最好的选择，我只用解决Docker的安装问题即可，然后使用Gitlab和Nexus的镜像即可解决问题，后期的延展性也比逐个安装好。 针对Docker的安装，有如下策略 相同CentOS版本的外网服务器，使用yum –downloadonly命令下载create repo和docker安装的依赖包，然后建立本地源，安装Docker，但是公司并没有CentOS版本完全一致的内外网服务器，所以此方案暂时搁浅； 利用已经安装好Docker的外网服务器，制作镜像文件，重装内网系统，这个比较费时，暂时不考虑； 利用一个可同时访问内外网的电脑做代理服务器，实现内网服务器的暂时外网联通，安装完成后，关闭代理服务器。 综上，我优先采用的是方案3。存在一定的安全风险，但是应该问题不大。 需求 CCProxy 一台连接内外网的电脑（我使用个人办公电脑） 操作方法简单配置一下CCProxy，参考官方操作手册，相对简单。CentOS服务器配置全局代理配置 端口和IP注意替换成自己代理服务器的端口和IP 123456vi /etc/profilehttp_proxy=http://yourproxy:808/ftp_proxy=http://yourproxy:808/export http_proxyexport ftp_proxy yum代理配置123vi /etc/yum.confproxy=http://yourproxy:808/ 若有其他配置也可以参照上面进行配置测试1curl -k https://www.baidu.com Docker安装参考前文","link":"/2018/06/19/内网环境下安装部署Docker/"},{"title":"《Android Framework 之路》 N版本 Framework Camera的一些改动","text":"前言Android N版本最近发布，Nougat是否好吃，不得而知，慢慢看下~ 感谢AndroidXref这个网站，给开发者提供了大量的便捷~以后学习Android就靠它了。 N版本上Framework关于Camera的一些改动CameraServer N版本之前，CameraService是运行在MediaServer下的，这样存在一定的问题，因为MediaServer下同时还运行这其他的多媒体内容 M版本 /frameworks/av/media/mediaserver/main_mediaserver.cpp 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100int main(int argc __unused, char** argv){ signal(SIGPIPE, SIG_IGN); char value[PROPERTY_VALUE_MAX]; bool doLog = (property_get(\"ro.test_harness\", value, \"0\") &gt; 0) &amp;&amp; (atoi(value) == 1); pid_t childPid; // FIXME The advantage of making the process containing media.log service the parent process of // the process that contains all the other real services, is that it allows us to collect more // detailed information such as signal numbers, stop and continue, resource usage, etc. // But it is also more complex. Consider replacing this by independent processes, and using // binder on death notification instead. if (doLog &amp;&amp; (childPid = fork()) != 0) { // media.log service //prctl(PR_SET_NAME, (unsigned long) \"media.log\", 0, 0, 0); // unfortunately ps ignores PR_SET_NAME for the main thread, so use this ugly hack strcpy(argv[0], \"media.log\"); sp&lt;ProcessState&gt; proc(ProcessState::self()); MediaLogService::instantiate(); ProcessState::self()-&gt;startThreadPool(); for (;;) { siginfo_t info; int ret = waitid(P_PID, childPid, &amp;info, WEXITED | WSTOPPED | WCONTINUED); if (ret == EINTR) { continue; } if (ret &lt; 0) { break; } char buffer[32]; const char *code; switch (info.si_code) { case CLD_EXITED: code = \"CLD_EXITED\"; break; case CLD_KILLED: code = \"CLD_KILLED\"; break; case CLD_DUMPED: code = \"CLD_DUMPED\"; break; case CLD_STOPPED: code = \"CLD_STOPPED\"; break; case CLD_TRAPPED: code = \"CLD_TRAPPED\"; break; case CLD_CONTINUED: code = \"CLD_CONTINUED\"; break; default: snprintf(buffer, sizeof(buffer), \"unknown (%d)\", info.si_code); code = buffer; break; } struct rusage usage; getrusage(RUSAGE_CHILDREN, &amp;usage); ALOG(LOG_ERROR, \"media.log\", \"pid %d status %d code %s user %ld.%03lds sys %ld.%03lds\", info.si_pid, info.si_status, code, usage.ru_utime.tv_sec, usage.ru_utime.tv_usec / 1000, usage.ru_stime.tv_sec, usage.ru_stime.tv_usec / 1000); sp&lt;IServiceManager&gt; sm = defaultServiceManager(); sp&lt;IBinder&gt; binder = sm-&gt;getService(String16(\"media.log\")); if (binder != 0) { Vector&lt;String16&gt; args; binder-&gt;dump(-1, args); } switch (info.si_code) { case CLD_EXITED: case CLD_KILLED: case CLD_DUMPED: { ALOG(LOG_INFO, \"media.log\", \"exiting\"); _exit(0); // not reached } default: break; } } } else { // all other services if (doLog) { prctl(PR_SET_PDEATHSIG, SIGKILL); // if parent media.log dies before me, kill me also setpgid(0, 0); // but if I die first, don't kill my parent } InitializeIcuOrDie(); sp&lt;ProcessState&gt; proc(ProcessState::self()); sp&lt;IServiceManager&gt; sm = defaultServiceManager(); ALOGI(\"ServiceManager: %p\", sm.get()); AudioFlinger::instantiate(); MediaPlayerService::instantiate(); ResourceManagerService::instantiate(); CameraService::instantiate(); AudioPolicyService::instantiate(); SoundTriggerHwService::instantiate(); RadioService::instantiate(); registerExtensions(); ProcessState::self()-&gt;startThreadPool(); IPCThreadState::self()-&gt;joinThreadPool(); }} 可以看到AudioFlinger，MediaPlayerService, ResourceManagerService,CameraService,AudioPolicyService,SoundTriggerHwService,RadioService等都是运行在这个进程下面的，这样就存在一个问题，假如说其他任何一个服务因为某些原因挂掉了，整个MediaServer将会重启，而这个重启的过程中，倘若相机正在操作，就会出现相机突然挂掉的问题。 N版本 /frameworks/av/media/mediaserver/main_mediaserver.cpp 1234567891011121314int main(int argc __unused, char **argv __unused){ signal(SIGPIPE, SIG_IGN); sp&lt;ProcessState&gt; proc(ProcessState::self()); sp&lt;IServiceManager&gt; sm(defaultServiceManager()); ALOGI(\"ServiceManager: %p\", sm.get()); InitializeIcuOrDie(); MediaPlayerService::instantiate(); ResourceManagerService::instantiate(); registerExtensions(); ProcessState::self()-&gt;startThreadPool(); IPCThreadState::self()-&gt;joinThreadPool();} 有没有觉得少了很多，不仅CameraService被抽离出去了，还有一些内容好像也被抽离出去了。在N版本的工程中多出来一个文件夹/frameworks/av/camera/cameraserver/说明CameraServer是独立于MediaServer的单独的进程，执行PS操作你讲看到独立的Camera进程。 12345678910111213141516171819#define LOG_TAG \"cameraserver\"//#define LOG_NDEBUG 0// from LOCAL_C_INCLUDES#include \"CameraService.h\"using namespace android;int main(int argc __unused, char** argv __unused){ signal(SIGPIPE, SIG_IGN); sp&lt;ProcessState&gt; proc(ProcessState::self()); sp&lt;IServiceManager&gt; sm = defaultServiceManager(); ALOGI(\"ServiceManager: %p\", sm.get()); CameraService::instantiate(); ProcessState::self()-&gt;startThreadPool(); IPCThreadState::self()-&gt;joinThreadPool();} 初始化的过程并没有变化，只是单纯的将它独立出来而已。那么问题来了，CameraService何时启动？看到cameraserver.rc文件， 123456service cameraserver /system/bin/cameraserver class main user cameraserver group audio camera drmrpc inet media mediadrm net_bt net_bt_admin net_bw_acct ioprio rt 4 writepid /dev/cpuset/foreground/tasks 也就是说只要加载了cameraserver.rc文件，服务就开始启动了，就会往main_cameraserer.cpp的入口函数中执行，因为mk文件中定义了这个模块为cameraserver 12345678910111213141516171819202122LOCAL_PATH:= $(call my-dir)include $(CLEAR_VARS)LOCAL_SRC_FILES:= \\ main_cameraserver.cpp//源文件LOCAL_SHARED_LIBRARIES := \\//依赖库 libcameraservice \\ libcutils \\ libutils \\ libbinder \\ libcamera_clientLOCAL_MODULE:= cameraserver//模块名LOCAL_32_BIT_ONLY := true//只支持32位LOCAL_CFLAGS += -Wall -Wextra -Werror -Wno-unused-parameter//一些编译条件，N版本在编译这一块也作出了很大的改动，有机会再研究下LOCAL_INIT_RC := cameraserver.rcinclude $(BUILD_EXECUTABLE)//执行文件 寻找，谁调用的camearserver.rc ???首先我们要看这个文件编译出来之后放在手机的什么位置/build/core/base_rules.mk 1234567891011121314151617# Rule to install the module&apos;s companion init.rc.my_init_rc := $(LOCAL_INIT_RC_$(my_32_64_bit_suffix))my_init_rc_src :=my_init_rc_installed :=ifndef my_init_rcmy_init_rc := $(LOCAL_INIT_RC)# Make sure we don&apos;t define the rule twice in multilib module.LOCAL_INIT_RC :=endififdef my_init_rcmy_init_rc_src := $(LOCAL_PATH)/$(my_init_rc)my_init_rc_installed := $(TARGET_OUT$(partition_tag)_ETC)/init/$(notdir $(my_init_rc_src))$(my_init_rc_installed) : $(my_init_rc_src) | $(ACP) @echo &quot;Install: $@&quot; $(copy-file-to-new-target)$(my_register_name) : $(my_init_rc_installed) 大致可以看出一些端倪，应该是放在xxx/etc/init目录下，这个xxx根据什么看判断，partition_tag变量 1234567891011121314ifdef LOCAL_IS_HOST_MODULE partition_tag :=elseifeq (true,$(LOCAL_PROPRIETARY_MODULE)) partition_tag := _VENDORelse ifeq (true,$(LOCAL_OEM_MODULE)) partition_tag := _OEMelse ifeq (true,$(LOCAL_ODM_MODULE)) partition_tag := _ODMelse # The definition of should-install-to-system will be different depending # on which goal (e.g., sdk or just droid) is being built. partition_tag := $(if $(call should-install-to-system,$(my_module_tags)),,_DATA)endif cameraserver应该是系统所有的，不是oem或者odm特有，存放在system/etc/init目录下。接下面看看这个文件/system/core/init/readme.txt 12345678910111213One may specify paths in the mount_all command line to have it import.rc files at the specified paths instead of the default ones listed above.This is primarily for supporting factory mode and other non-standard bootmodes. The three default paths should be used for the normal boot process.The intention of these directories is as follows 1) /system/etc/init/ is for core system items such as SurfaceFlinger, MediaService, and logcatd. 2) /vendor/etc/init/ is for SoC vendor items such as actions or daemons needed for core SoC functionality. 3) /odm/etc/init/ is for device manufacturer items such as actions or daemons needed for motion sensor or other peripheral functionality. 显然是在执行“mount_all“的时候，CameraServer启动 ~ ，找到启动的位置，这一点和之前的版本是有很大差别的。 AIDLN版本上对于Camera的一些接口采用了Aidl的文件格式frameworks/av/camera/aidl/android/hardware/ 其他模块想要访问这些接口，需要include libcamera_client模块才行 mk文件中有说明。","link":"/2016/09/13/《Android Framework 之路》 N版本 Framework Camera的一些改动/"},{"title":"《Android 基础（三十一）》 ObjectAnimator","text":"简介 ObjectAnimator，是ValueAnimator的子类，支持利用目标视图的属性来实现动画效果。构造ObjectAnimator的时候，将会提取对应的参数来定义动画对象和对象属性。合适的get/set方法是视图实现属性动画的内部机理，动画过程中，系统将通过get/set方法来实现效果，也就是根据一定的规律来为View设置属性。 Animators可以用过资源文件或者是代码定义，当使用资源文件创建的时候，若使用PropertyValuesHolder和Keyframe可以创建出更加复杂的动画，使用PropertyValuesHolder可以实现几个属性的并行变化。 使用Keyframes，可以实现更复杂的动画过程中的属性变化方式。我们可以为每一个Keyframes明确一个fractional value（因子，0-1）来决定在整个动画过程中什么时候到达这个属性值。不设置fractions的时候，这些关键帧将会均匀的分布在整个动画过程中。至于那些没有指定value值的关键帧，将会在动画开始的时候推导出他们的 value。初次之外，我们可以给关键帧添加插值器，整个插值器将会在被设置的这一帧和前一帧动画之间。对于没有设置插值器的关键帧，将会给他们提供一个默认的插值器AccelerateDecelerateInterpolator XML实现123456789101112131415161718192021222324252627282930&lt;objectAnimator xmlns:android=\"http://schemas.android.com/apk/res/android\" android:duration=\"1000\" android:repeatCount=\"1\" android:repeatMode=\"reverse\"&gt; &lt;!-- BEGIN_INCLUDE(KeyframeResources) --&gt; &lt;propertyValuesHolder android:propertyName=\"x\"&gt; &lt;keyframe android:fraction=\"0\" android:value=\"800\" /&gt; &lt;keyframe android:fraction=\".2\" android:interpolator=\"@android:anim/accelerate_interpolator\" android:value=\"1000\" /&gt; &lt;keyframe android:fraction=\"1\" android:interpolator=\"@android:anim/accelerate_interpolator\" android:value=\"400\" /&gt; &lt;/propertyValuesHolder&gt; &lt;propertyValuesHolder android:propertyName=\"y\"&gt; &lt;keyframe /&gt; &lt;keyframe android:fraction=\".2\" android:interpolator=\"@android:anim/accelerate_interpolator\" android:value=\"300\" /&gt; &lt;keyframe android:interpolator=\"@android:anim/accelerate_interpolator\" android:value=\"1000\" /&gt; &lt;/propertyValuesHolder&gt; &lt;!-- END_INCLUDE(KeyframeResources) --&gt;&lt;/objectAnimator&gt; objectAnimator属性值 含义 android:propertyName 属性名称 android:valueTo 动画结束时属性的值 android:valueFrom android:duration 动画时长 android:startOffset 动画延迟几秒播放，调用start()方法后延迟 android:repeatCount 动画重复次数 android:repeatMode 动画重复的方式，restart/reverse android:valueType 属性值类型，intType,floatType,colorType,pathType propertyValuesHolder属性值和objectAnimator基本相同keyframe属性值 | 含义——————– | —————android:fraction | 插值因子android:interpolator | 插值器，用在当前帧和前一帧之间android:value | 需要设置的属性值 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120public class MainActivity extends AppCompatActivity { private int width; private int height; private ImageView imageView = null; private ImageView loveImageView = null; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); Toolbar toolbar = (Toolbar) findViewById(R.id.toolbar); toolbar.setNavigationIcon(R.drawable.left); setSupportActionBar(toolbar);//设置ActionBar getWidthAndHeight();//获取屏幕大小 imageView = (ImageView) findViewById(R.id.ball); loveImageView = (ImageView) findViewById(R.id.love); } /* 心跳 */ public void doAnimation(final View view) { PropertyValuesHolder pvhX = PropertyValuesHolder.ofFloat(\"alpha\", 1f, 0.8f, 1f, 0.8f, 1.0f); PropertyValuesHolder pvhY = PropertyValuesHolder.ofFloat(\"scaleX\", 0.6f, 0.8f, 1f, 0.8f, 1.0f); PropertyValuesHolder pvhZ = PropertyValuesHolder.ofFloat(\"scaleY\", 0.6f, 0.8f, 1f, 0.8f, 1.0f); ObjectAnimator.ofPropertyValuesHolder(loveImageView, pvhX, pvhY, pvhZ).setDuration(1000).start();//创建属性动画并开始 } /* 抛物线 */ public void doGtAnimation(final View view) { ObjectAnimator anim = ObjectAnimator.ofFloat(imageView, \"yidong\", 0, 1, 0).setDuration(3000); /*设置动画更新监听器，通过手动设置属性来实现view属性的改变达到动画的效果*/ anim.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() { @Override public void onAnimationUpdate(ValueAnimator animation) { float cVal = (Float) animation.getAnimatedValue(); imageView.setX(5 * cVal * 100); imageView.setY(5 * cVal * 3 * cVal * 3 * 100); } }); /*设置动画过程监听器，监听开始结束取消等动作*/ anim.addListener(new Animator.AnimatorListener() { @Override public void onAnimationStart(Animator animation) { System.err.println(\"yidong -- onAnimationStart\"); } @Override public void onAnimationEnd(Animator animation) { System.err.println(\"yidong -- onAnimationEnd\"); } @Override public void onAnimationCancel(Animator animation) { System.err.println(\"yidong -- onAnimationCancel\"); } @Override public void onAnimationRepeat(Animator animation) { System.err.println(\"yidong -- onAnimationRepeat\"); } }); /*重复魔石*/ anim.setRepeatMode(ValueAnimator.RESTART); /*重复次数*/ anim.setRepeatCount(2); anim.start(); } /* 转圈圈 */ public void doCircleAnimation(View view) { ObjectAnimator anim = ObjectAnimator.ofFloat(imageView, \"yidong\", 0, 2 * (float) Math.PI).setDuration(1000); anim.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() { @Override public void onAnimationUpdate(ValueAnimator animation) { System.err.println(\"yidong -- value = \" + animation.getAnimatedValue()); float cVal = (Float) animation.getAnimatedValue(); imageView.setX((float) Math.sin(cVal) * 200 + width / 2); imageView.setY((float) Math.cos(cVal) * 200 + height / 2); } }); anim.setRepeatMode(ValueAnimator.REVERSE); anim.setRepeatCount(-1);//无限重复 anim.start(); } /* 从xml文件中提取动画 */ public void doXmlAnimation(View view) { Animator animator = AnimatorInflater.loadAnimator(this, R.animator.one);//从xml文件中添加动画 animator.setTarget(loveImageView); animator.start(); } /* 获取屏幕的宽高 */ private void getWidthAndHeight() { WindowManager wm = (WindowManager) getSystemService(WINDOW_SERVICE); DisplayMetrics dm = new DisplayMetrics(); wm.getDefaultDisplay().getMetrics(dm); width = dm.widthPixels; height = dm.heightPixels; System.err.println(\"yidong -- width = \" + width); System.err.println(\"yidong -- height = \" + height); }} 实际效果 总结属性动画的内容很丰富，这里只是提到了ObjectAnimator的一些简单实现，很深入和全面的东西，需要自己看源码，熟悉对应的API。","link":"/2016/11/23/《Android 基础（三十一）》 ObjectAnimator/"},{"title":"《Android 基础（一）》 Service","text":"介绍 Service（服务）是一个没有用户界面的在后台运行执行耗时操作的应用组件。其他应用组件能够启动Service，并且当用户切换到另外的应用场景，Service将持续在后台运行。另外，一个组件能够绑定到一个service与之交互（IPC机制），例如，一个service可能会处理网络操作，播放音乐，操作文件I/O或者与内容提供者（content provider）交互，所有这些活动都是在后台进行。 Service有两种状态，“启动的”和“绑定”。 使用方法 看下关于Service两张比较经典的图 ####简单实例 AndroidManifest.xml 123456789101112131415&lt;application android:label=\"@string/app_name\" android:icon=\"@drawable/ic_launcher\"&gt; &lt;activity android:name=\".MyActivity\" android:label=\"@string/app_name\"&gt; &lt;intent-filter&gt; &lt;action android:name=\"android.intent.action.MAIN\"/&gt; &lt;category android:name=\"android.intent.category.LAUNCHER\"/&gt; &lt;/intent-filter&gt; &lt;/activity&gt; &lt;service android:name=\".MyService\" android:enabled=\"true\"/&gt; &lt;！--四大组件都要在AndroidManifest中申明一把 --&gt; &lt;/application&gt; MyActivity.java 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152public class MyActivity extends Activity implements View.OnClickListener, ServiceConnection { public static String TAG = \"MyActivity\"; Intent intent; /** * Called when the activity is first created. */ @Override public void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.main); Log.e(TAG, \"MyActivity OnCreate\"); intent = new Intent(MyActivity.this, MyService.class); findViewById(R.id.bt_startservice).setOnClickListener(this); findViewById(R.id.bt_stopservice).setOnClickListener(this); findViewById(R.id.bt_bindservice).setOnClickListener(this); findViewById(R.id.bt_unbindservice).setOnClickListener(this); } //OnClick事件监听 public void onClick(View view) { Log.e(TAG,\"OnClick\"); switch (view.getId()) { case R.id.bt_startservice: Log.e(TAG, \"start Service\"); startService(intent); break; case R.id.bt_stopservice: stopService(intent); break; case R.id.bt_bindservice: bindService(intent, this, Context.BIND_AUTO_CREATE); break; case R.id.bt_unbindservice: unbindService(this); break; } } @Override //binderService成功后回调，带过来的IBinder可用于和Activity通信 public void onServiceConnected(ComponentName componentName, IBinder iBinder) { Log.e(TAG, \"onServiceConnected\"); } @Override //在服务崩溃或被杀死导致的连接中断时被调用 public void onServiceDisconnected(ComponentName componentName) { Log.e(TAG, \"onServiceDisconnected\"); }} MyService.java 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455public class MyService extends Service { public static String TAG = \"MyService\"; @Override public void onCreate() { super.onCreate(); Log.e(TAG, \"MyService onCreate\"); } @Override public int onStartCommand(Intent intent, int flags, int startId) { Log.e(TAG, \"onStartCommand\"); //用来测试Service是否在后台有运行 /*new Thread(new Runnable() { @Override public void run() { while (true) { try { Thread.sleep(1000); } catch (InterruptedException e) { e.printStackTrace(); } Log.e(TAG, \"Service is Running ...\"); } } }).start();*/ return super.onStartCommand(intent, flags, startId); } @Override public void onDestroy() { super.onDestroy(); Log.e(TAG, \"onDestroy\"); } @Override public IBinder onBind(Intent intent) { Log.e(TAG, \"onBind\"); return new Binder();//new一个binder对象通过onServiceConnected回调，方便通信 } @Override public boolean onUnbind(Intent intent) { Log.e(TAG, \"onUnbind\"); return super.onUnbind(intent); } @Override //onRebind的调用时机和onUnbind的返回值有关系 public void onRebind(Intent intent) { Log.e(TAG, \"onRebind\"); super.onRebind(intent); }} 测试结果 启动服务，停止服务 绑定服务，解绑服务 启动服务，绑定服务，解绑服务 注意：这里最后Service是没有onDestory的 启动服务，绑定服务，解绑服务，停止服务 Binder使用，这个很关键 MyService.java中修改 123456789 public IBinder onBind(Intent intent) { Log.e(TAG, \"onBind\"); return new MyBinder(); }class MyBinder extends Binder { public void sayHello() { Log.e(TAG,\"I am a binder, hi\"); } } MyActivity.java中修改 12345public void onServiceConnected(ComponentName componentName, IBinder iBinder) { Log.e(TAG, \"onServiceConnected\"); MyService.MyBinder binder = (MyService.MyBinder) iBinder; ((MyService.MyBinder) iBinder).sayHello();} 然后执行：绑定服务，解绑服务 通过这个Binder，再加上Callback，可以实现对Service内部状态的监听 先定义一个接口，然后创建get与set，在onBinder方法中定义一个线程不停的发送数据 123456789101112public interface Callback() { public void onDateChanged(String data) { }}public void setCallback(Callback callback) { this.callback = callback;}public Callback getCallback() { return callback;} 12345678910111213141516171819202122public IBinder onBind(Intent intent) { Log.e(TAG, \"onBind\"); running = true;//running通过service的生命周期控制 new Thread(new Runnable() { @Override public void run() { while (running) { try { Thread.sleep(1000); i++; String str = \"send: \" + i ; callback.onDateChanged(str); } catch (InterruptedException e) { e.printStackTrace(); } Log.e(TAG, \"Service is Running ... \"); } } }).start(); return new MyBinder();} 然后在MyBinder类中定义一个getService方法 123public MyService getSetvice() { return MyService.this;} 然后在onServiceConnected中 12345678910111213141516public void onServiceConnected(ComponentName componentName, IBinder iBinder) { Log.e(TAG, \"onServiceConnected\"); MyService.MyBinder binder = (MyService.MyBinder) iBinder; MyService myservice = binder.getService(); myservice.setCallback(new MyService.Callback() { @Override public void onDateChanged(String str) {//非UI线程无法直接更新UI，需要通过handler机制 Message msg = new Message(); msg.arg1 = 1; Bundle bundle = new Bundle(); bundle.putString(\"data\", str); msg.setData(bundle); handler.sendMessage(msg); } }); } 通过这种方式就可以实现Service和Activity的通信工作，不难看出，Binder在其中起着非常重要的角色。Android中进程间通信，从JAVA到C++基本上都是用Binder来实现的，上层使用的AIDL下一篇介绍一下，","link":"/2016/05/22/《Android 基础（一）》 Service/"},{"title":"《Android 基础（七）》 DrawerLayout and NavigationView","text":"介绍 DrawerLayout是Support Library包中实现了侧滑菜单效果的控件android.support.v4.widget.DrawerLayoutNavigationView是一个导航菜单框架，使用menu资源填充数据常用来配合DrawerLayout使用 基本使用DrawerLayout布局文件1234567&lt;android.support.v4.widget.DrawerLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:app=\"http://schemas.android.com/apk/res-auto\" android:id=\"@+id/drawerlayout\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\"&gt; ……&lt;/android.support.v4.widget.DrawerLayout&gt; 使用DrawerLayout的时候需要将该布局作为根布局，然后在DrawerLayout中添加其他布局作为显示界面。 代码123456789101112131415161718192021222324drawerLayout = (DrawerLayout) findViewById(R.id.drawerlayout);获取DrawerLayout对象//设置监听事件，监听DrawerLayout的状态，打开，关闭，滑动距离，状态改变，可以实现自己的定制drawerLayout.addDrawerListener(new DrawerLayout.DrawerListener() { @Override public void onDrawerSlide(View drawerView, float slideOffset) { Log.e(TAG , \" onDrawerSlide slideOffset = \" + slideOffset); } @Override public void onDrawerOpened(View drawerView) { Log.e(TAG , \" onDrawerOpened \"); } @Override public void onDrawerClosed(View drawerView) { Log.e(TAG , \" onDrawerClosed \"); } @Override public void onDrawerStateChanged(int newState) { Log.e(TAG , \" onDrawerStateChanged \"); }}); DrawerLayout的状态监听，listener的回调提供给开发者使用。 NavigationView布局文件header.xml 123456789101112131415161718192021222324252627282930313233343536373839404142&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;RelativeLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" android:layout_width=\"match_parent\" android:layout_height=\"240dp\" android:background=\"@color/colorPrimaryDark\" android:orientation=\"vertical\"&gt; //引用GitHub上的开源库 &lt;de.hdodenhof.circleimageview.CircleImageView android:id=\"@+id/civ_profile\" android:layout_width=\"150dp\" android:layout_height=\"150dp\" android:layout_alignParentLeft=\"true\" android:layout_marginLeft=\"24dp\" android:layout_marginStart=\"24dp\" android:layout_marginTop=\"20dp\" android:src=\"@drawable/logo\" /&gt; &lt;TextView android:id=\"@+id/tv_name\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:layout_alignLeft=\"@+id/civ_profile\" android:layout_below=\"@+id/civ_profile\" android:layout_marginTop=\"10dp\" android:text=\"Askmak Sharon\" android:textColor=\"#FFFFFF\" android:textSize=\"8pt\" android:textStyle=\"bold\" /&gt; &lt;TextView android:id=\"@+id/tv_email\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:layout_alignLeft=\"@+id/civ_profile\" android:layout_below=\"@+id/tv_name\" android:layout_marginTop=\"10dp\" android:text=\"onlyloveyd@gmail.com\" android:textColor=\"#FFFFFF\" android:textSize=\"8pt\" android:textStyle=\"italic\" /&gt;&lt;/RelativeLayout&gt; 这里使用了Github上的开关库de.hdodenhof.circleimageview.CircleImageView，其中可以设置一些属性，这里没有设置，可能是因为我使用的图片风格的原因，将头像的边框加上去后看上去不是那么协调 属性 意义 app:civ_border_color=”” 边框颜色 app:civ_border_width=”” 边框宽度 app:civ_fill_color=”” 填充颜色 second_menu.xml这里只是名字叫做second_menu而已，没有其他的意思，只是一个普通的menu资源文件 123456789101112131415161718192021&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;menu xmlns:android=\"http://schemas.android.com/apk/res/android\"&gt; &lt;item android:id=\"@+id/nv_profile\" android:icon=\"@drawable/profile\" android:orderInCategory=\"80\" android:title=\"Profile\" /&gt; &lt;item android:id=\"@+id/nv_video\" android:icon=\"@drawable/video\" android:orderInCategory=\"90\" android:title=\"Video\" /&gt; &lt;item android:id=\"@+id/nv_help\" android:icon=\"@drawable/help\" android:orderInCategory=\"100\" android:title=\"Help\" /&gt;&lt;/menu&gt; 这个menu资源是用来在NavigationView中使用的导航菜单 activity_main.xml 123456789101112131415161718192021222324252627282930313233343536373839&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;android.support.v4.widget.DrawerLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:app=\"http://schemas.android.com/apk/res-auto\" android:id=\"@+id/drawerlayout\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\"&gt; &lt;LinearLayout android:orientation=\"vertical\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\"&gt; &lt;include layout=\"@layout/toolbar\"&gt;&lt;/include&gt; &lt;FrameLayout android:id=\"@+id/frame\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\"&gt; &lt;ImageView android:id=\"@+id/content_iv\" android:layout_gravity=\"center\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:src=\"@mipmap/ic_launcher\"/&gt; &lt;/FrameLayout&gt; &lt;/LinearLayout&gt; &lt;android.support.design.widget.NavigationView android:id=\"@+id/nv_left\" android:layout_width=\"240dp\" android:layout_height=\"match_parent\" android:layout_gravity=\"start\" app:headerLayout=\"@layout/header\" app:menu=\"@menu/second_menu\"&gt; &lt;/android.support.design.widget.NavigationView&gt;&lt;/android.support.v4.widget.DrawerLayout&gt; 比较关键的几个点android:layout_gravity=“start”app:headerLayout=”@layout/header”//头布局app:menu=”@menu/second_menu”//菜单资源 代码MainActivity.java 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485package mraz.com.actionbardemo;import android.os.Bundle;import android.support.design.widget.NavigationView;import android.support.design.widget.Snackbar;import android.support.v4.view.MenuItemCompat;import android.support.v4.widget.DrawerLayout;import android.support.v7.app.AppCompatActivity;import android.support.v7.widget.SearchView;import android.support.v7.widget.Toolbar;import android.util.Log;import android.view.Gravity;import android.view.Menu;import android.view.MenuItem;import android.view.View;import android.widget.ImageView;public class MainActivity extends AppCompatActivity { public static String TAG = \"yidong\"; DrawerLayout drawerLayout; NavigationView navigationView; Toolbar toolbar; ImageView imageView; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); drawerLayout = (DrawerLayout) findViewById(R.id.drawerlayout); toolbar = (Toolbar) findViewById(R.id.toolbar); navigationView = (NavigationView) findViewById(R.id.nv_left); imageView = (ImageView) findViewById(R.id.content_iv); setSupportActionBar(toolbar); toolbar.setNavigationIcon(R.drawable.ic_menu_black_24dp); drawerLayout.addDrawerListener(new DrawerLayout.DrawerListener() { @Override public void onDrawerSlide(View drawerView, float slideOffset) { Log.e(TAG , \" onDrawerSlide slideOffset = \" + slideOffset); } @Override public void onDrawerOpened(View drawerView) { Log.e(TAG , \" onDrawerOpened \"); } @Override public void onDrawerClosed(View drawerView) { Log.e(TAG , \" onDrawerClosed \"); } @Override public void onDrawerStateChanged(int newState) { Log.e(TAG , \" onDrawerStateChanged \"); } }); navigationView.setNavigationItemSelectedListener(new NavigationView.OnNavigationItemSelectedListener() { @Override public boolean onNavigationItemSelected(MenuItem item) { if(drawerLayout.isDrawerOpen(Gravity.LEFT)) drawerLayout.closeDrawer(Gravity.LEFT); switch(item.getItemId()) { case R.id.nv_profile: imageView.setImageResource(R.drawable.profile); break; case R.id.nv_video: imageView.setImageResource(R.drawable.video); break; case R.id.nv_help: imageView.setImageResource(R.drawable.help); break; } return true; } }); } ……} 针对NavigationView中的Menu设置响应事件，使用的方式和上一篇中ActionBar中的菜单资源使用方式相似，都是用过getItemId获取资源的id，然后以此作为依据进行对应的响应操作 ActionBar和DrawerLayout配合 一般用户的操作就是右滑或者点击ActionBar左上角的Icon出现左侧抽屉菜单 左侧滑动上面的内容已经实现了，点击ActionBar实现抽屉菜单的开关只需要针对左上角的ActionBar的图标做对应的事件处理即可。 12setSupportActionBar(toolbar);toolbar.setNavigationIcon(R.drawable.ic_menu_black_24dp); 然后在onOptionsItemSelected中 12345case android.R.id.home: if(!drawerLayout.isDrawerOpen(Gravity.LEFT)) { drawerLayout.openDrawer(Gravity.LEFT, true); } break; 因为ActionBar的NavigationIcon对应的资源ID就是 android.R.id.home 根据这个资源ID定制对应的事件响应，上面就是简单的打开左侧的抽屉菜单 效果图NavigationView菜单响应 ActionBar左上角图标响应 ####源代码 ###点击下载源代码###","link":"/2016/06/24/《Android 基础（七）》 DrawerLayout and NavigationView/"},{"title":"《Android 基础（三十三）》 TabHost ~ 仿微信底部菜单","text":"简介 Container for a tabbed window view. This object holds two children: a set of tab labels that theuser clicks to select a specific tab, and a FrameLayout object that displays the contents of thatpage. The individual elements are typically controlled using this container object, rather thansetting values on the child elements themselves.TabHost ，标签视图的容器。容器包含两个孩子节点，一个用来存放一系列的标签，点击来选择对应的窗口；一个是FrameLayout用来存放页面具体内容。这些独立的元素通常用TabHost来控制，而不是在视图内部通过设置值来实现 类结构 方法 意义 addTab 添加一个tab clearAllTabs 移除所有的tab dispatchKeyEvent 下发keyevent dispatchWindowFocusChanged 下发windowsfocusChanged事件 newTabSpec 创建一个新的TabSpec，关联到具体内容 onTouchModeChanged NA setup（） 不和TabActivity关联，通过findViewById获取的TabHost需要调用setup(),如果是在TabActivity中通过getTabHost()的方式获取的不需要调用这个方法 setup(LocalActivityManager activityGroup) setContent中传入intent的时候才关注下这个方法 getCurrentTab()/setCurrentTab() 获取/设置当前需要显示的tab，通过index setCurrentTabByTag/getCurrentTabTag 通过tag设置当前需要显示的Tab,tag就是创建TabSpec的时候传入的字符串 getCurrentTabView 设置/获取当前在TabWidget中显示的View,也就是作为标签的View而非内容 getCurrentView 获取当前显示的内容 setOnTabChangedListener 设置标签页切换事件监听 getTabContentView 获取内容页面的容器FrameLayout getTabWidget 获取TabWidget 基本使用布局文件(content_fragment.xml)1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:orientation=\"vertical\"&gt; &lt;android.support.v7.widget.Toolbar android:id=\"@+id/toolbar\" android:layout_width=\"match_parent\" android:layout_height=\"?attr/actionBarSize\" android:background=\"@color/colorTopBackGround\"&gt;&lt;/android.support.v7.widget.Toolbar&gt; &lt;TabHost android:id=\"@+id/tabhost\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\"&gt; &lt;LinearLayout android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:orientation=\"vertical\"&gt; &lt;!-- 设置的id必须是 \"@android:id/tabcontent\"--&gt; &lt;FrameLayout android:id=\"@android:id/tabcontent\" android:layout_width=\"match_parent\" android:layout_height=\"0dp\" android:layout_weight=\"9\"&gt; &lt;TextView android:id=\"@+id/tv_one\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:text=\"This is one\" android:textColor=\"@color/colorAccent\" android:textSize=\"20sp\" /&gt; &lt;TextView android:id=\"@+id/tv_two\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:text=\"This is two\" android:textColor=\"@color/colorPrimary\" android:textSize=\"25sp\" /&gt; &lt;TextView android:id=\"@+id/tv_three\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:text=\"This is three\" android:textColor=\"@color/colorPrimaryDark\" android:textSize=\"30sp\" /&gt; &lt;TextView android:id=\"@+id/tv_four\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:text=\"This is Four\" android:textColor=\"@color/colorBlack\" android:textSize=\"35sp\" /&gt; &lt;/FrameLayout&gt; &lt;!-- 设置的id必须是android:id=\"@android:id/tabs\" --&gt; &lt;TabWidget android:id=\"@android:id/tabs\" android:layout_width=\"match_parent\" android:layout_height=\"0dp\" android:layout_weight=\"1\" android:background=\"@color/colorWhite\" android:padding=\"5dp\" android:showDividers=\"none\"&gt;&lt;/TabWidget&gt; &lt;/LinearLayout&gt; &lt;/TabHost&gt;&lt;/LinearLayout&gt; 自定义底部标签布局(myindicator.xml)12345678910111213141516171819&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:orientation=\"vertical\"&gt; &lt;ImageView android:id=\"@+id/iv_indicator\" android:layout_width=\"match_parent\" android:layout_height=\"0dp\" android:layout_weight=\"5\"&gt;&lt;/ImageView&gt; &lt;TextView android:id=\"@+id/tv_indicator\" android:layout_width=\"match_parent\" android:layout_height=\"0dp\" android:layout_weight=\"2.5\" android:gravity=\"center\" android:textSize=\"5pt\" /&gt;&lt;/LinearLayout&gt; 底部一个图标下面一段文字代码使用(MainActivity.java)，不使用TabActivity123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293public class MainActivity extends AppCompatActivity { float initx = 0.0f, currentx = 0.0f; TabHost tabHost = null; Toolbar toolbar = null; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.content_fragment); toolbar = (Toolbar) findViewById(R.id.toolbar); setSupportActionBar(toolbar);//设置ActionBar toolbar.setTitleTextColor(getResources().getColor(R.color.colorWhite));//设置背景色 tabHost = (TabHost) findViewById(R.id.tabhost); tabHost.setup();//初始化TabHost /*添加tab*/ for (int i = 0; i &lt; 4; i++) { View view = LayoutInflater.from(this).inflate(R.layout.myindicator, null, false); TextView textView = (TextView) view.findViewById(R.id.tv_indicator); ImageView imageView = (ImageView) view.findViewById(R.id.iv_indicator); switch (i) { case 0: textView.setText(\"微信\"); imageView.setImageResource(R.drawable.weixin); tabHost.addTab(tabHost.newTabSpec(\"1\").setIndicator(view).setContent(R.id.tv_one)); break; case 1: textView.setText(\"通讯录\"); imageView.setImageResource(R.drawable.contact); tabHost.addTab(tabHost.newTabSpec(\"2\").setIndicator(view).setContent(R.id.tv_two)); break; case 2: textView.setText(\"发现\"); imageView.setImageResource(R.drawable.find); tabHost.addTab(tabHost.newTabSpec(\"3\").setIndicator(view).setContent(R.id.tv_three)); break; case 3: textView.setText(\"我\"); imageView.setImageResource(R.drawable.profile); tabHost.addTab(tabHost.newTabSpec(\"4\").setIndicator(view).setContent(R.id.tv_four)); break; } } /*设置标签切换监听器*/ tabHost.setOnTabChangedListener(new TabHost.OnTabChangeListener() { @Override public void onTabChanged(String tabId) { for (int i = 0; i &lt; 4; i++) {//颜色全部重置 ((TextView) tabHost.getTabWidget().getChildTabViewAt(i).findViewById(R.id.tv_indicator)).setTextColor(getResources().getColor(R.color.colorBlack)); } if (tabHost.getCurrentTabTag() == tabId) { ((TextView) tabHost.getCurrentTabView().findViewById(R.id.tv_indicator)).setTextColor(getResources().getColor(R.color.colorSelected)); }//选中的那个Tab文字颜色修改 } }); ((TextView) tabHost.getCurrentTabView().findViewById(R.id.tv_indicator)).setTextColor(getResources().getColor(R.color.colorSelected));//第一次进入的时候讲选中的Tab修改文字颜色 } @Override public boolean onTouchEvent(MotionEvent event) { switch (event.getAction()) { case MotionEvent.ACTION_DOWN: initx = event.getX(); break; case MotionEvent.ACTION_MOVE: currentx = event.getX(); break; case MotionEvent.ACTION_UP: /*左右滑动事件处理*/ if ((currentx - initx) &gt; 25) { if (tabHost.getCurrentTab() != 0) { tabHost.setCurrentTab(tabHost.getCurrentTab() - 1); } } else if ((currentx - initx) &lt; -25) { if (tabHost.getCurrentTab() != tabHost.getTabContentView().getChildCount()) { tabHost.setCurrentTab(tabHost.getCurrentTab() + 1); } } break; } return true; } /*菜单创建*/ @Override public boolean onCreateOptionsMenu(Menu menu) { getMenuInflater().inflate(R.menu.toolbar, menu); return true; }} 代码使用(MainActivity.java)，继承TabActivityTabActivity已经被废弃很久了，但是还是可以使用，在布局中将TabHost的id改成android:id=”@android:id/tabhost”，然后在继承了TabActivity的MainActivity.java中使用tabHost = getTabHost();然后基本使用方法就和上面一样了 实际效果 总结TabHost在TabActivity中的使用现在开发过程中使用的不多，推荐使用ViewPager和Fragment的方式。","link":"/2016/11/30/《Android 基础（三十三）》 TabHost ~ 仿微信底部菜单/"},{"title":"《Android 基础（三十五)》 RecyclerView多类型Item的正确实现姿势","text":"简介RecyclerView是我们开发过程中经常使用到的一个元素，原生的RecyclerView.Adapter基本上可以满足一般的需求，关于RecyclerView的基础介绍请移步： RecyclerView基础使用 关于多类型的Item,原生的Adapter可以通过getItemViewType返回对应的ViewHolder类型，然后在onCreateViewHolder传入的type参数，生成不同的ViewHolder，更要命的是数据绑定过程中onBindViewHolder只传入ViewHolder对象和position，针对不同的ViewHolder，我们只能通过instanceof和强制类型装换来对不同的ViewHolder进行不同的数据操作。 这样做的弊端就是，后续如果需要添加一个类型，几乎需要修改Adapter类中的每一个方法，不利于维护。 类结构 目的 便于维护。增删Item的类型不需要修改Adapter的代码； 条例清晰。不同类型的Item对应不同的Bean类，对应不用的ViewHolder,对应不同的layout, item type &lt;-&gt; layout &lt;—&gt; ViewHolder &lt;-&gt; java bean 工厂接口。抽象出TypeFactory接口，针对同一个Bean,可以使用不同的layout和不同的ViewHolder。 思路 所有Bean类实现统一Visitable接口，实现type方法，返回对应的layout id; 创建BaseViewHolder使用泛型，T为Bean类。使用SparseArray存储View,View的id作为唯一标识。 具体的ViewHolder类，继承BaseViewHolder,传入不同的Bean类，方便不同的ViewHolder中绑定不同的数据。 Adapter实现中使用Visitable List同一处理列表数据，使用事项TypeFactory接口的实例返回ItemType，viewHolder等 代码结构 代码内容Visitable接口123public interface Visitable { int type(TypeFactory typeFactory);} TypeFactory接口1234567public interface TypeFactory { int type(BannerBean bannerBean); int type(ContentBean contentBean); int type(SearchBean searchBean); int type(DividerBean dividerBean); BaseViewHolder createViewHolder(int type, View itemView);} BaseViewHolder抽象类12345678910111213141516171819202122public abstract class BaseViewHolder&lt;T&gt; extends RecyclerView.ViewHolder{ SparseArray&lt;View&gt; mViews; View mItemView; public BaseViewHolder(View itemView) { super(itemView); mItemView = itemView; mViews = new SparseArray&lt;&gt;(); } public View getView(int resId) { View view = mViews.get(resId); if(view== null) { view = mItemView.findViewById(resId); mViews.put(resId, view); } return view; } public abstract void bindViewData(T data);} TypeFactory实现类: ItemTypeFactory123456789101112131415161718192021222324252627282930313233343536373839404142public class ItemTypeFactory implements TypeFactory { public static final int BANNER_ITEM_LAYOUT = R.layout.rv_item_banner; public static final int CONTENT_ITEM_LAYOUT = R.layout.rv_item_content; public static final int SEARCH_ITEM_LAYOUT = R.layout.rv_item_search; public static final int DIVIDER_ITEM_LAYOUT = R.layout.rv_item_divider; @Override public int type(BannerBean bannerBean) { return BANNER_ITEM_LAYOUT; } @Override public int type(ContentBean contentBean) { return CONTENT_ITEM_LAYOUT; } @Override public int type(DividerBean dividerBean){ return DIVIDER_ITEM_LAYOUT; } @Override public int type(SearchBean dividerBean){ return SEARCH_ITEM_LAYOUT; } @Override public BaseViewHolder createViewHolder(int type, View itemView) { switch (type) { case BANNER_ITEM_LAYOUT: return new BannerViewHolder(itemView); case SEARCH_ITEM_LAYOUT: return new SearchViewHolder(itemView); case CONTENT_ITEM_LAYOUT: return new ContentViewHolder(itemView); case DIVIDER_ITEM_LAYOUT: return new DividerViewHolder(itemView); default: return null; } }} 各种Java Bean类BannerBean1234567891011121314151617181920public class BannerBean implements Visitable { int[] mResIds; public BannerBean(int[] mResIds) { this.mResIds = mResIds; } public int[] getmResIds() { return mResIds; } public void setmResIds(int[] mResIds) { this.mResIds = mResIds; } @Override public int type(TypeFactory typeFactory) { return typeFactory.type(this); }} 123456789101112&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" android:orientation=\"vertical\" android:layout_width=\"match_parent\" android:layout_height=\"200dp\"&gt; &lt;cn.bingoogolapple.bgabanner.BGABanner android:id=\"@+id/bgabanner_header\" android:layout_width=\"match_parent\" android:layout_height=\"200dp\"&gt; &lt;/cn.bingoogolapple.bgabanner.BGABanner&gt;&lt;/LinearLayout&gt; ContentBean123456789101112131415161718192021public class ContentBean implements Visitable{ String content; public String getContent() { return content; } public void setContent(String content) { this.content = content; } public ContentBean(String content) { this.content = content; } @Override public int type(TypeFactory typeFactory) { return typeFactory.type(this); }} 12345678910111213&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" android:orientation=\"vertical\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\"&gt; &lt;TextView android:id=\"@+id/tv_content\" android:textStyle=\"italic\" android:fontFamily=\"sans-serif-condensed\" android:textSize=\"16sp\" android:gravity=\"center_horizontal\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" /&gt;&lt;/LinearLayout&gt; DividerBean1234567public class DividerBean implements Visitable{ @Override public int type(TypeFactory typeFactory) { return typeFactory.type(this); }} 1234567&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" android:orientation=\"vertical\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:background=\"@drawable/divider\"&gt;&lt;/LinearLayout&gt; SearchBean123456public class SearchBean implements Visitable { @Override public int type(TypeFactory typeFactory) { return typeFactory.type(this); }} 1234567891011121314151617181920212223242526&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" android:orientation=\"horizontal\" android:layout_width=\"match_parent\" android:layout_height=\"50dp\" android:padding=\"6dp\"&gt; &lt;EditText android:layout_marginLeft=\"30dp\" android:id=\"@+id/et_search\" android:layout_width=\"0dp\" android:layout_weight=\"9\" android:maxLines=\"1\" android:textSize=\"10sp\" android:paddingLeft=\"10dp\" android:paddingRight=\"10dp\" android:hint=\"输入文字搜索...\" android:background=\"@drawable/bg_search\" android:layout_height=\"match_parent\" /&gt; &lt;ImageView android:id=\"@+id/bt_search\" android:layout_width=\"0dp\" android:layout_weight=\"2\" android:src=\"@drawable/search\" android:layout_height=\"match_parent\" /&gt;&lt;/LinearLayout&gt; MultiRecyclerAdapter123456789101112131415161718192021222324252627282930public class MultiRecyclerAdapter extends RecyclerView.Adapter&lt;BaseViewHolder&gt; { List&lt;Visitable&gt; mData; TypeFactory typeFactory; public MultiRecyclerAdapter(List&lt;Visitable&gt; mData) { this.mData = mData; this.typeFactory = new ItemTypeFactory(); } @Override public BaseViewHolder onCreateViewHolder(ViewGroup parent, int viewType) { View view = LayoutInflater.from(parent.getContext()).inflate(viewType, parent, false); return typeFactory.createViewHolder(viewType, view); } @Override public void onBindViewHolder(BaseViewHolder holder, int position) { holder.bindViewData(mData.get(position)); } @Override public int getItemViewType(int position) { return mData.get(position).type(typeFactory); } @Override public int getItemCount() { return (mData != null ? mData.size() : 0); }} 示例12345678910111213141516171819202122232425262728293031323334353637383940414243public class MultiActivity extends AppCompatActivity { @BindView(R.id.rv_content) RecyclerView rvContent; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_weather); ButterKnife.bind(this); List&lt;Visitable&gt; beans = new ArrayList&lt;&gt;(); int[] resIds = {R.mipmap.banner_one, R.mipmap.banner_two, R.mipmap.banner_three, R.mipmap.banner_four, R.mipmap.banner_five}; beans.add(new BannerBean(resIds)); beans.add(new SearchBean()); beans.add(new DividerBean()); beans.add(new ContentBean(\"one\")); beans.add(new ContentBean(\"one\")); beans.add(new ContentBean(\"one\")); beans.add(new DividerBean()); beans.add(new ContentBean(\"two\")); beans.add(new ContentBean(\"two\")); beans.add(new ContentBean(\"two\")); beans.add(new DividerBean()); beans.add(new ContentBean(\"three\")); beans.add(new ContentBean(\"three\")); beans.add(new ContentBean(\"three\")); beans.add(new DividerBean()); beans.add(new ContentBean(\"four\")); beans.add(new ContentBean(\"four\")); beans.add(new ContentBean(\"four\")); beans.add(new DividerBean()); MultiRecyclerAdapter multiRecyclerAdapter = new MultiRecyclerAdapter(beans); LinearLayoutManager linearLayoutManager = new LinearLayoutManager(this, LinearLayoutManager.VERTICAL, false); rvContent.setAdapter(multiRecyclerAdapter); rvContent.setLayoutManager(linearLayoutManager); }} 效果 写在最后 思路来源： https://medium.com/@dpreussler/writing-better-adapters-1b09758407d2 github上也有很多开源的万能Adapter，但是个人感觉这个思路虽然实现上代码会相对较多，但是层次分析，便于维护，扩展性较好。想要添加一个新类型的ItemType，只需要稍作修改即可快速完成，不用修改Adapter的代码。","link":"/2017/01/13/《Android 基础（三十五)》 RecyclerView多类型Item的正确实现姿势/"},{"title":"《Android 基础（三十八）》 FragmentTabHost","text":"简介 FragmentTabHost是一种特殊的TabHost，允许我们在Tab内容区域内使用Fragment。当我们得到FragmentTabHost对象后，我们必须通过调用setup(Context, FragmentManager, int)方法来完成对tabhost的初始化。FragmentTabHost是Android4.0版本的控件, 之前被广泛的使用，但是我尽然没有使用过，因为我开始学习Android的时候版本已经来到了5.0版本，使用的比较多的是TabLayout+ViewPager这种方式。但是作为基础知识，FragmentTabHost也是需要学习一下的。 类结构 FragmentTabHost继承TabHost。先看一下public方法 方法 描述 public FragmentTabHost(Context context) 构造方法 public FragmentTabHost(Context context, AttributeSet attrs) 构造方法 public void setup(Context context, FragmentManager manager)/public void setup(Context context, FragmentManager manager, int containerId) FragmentTabHost初始化方法，必须调用此方法完成初始化 public void setOnTabChangedListener(OnTabChangeListener l) 设置页面切换监听器 public void addTab(@NonNull TabHost.TabSpec tabSpec, @NonNull Class&lt;?&gt; clss,@Nullable Bundle args) 添加标签 public void onTabChanged(String tabId) FragmentTabHost实现TabHost.OnTabChangeListener 基本使用布局文件 activity_main.xml 注意： android:id=”@android:id/tabhost” android:id=”@android:id/tabcontent” android:id=”@android:id/tabs” 123456789101112131415161718192021222324&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;android.support.v4.app.FragmentTabHost android:id=\"@android:id/tabhost\" xmlns:android=\"http://schemas.android.com/apk/res/android\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\"&gt; &lt;LinearLayout android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:orientation=\"vertical\"&gt; &lt;FrameLayout android:id=\"@android:id/tabcontent\" android:layout_width=\"match_parent\" android:layout_height=\"0dp\" android:layout_weight=\"1\"/&gt; &lt;TabWidget android:id=\"@android:id/tabs\" android:layout_width=\"match_parent\" android:layout_height=\"?attr/actionBarSize\" android:layout_gravity=\"bottom\"/&gt; &lt;/LinearLayout&gt;&lt;/android.support.v4.app.FragmentTabHost&gt; fragment_content.xml 12345678910111213141516&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:tools=\"http://schemas.android.com/tools\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:orientation=\"vertical\"&gt; &lt;TextView android:id=\"@+id/tab_tv_text\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:gravity=\"center\" android:textSize=\"40sp\" tools:text=\"Test\"/&gt;&lt;/LinearLayout&gt; indicator.xml 12345678910111213141516171819&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:orientation=\"vertical\"&gt; &lt;ImageView android:id=\"@+id/iv_indicator\" android:layout_width=\"match_parent\" android:layout_height=\"0dp\" android:layout_weight=\"5\"/&gt; &lt;TextView android:id=\"@+id/tv_indicator\" android:layout_width=\"match_parent\" android:layout_height=\"0dp\" android:layout_weight=\"2.5\" android:gravity=\"center\" android:textSize=\"5pt\" /&gt;&lt;/LinearLayout&gt; 代码 MainActivity.java 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152public class MainActivity extends AppCompatActivity { // 图片 @DrawableRes private int mImages[] = { R.drawable.tab_daily, R.drawable.tab_sort, R.drawable.tab_bonus, R.drawable.tab_about }; // 标题 private String mFragmentTags[] = { \"每日干货\", \"分类阅读\", \"福利社区\", \"关于作者\" }; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); FragmentTabHost fragmentTabHost = (FragmentTabHost) this.findViewById(android.R.id.tabhost); fragmentTabHost.setup(this,getSupportFragmentManager(), android.R.id.tabcontent); for (int i = 0; i &lt; mImages.length; i++) { TabHost.TabSpec tabSpec = fragmentTabHost.newTabSpec(mFragmentTags[i]).setIndicator(getImageView(i)); fragmentTabHost.addTab(tabSpec, YFragment.class, null); fragmentTabHost.getTabWidget().getChildAt(i).setBackgroundResource(R.color.colorWhite); } fragmentTabHost.setOnTabChangedListener(new TabHost.OnTabChangeListener() { @Override public void onTabChanged(String s) { Toast.makeText(MainActivity.this, \"OnTabChanged To : \" + s, Toast.LENGTH_SHORT).show(); } }); } // 获得图片资源 private View getImageView(int index) { @SuppressLint(\"InflateParams\") View view = getLayoutInflater().inflate(R.layout.indicator, null); ImageView imageView = view.findViewById(R.id.iv_indicator); TextView textView = view.findViewById(R.id.tv_indicator); imageView.setImageResource(mImages[index]); textView.setText(mFragmentTags[index]); return view; }} YFragment.java 1234567891011121314151617181920public class YFragment extends Fragment { TextView mTvText; @Nullable @Override public View onCreateView(LayoutInflater inflater, @Nullable ViewGroup container, @Nullable Bundle savedInstanceState) { View view = inflater.inflate(R.layout.fragment_content, container, false); mTvText = view.findViewById(R.id.tab_tv_text); return view; } @Override public void onViewCreated(View view, @Nullable Bundle savedInstanceState) { super.onViewCreated(view, savedInstanceState); mTvText.setText(String.valueOf(getTag())); }} 图片资源tab_daily.xml 12345&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;selector xmlns:android=\"http://schemas.android.com/apk/res/android\"&gt; &lt;item android:state_selected=\"true\" android:drawable=\"@drawable/tab_daily_select\"/&gt; &lt;item android:drawable=\"@drawable/tab_daily_unselect\"/&gt;&lt;/selector&gt; 其余几个tab标签的内容参照如上 效果 其他测试操作一：注释掉 TabWidget activity_main.xml 123456789101112131415161718192021222324&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;android.support.v4.app.FragmentTabHost android:id=\"@android:id/tabhost\" xmlns:android=\"http://schemas.android.com/apk/res/android\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\"&gt; &lt;LinearLayout android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:orientation=\"vertical\"&gt; &lt;FrameLayout android:id=\"@android:id/tabcontent\" android:layout_width=\"match_parent\" android:layout_height=\"0dp\" android:layout_weight=\"1\"/&gt; &lt;!--&lt;TabWidget--&gt; &lt;!--android:id=\"@android:id/tabs\"--&gt; &lt;!--android:layout_width=\"match_parent\"--&gt; &lt;!--android:layout_height=\"?attr/actionBarSize\"--&gt; &lt;!--android:layout_gravity=\"bottom\"/&gt;--&gt; &lt;/LinearLayout&gt;&lt;/android.support.v4.app.FragmentTabHost&gt; 操作一：注释掉Id为@android:id/tabcontent的内容123456789101112131415161718192021222324&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;android.support.v4.app.FragmentTabHost android:id=\"@android:id/tabhost\" xmlns:android=\"http://schemas.android.com/apk/res/android\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\"&gt; &lt;LinearLayout android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:orientation=\"vertical\"&gt; &lt;!--&lt;FrameLayout--&gt; &lt;!--android:id=\"@android:id/tabcontent\"--&gt; &lt;!--android:layout_width=\"match_parent\"--&gt; &lt;!--android:layout_height=\"0dp\"--&gt; &lt;!--android:layout_weight=\"1\"/&gt;--&gt; &lt;!--&lt;TabWidget--&gt; &lt;!--android:id=\"@android:id/tabs\"--&gt; &lt;!--android:layout_width=\"match_parent\"--&gt; &lt;!--android:layout_height=\"?attr/actionBarSize\"--&gt; &lt;!--android:layout_gravity=\"bottom\"/&gt;--&gt; &lt;/LinearLayout&gt;&lt;/android.support.v4.app.FragmentTabHost&gt; 备注第五部分的解释可以从FragmentTabHost的源码中分析得到。","link":"/2017/08/08/《Android 基础（三十八）》 FragmentTabHost/"},{"title":"《Android 基础（三十九）》 SpannableString","text":"简介看下类的英文说明： This is the class for text whose content is immutable but to whichmarkup objects can be attached and detached.For mutable text, see {@link SpannableStringBuilder}. 装饰物可以添加和删除的定长文本。针对不定长文本，请使用SpannableStringBuilder。 类源码12345678910111213141516171819202122232425262728293031323334353637383940public class SpannableStringextends SpannableStringInternalimplements CharSequence, GetChars, Spannable{ public SpannableString(CharSequence source) { super(source, 0, source.length()); } private SpannableString(CharSequence source, int start, int end) { super(source, start, end); } public static SpannableString valueOf(CharSequence source) { if (source instanceof SpannableString) { return (SpannableString) source; } else { return new SpannableString(source); } } /* what代表span,start和end分别代表文本效果覆盖的起点index和终点index flag: SPAN_INCLUSIVE_INCLUSIVE:包含起点终点 SPAN_EXCLUSIVE_EXCLUSIVE:不包含起点终点 SPAN_INCLUSIVE_EXCLUSIVE:包含起点不包含终点 SPAN_EXCLUSIVE_INCLUSIVE:不包含起来包含终点 */ public void setSpan(Object what, int start, int end, int flags) { super.setSpan(what, start, end, flags); } public void removeSpan(Object what) { super.removeSpan(what); } public final CharSequence subSequence(int start, int end) { return new SpannableString(this, start, end); }} 这个类本身是没有多少内容的，但是如果深究到其父类，可能还是有一些东西可以看到。整体来说，你可以把他理解成一个高阶的String。SpannableStringBuilder就是高阶的StringBuilder. 基本使用看下frameworks/base/core/java/android/text/style/目录下的文件内容，大部分是支持的Span种类。 AbsoluteSizeSpan 单位为物理像素 12345//pixel sizeSpannableString spanString = new SpannableString(\"AbsoluteSizeSpan\");AbsoluteSizeSpan absoluteSizeSpan = new AbsoluteSizeSpan(100);spanString.setSpan(absoluteSizeSpan, 2, 5, Spannable.SPAN_INCLUSIVE_INCLUSIVE);mAbsoluteSizeSpanTextView.setText(spanString); AlignmentSpan支持ALIGN_NORMAL，ALIGN_OPPOSITE，ALIGN_CENTER，效果自行替换尝试 1234567//文本对齐方式SpannableString spannableString2 = new SpannableString( \"AlignmentSpanasdfasdfasdfasdfasdfasdasdfasdfasdasdagsdfsdfasdfsdfasdfasdafsdfsdfsdfsdf\");AlignmentSpan alignmentSpan = new AlignmentSpan.Standard(Layout.Alignment.ALIGN_CENTER);spannableString2.setSpan(alignmentSpan, 0, spannableString2.length(), Spannable.SPAN_INCLUSIVE_INCLUSIVE);mAlignmentSpanTextView.setText(spannableString2); BackgroundColorSpan 文字背景色改变 123456//背景色改变SpannableString spannableString3 = new SpannableString(\"BackgroundColorSpan\");BackgroundColorSpan backgroundColorSpan = new BackgroundColorSpan( Color.parseColor(\"#FFAACC\"));spannableString3.setSpan(backgroundColorSpan, 2, 5, Spanned.SPAN_INCLUSIVE_INCLUSIVE);mBackgroundColorSpanTextView.setText(spannableString3); BulletSpan12345//小子弹，类似于列表前面的小圆圈SpannableString spannableString4 = new SpannableString(\"BulletSpan\");spannableString4.setSpan(new BulletSpan(66, 0xff303F9F), 0, spannableString4.length(), Spannable.SPAN_INCLUSIVE_INCLUSIVE);mBulletSpanTextView.setText(spannableString4); ClickableSpan12345678910//可点击SpannableString spannableString5 = new SpannableString(\"ClickableSpan\");spannableString5.setSpan(new ClickableSpan() { @Override public void onClick(View view) { Toast.makeText(MainActivity.this, \"Click\", Toast.LENGTH_SHORT).show(); }}, 0, 5, Spanned.SPAN_INCLUSIVE_INCLUSIVE);mClickableSpanTextView.setText(spannableString5);mClickableSpanTextView.setMovementMethod(LinkMovementMethod.getInstance()); DrawableMarginSpan123456//Drawable，不占位SpannableString spannableString6 = new SpannableString(\"DrawableMarginSpan\");DrawableMarginSpan drawableMarginSpan = new DrawableMarginSpan( getResources().getDrawable(R.drawable.android), 10);spannableString6.setSpan(drawableMarginSpan, 0, 0, Spanned.SPAN_INCLUSIVE_INCLUSIVE);mDrawableMarginSpanTextView.setText(spannableString6); DynamicDrawableSpan123456789101112//DynamicDrawable,占位SpannableString spannableString7 = new SpannableString(\"DynamicDrawableSpan\");DynamicDrawableSpan dynamicDrawableSpan = new DynamicDrawableSpan() { @Override public Drawable getDrawable() { Drawable drawable = getResources().getDrawable(R.drawable.android); drawable.setBounds(0, 0, 100, 100); return drawable; }};spannableString7.setSpan(dynamicDrawableSpan, 0, 4, Spanned.SPAN_INCLUSIVE_INCLUSIVE);mDynamicDrawableSpanTextView.setText(spannableString7); ForegroundColorSpan1234567//前景色SpannableString spannableString9 = new SpannableString(\"ForegroundColorSpan\");ForegroundColorSpan foregroundColorSpan = new ForegroundColorSpan( Color.parseColor(\"#AABBCC\"));spannableString9.setSpan(foregroundColorSpan, 1, spannableString9.length() - 1, Spanned.SPAN_INCLUSIVE_INCLUSIVE);mForegroundColorSpanTextView.setText(spannableString9); IconMarginSpan12345678//图标margin，不占位SpannableString spannableString10 = new SpannableString( \"IconMarginSpan------------------------\");IconMarginSpan iconMarginSpan = new IconMarginSpan( BitmapFactory.decodeResource(getResources(), R.mipmap.ic_launcher));spannableString10.setSpan(iconMarginSpan, 0, spannableString10.length(), Spanned.SPAN_INCLUSIVE_INCLUSIVE);mIconMarginSpanTextView.setText(spannableString10); ImageSpan1234567//图片，占位SpannableString spannableString11 = new SpannableString( \"ImageSpan------------------------\");ImageSpan imageSpan = new ImageSpan(this, BitmapFactory.decodeResource(getResources(), R.mipmap.ic_launcher));spannableString11.setSpan(imageSpan, 0, 1, Spanned.SPAN_INCLUSIVE_INCLUSIVE);mImageSpanTextView.setText(spannableString11); LeadingMarginSpan123456//控制行前空隙SpannableString spannableString12 = new SpannableString( \"LeadingMarginSpan.Standard--------------------------------------------------\");spannableString12.setSpan(new LeadingMarginSpan.Standard(96, 36), 0, spannableString12.length(), Spanned.SPAN_INCLUSIVE_INCLUSIVE);mLeadingMarginSpanTextView.setText(spannableString12); QuoteSpan12345//左侧出现引用符号 竖线SpannableString spannableString15 = new SpannableString(\"QuoteSpan\");QuoteSpan quoteSpan = new QuoteSpan(Color.BLACK);spannableString15.setSpan(quoteSpan, 0, 5, Spanned.SPAN_INCLUSIVE_INCLUSIVE);mQuoteSpanTextView.setText(spannableString15); RelativeSizeSpan12345//字体放大SpannableString spannableString17 = new SpannableString(&quot;RelativeSizeSpan&quot;);RelativeSizeSpan relativeSizeSpan = new RelativeSizeSpan(2.5F);spannableString17.setSpan(relativeSizeSpan, 0, 4, Spanned.SPAN_INCLUSIVE_INCLUSIVE);mRelativeSizeSpanTextView.setText(spannableString17); ScaleXSpan12345//字体宽度放大SpannableString spannableString18 = new SpannableString(\"ScaleXSpan\");ScaleXSpan scaleXSpan = new ScaleXSpan(5);spannableString18.setSpan(scaleXSpan, 0, 4, Spanned.SPAN_INCLUSIVE_INCLUSIVE);mScaleXSpanTextView.setText(spannableString18); StrikethroughSpan12345//删除线SpannableString spannableString19 = new SpannableString(\"StrikethroughSpan\");StrikethroughSpan strikethroughSpan = new StrikethroughSpan();spannableString19.setSpan(strikethroughSpan, 0, 4, Spanned.SPAN_INCLUSIVE_INCLUSIVE);mStrikethroughSpanTextView.setText(spannableString19); StyleSpan123456789//主要由正常、粗体、斜体和同时加粗倾斜四种样式，常量值定义在Typeface类中。构造函数：SpannableString spannableString20 = new SpannableString(\"StyleSpan\");Parcel parcel = Parcel.obtain();parcel.writeInt(Typeface.BOLD_ITALIC);parcel.setDataPosition(0);StyleSpan styleSpan = new StyleSpan(parcel);spannableString20.setSpan(styleSpan, 0, spannableString20.length(), Spanned.SPAN_INCLUSIVE_INCLUSIVE);mStyleSpanTextView.setText(spannableString20); SubscriptSpan12345//下标SpannableString spannableString21 = new SpannableString(\"SubscriptSpan9\");SubscriptSpan subscriptSpan = new SubscriptSpan();spannableString21.setSpan(subscriptSpan, 0, spannableString21.length()-7, Spanned.SPAN_INCLUSIVE_INCLUSIVE);mSubscriptSpanTextView.setText(spannableString21); SuperscriptSpan12345//上标SpannableString spannableString23 = new SpannableString(\"SuperscriptSpan\");SuperscriptSpan superscriptSpan = new SuperscriptSpan();spannableString23.setSpan(superscriptSpan, 0, spannableString21.length()-7, Spanned.SPAN_INCLUSIVE_INCLUSIVE);mSuperscriptSpanTextView.setText(spannableString23); TextAppearanceSpan12345//Sets the text color, size, style, and typeface to match a TextAppearanceSpannableString spannableString24 = new SpannableString(\"TextAppearanceSpan\");TextAppearanceSpan textAppearanceSpan = new TextAppearanceSpan(this, R.style.StyleSpanDemo);spannableString24.setSpan(textAppearanceSpan, 0, spannableString24.length(), Spanned.SPAN_INCLUSIVE_INCLUSIVE);mTextAppearanceSpanTextView.setText(spannableString24); TypefaceSpan12345//字体设置SpannableString spannableString25 = new SpannableString(\"TypefaceSpan\");TypefaceSpan typefaceSpan= new TypefaceSpan(\"monospace\");spannableString25.setSpan(typefaceSpan, 0, spannableString25.length(), Spanned.SPAN_INCLUSIVE_INCLUSIVE);mTypefaceSpanTextView.setText(spannableString25); UnderlineSpan12345//下划线SpannableString spannableString26 = new SpannableString(\"UnderlineSpan\");UnderlineSpan underlineSpan= new UnderlineSpan();spannableString26.setSpan(underlineSpan, 0, spannableString25.length() - 4 , Spanned.SPAN_INCLUSIVE_INCLUSIVE);mUnderlineSpanTextView.setText(spannableString26); URLSpan12345//URLSpannableString spannableString27 = new SpannableString(\"URLSpan------------------------------\");URLSpan urlSpan = new URLSpan(\"https://www/baidu.com\");spannableString27.setSpan(urlSpan, 0, spannableString26.length(), Spanned.SPAN_INCLUSIVE_INCLUSIVE);mURLSpanTextView.setText(spannableString27); 备注示例完整Github:https://github.com/onlyloveyd/SpannableDemo","link":"/2017/08/11/《Android 基础（三十九）》 SpannableString/"},{"title":"《Android 基础（三十四）》 TabLayout 从头到脚","text":"简介 1.TabLayout给我们提供的是一排横向的标签页 2.#newTab()这个方法来创建新的标签页，然后用过#setText()和#setIcon方法分别修改标签页的文本和图标，创建完成之后，我们需要使用#addtab()方法把他加到TabLayout中显示出来 3.第二种添加标签的方式就是直接在TabLayout布局下添加#TabItem控件 4.对于TabLayout在标签之前的切换事件我们可以通过注册一个监听器来处理，#setOnTabSelectedListener(OnTabSelectedListener) 5.TabLayout可以和ViewPager一起使用 自定义属性值TabLayout属性 属性 意义 tabGravity fill，填满TabLayout；center,居中显示 tabMode fixed, 固定标签；scrollable，可滚动标签，个数较少的时候可以使用fixed,如果标签超出了屏幕范围，设置为scrollable比较好 tabMaxWidth Tab的最大宽度 tabIndicatorColor 底部滑动的线条的颜色，默认是colorAccent tabIndicatorHeight 底部滑动线条的高度 tabPadding* 标签页的padding tabBackground 标签页的背景 tabTextAppearance 文本设置 tabSelectedTextColor 选中字体颜色 TabItem属性 属性 意义 text 标签文字 icon 图标 layout 自定义布局 源码分析 一点一点的看 类成员 稍微解释一下 Mode MODE_SCROLLABLE, MODE_FIXED两种模式，一个是固定，一个是可滚动 TabGravity GRAVITY_FILL， GRAVITY_CENTER,两种摆放方式，铺满和居中 OnTabSelectedListener Tab切换事件的回调接口 Tab类 对TabView进行的封装，给它加了一些属性，因为TabView无法对外暴露，相当于给外部提供一个调用的类，值得一提的是这个tag是一个object,所以可以往里面存放各种内容，传递数据的时候可能会有用 TabLayoutOnPageChangeListener 继承 ViewPager.OnPageChangeListener用于与ViewPager联动，主要是indicator的动作和tab页的选中 ViewPagerOnTabSelectedListener 继承TabLayout.OnTabSelectedListener，viewpager用来配合tablayout的页面切换事件 方法 稍微解释一下 构造方法 不显示滚动条，创建标签条就是下面滚来滚去的那个东东，获取自定义属性值 addTab 手动添加Tab页 addOnTabSelectedListener/removeOnTabSelectedListener、clearOnTabSelectedListeners 添加/移除/清空Tab选择事件监听器 newTab 创建Tab页 getTabAt 通过index获取Tab removeTab 通过tab实例移除tab removeTabAt 移除特定位置的tab removeAllTabs 清空tabs setTabTextColors 设置tab的正常显示颜色和选中后颜色 setupWithViewPager 通过ViewPager初始化TabLayout shouldDelayChildPressedState 判断是否需要delay视图的press状态，一般无法滚动的视图直接返回false,可以滚动的视图看情况返回true或者false addView 添加TabItem,如果参数类型不是TabItem会报异常 generateLayoutParams 默认生成属性值，防止TabItem没有定义android:layout_*而报异常 结合上面的介绍，这些内容含义应该比较清晰了 基本使用不使用setupWithViewPager,与ViewPager联动布局文件12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:app=\"http://schemas.android.com/apk/res-auto\" xmlns:tools=\"http://schemas.android.com/tools\" android:id=\"@+id/activity_main\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:orientation=\"vertical\" tools:context=\"onlyloveyd.com.indicatordemo.MainActivity\"&gt; &lt;android.support.design.widget.TabLayout android:id=\"@+id/tb_title\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:background=\"@color/colorWhite\" app:tabGravity=\"fill\" app:tabIndicatorColor=\"@color/colorAccent\" app:tabIndicatorHeight=\"4dp\" app:tabMode=\"fixed\" app:tabSelectedTextColor=\"@color/colorAccent\" app:tabTextColor=\"@color/colorBlack\"&gt; &lt;android.support.design.widget.TabItem android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:icon=\"@drawable/one\" android:text=\"社会\"/&gt; &lt;android.support.design.widget.TabItem android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:icon=\"@drawable/two\" android:text=\"娱乐\"/&gt; &lt;android.support.design.widget.TabItem android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:icon=\"@drawable/three\" android:text=\"体育\"/&gt; &lt;android.support.design.widget.TabItem android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:icon=\"@drawable/four\" android:text=\"军事\"/&gt; &lt;/android.support.design.widget.TabLayout&gt; &lt;android.support.v4.view.ViewPager android:id=\"@+id/vp_content\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\"/&gt;&lt;/LinearLayout&gt; MainActivity123456789101112131415161718192021public class MainActivity extends AppCompatActivity { @BindView(R.id.activity_main) LinearLayout activityMain; @BindView(R.id.vp_content) ViewPager vpContent; @BindView(R.id.tb_title) TabLayout tbTitle; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); ButterKnife.bind(this); MainPagerAdapter mainPagerAdapter = new MainPagerAdapter(getSupportFragmentManager()); vpContent.setAdapter(mainPagerAdapter); tbTitle.addOnTabSelectedListener(new TabLayout.ViewPagerOnTabSelectedListener(vpContent)); vpContent.addOnPageChangeListener(new TabLayout.TabLayoutOnPageChangeListener(tbTitle)); }} 关键点在最后两行代码 12tbTitle.addOnTabSelectedListener(new TabLayout.ViewPagerOnTabSelectedListener(vpContent));vpContent.addOnPageChangeListener(new TabLayout.TabLayoutOnPageChangeListener(tbTitle)); 这两行代码来源于TabLayout的setupWithViewPager方法，目的就是为了实现ViewPager和TabLayout的联动，但是也不用removeAllTabs，看过这部分源码的朋友应该都知道，setupWithViewPager方法中先清除tab,然后根据ViewPager的getPagerTitle返回的字符串创建文字Tab并且添加到TabLayout中用于与ViewPager联动，这就是为啥很多初学者在使用setupWithViewPager的时候出现tab页无法显示的问题一般原因都是自己添加了tab或者是在布局文件中定义了TabItem但是使用的时候调用了setupWithViewPager方法，但是ViewPager的Adapter又没有复写getPagerTitle方法，因为这个方法在PagerAdapter中实默认返回null的。同时还有一个弊端就是setupWithViewPager并不支持图标显示。，原因就是： 而在populateFromPagerAdapter的实现中 123456789101112131415161718void populateFromPagerAdapter() { removeAllTabs();//一开始就把全部的tab给干掉 if (mPagerAdapter != null) { final int adapterCount = mPagerAdapter.getCount();//获取ViewPager的数量 for (int i = 0; i &lt; adapterCount; i++) { addTab(newTab().setText(mPagerAdapter.getPageTitle(i)), false);//只拿title,没有设置icon } // Make sure we reflect the currently set ViewPager item if (mViewPager != null &amp;&amp; adapterCount &gt; 0) { final int curItem = mViewPager.getCurrentItem(); if (curItem != getSelectedTabPosition() &amp;&amp; curItem &lt; getTabCount()) { selectTab(getTabAt(curItem)); } } }} 实际效果 使用setupWithViewPager,与ViewPager联动 既然setupWithViewPager会清除TabItem,那么我们就不添加TabItem，让它自己处理吧 布局文件去掉上个例子中的四个TabItemMainActivity中去掉后面两行，换成如下一行代码1tbTitle.setupWithViewPager(vpContent); 实际效果 虽说setupWithViewPager本身的实现过程是不支持Icon的显示的，但是我们可以自己动手，一个简单的循环解决问题，实现的效果与上面4.1节相同 1234for(int index = 0 ; index&lt; tbTitle.getTabCount(); index++) { TabLayout.Tab tab = tbTitle.getTabAt(index); tab.setIcon(MainPagerAdapter.mIcons[index]);} 自定义Layout的TabItem图标+文字布局文件1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:app=\"http://schemas.android.com/apk/res-auto\" xmlns:tools=\"http://schemas.android.com/tools\" android:id=\"@+id/activity_main\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:orientation=\"vertical\" tools:context=\"onlyloveyd.com.indicatordemo.MainActivity\"&gt; &lt;android.support.design.widget.TabLayout android:id=\"@+id/tb_title\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:background=\"@color/colorWhite\" app:tabGravity=\"fill\" app:tabIndicatorColor=\"@color/colorAccent\" app:tabIndicatorHeight=\"4dp\" app:tabMode=\"fixed\" app:tabSelectedTextColor=\"@color/colorAccent\" app:tabTextColor=\"@color/colorBlack\"&gt; &lt;android.support.design.widget.TabItem android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:icon=\"@drawable/one\" android:layout=\"@layout/custom_indicator\" android:text=\"社会\"/&gt; &lt;android.support.design.widget.TabItem android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:layout=\"@layout/custom_indicator2\" android:icon=\"@drawable/two\" android:text=\"娱乐\"/&gt; &lt;android.support.design.widget.TabItem android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:layout=\"@layout/custom_indicator3\" android:icon=\"@drawable/three\" android:text=\"体育\"/&gt; &lt;android.support.design.widget.TabItem android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:icon=\"@drawable/four\" android:text=\"军事\"/&gt; &lt;/android.support.design.widget.TabLayout&gt; &lt;android.support.v4.view.ViewPager android:id=\"@+id/vp_content\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\"/&gt;&lt;/LinearLayout&gt; 使用自定义布局android:layout=”@layout/custom_indicator”android:layout=”@layout/custom_indicator2”android:layout=”@layout/custom_indicator3” custom_indicator.xml文件内容，值得注意的是这里的TextView的id必须是”@android:id/text1”,ImageView的id必须是”@android:id/icon”，原因来自于与TabLayout的源码中TabView的update方法。 custom_indicator.xml 12345678910111213141516171819&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" android:orientation=\"vertical\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\"&gt; &lt;TextView android:id=\"@android:id/text1\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:gravity=\"center\" /&gt; &lt;ImageView android:id=\"@android:id/icon\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:layout_gravity=\"center\" /&gt;&lt;/LinearLayout&gt; 其他的两个文件和这个类似，只是位置调整一下。 实际效果","link":"/2017/01/02/《Android 基础（三十四）》 TabLayout 从头到脚/"},{"title":"《Android 基础（六）》 ActionBar","text":"介绍 Action Bar是一种新増的导航栏功能，在Android 3.0之后加入到系统的API当中，它标识了用户当前操作界面的位置，并提供了额外的用户动作、界面导航等功能。使用ActionBar的好处是，它可以给提供一种全局统一的UI界面，使得用户在使用任何一款软件时都懂得该如何操作，并且ActionBar还可以自动适应各种不同大小的屏幕。下面是一张使用ActionBar的界面截图： 其中，[1]是ActionBar的图标，[2]是两个action按钮，[3]是overflow按钮。 基本使用添加ActionBar布局文件AndroidStudio自动创建的MainActivity继承自AppCompatActivity本身携带有ActionBar，这里想要使用ToolBar来实现ActionBar的功能，需要先修改下theme 1234567&lt;!-- Base application theme. --&gt;&lt;style name=\"AppTheme\" parent=\"Theme.AppCompat.Light.NoActionBar\"&gt; &lt;!-- Customize your theme here. --&gt; &lt;item name=\"colorPrimary\"&gt;@color/colorPrimary&lt;/item&gt; &lt;item name=\"colorPrimaryDark\"&gt;@color/colorPrimaryDark&lt;/item&gt; &lt;item name=\"colorAccent\"&gt;@color/colorAccent&lt;/item&gt;&lt;/style&gt; 使用Theme.AppCompat.Light.NoActionBar作为activity的风格，这里插述一下相关属性代表的界面位置 创建ToolBar对应的xml文件 toolbar.xml 123456789101112&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;android.support.v7.widget.Toolbar android:id=\"@+id/toolbar\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:background=\"?attr/colorPrimary\" android:minHeight=\"?attr/actionBarSize\" app:popupTheme=\"@style/ThemeOverlay.AppCompat.Light\" app:theme=\"@style/ThemeOverlay.AppCompat.ActionBar\" xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:app=\"http://schemas.android.com/apk/res-auto\"&gt;&lt;/android.support.v7.widget.Toolbar&gt; 这里把这个文件单独作为一个xml方便多个layout中包含 activity_main.xml 1234567891011121314151617&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:tools=\"http://schemas.android.com/tools\" xmlns:app=\"http://schemas.android.com/apk/res-auto\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:id=\"@+id/rootlayout\" tools:context=\"mraz.com.actionbardemo.MainActivity\" android:orientation=\"vertical\"&gt; &lt;include layout=\"@layout/toolbar\"/&gt; &lt;TextView android:id=\"@+id/tv_hello\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:text=\"Hello World!\" /&gt;&lt;/LinearLayout&gt; 主界面对应的layout中include刚才创建的toolbar.xml文件 main_menu.xml 1234567891011121314151617181920212223242526&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;menu xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:app=\"http://schemas.android.com/apk/res-auto\"&gt; &lt;item android:id=\"@+id/action_search\" android:icon=\"@drawable/ic_search_black_24dp\" app:actionViewClass=\"android.support.v7.widget.SearchView\" android:title=\"Search\" android:inputType=\"textCapWords\" android:imeOptions=\"actionSearch\" android:orderInCategory=\"80\" app:showAsAction=\"ifRoom|collapseActionView\"/&gt; &lt;item android:id=\"@+id/action_settings\" android:icon=\"@drawable/ic_apps_black_24dp\" android:title=\"Settings\" android:orderInCategory=\"100\" app:showAsAction=\"always\"/&gt; &lt;item android:id=\"@+id/action_info\" android:title=\"Details\" android:icon=\"@drawable/ic_report_black_24dp\" android:orderInCategory=\"90\" app:showAsAction=\"ifRoom\"/&gt;&lt;/menu&gt; menu 对应的属性解释一下 属性值 意义 id 控件id title 标题（必需） icon 图标 showAsAction 控制显示到actionbar还是overflow actionViewClass 构建视图所使用的View actionProviderClass 基本同上 menuCategory 同种菜单项的种类。该属性可取4个值：containersystem、secondary和alternative。通过menuCategroy属性可以控制菜单项的置。例如将属性设为system，表示该菜单项是系统菜单，应放在其他种类菜单项的后面。 orderInCategory 同种类菜单的排列顺序。该属性需要设置一个整数值,越越靠左 showAsAction 的几个属性，解释一下 属性 意义 ifRoom 根据当前的空间大小调整 never 永远不会显示。只会在溢出列表中显示，而且只显示标题，以在定义item的时候，最好把标题都带上 always 无论是否溢出，都会显示 withText withText值示意Action bar要显示文本标题。Actionbar会尽可能的显示这个标题，但是，如果图标有效并且受到Action bar空间的限制文本标题有可能显示不全。 collapseActionView 声明了这个操作视窗应该被折叠到一个按钮中，当用户选择个按钮时，这个操作视窗展开。否则，这个操作视窗在默认的情况下是可见的，并且即在用于不适用的时候，也要占据操作栏的有效空间。一般要配合ifRoom一起使用才会有果。 代码使用12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849package mraz.com.actionbardemo;import android.os.Bundle;import android.support.design.widget.Snackbar;import android.support.v7.app.AppCompatActivity;import android.support.v7.widget.Toolbar;import android.view.Menu;import android.view.MenuItem;import android.widget.LinearLayout;public class MainActivity extends AppCompatActivity { LinearLayout rootlayout; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); rootlayout = (LinearLayout) findViewById(R.id.rootlayout); Toolbar toolbar = (Toolbar) findViewById(R.id.toolbar); setSupportActionBar(toolbar); toolbar.setNavigationIcon(R.drawable.ic_menu_black_24dp); } @Override public boolean onCreateOptionsMenu(Menu menu) { getMenuInflater().inflate(R.menu.main_menu, menu); return true; } @Override public boolean onOptionsItemSelected(MenuItem item) { switch (item.getItemId()) { case R.id.action_info: Snackbar.make(rootlayout, \" Info \", Snackbar.LENGTH_SHORT).show(); break; case R.id.action_search: Snackbar.make(rootlayout, \" Search \", Snackbar.LENGTH_SHORT).show(); break; case R.id.action_settings: Snackbar.make(rootlayout, \" Settings \", Snackbar.LENGTH_SHORT).show(); break; } return super.onOptionsItemSelected(item); }} 比较关键的只有3行代码 Toolbar toolbar = (Toolbar) findViewById(R.id.toolbar); //获取toolbarsetSupportActionBar(toolbar); //设置成ActionBargetMenuInflater().inflate(R.menu.main_menu, menu); //创建actionbar的单项 有了这些代码基本上就可以显示ActionBar，当然要实现与用户的交互，就需要对每一个ite做对应的响应处理，这里根据菜单的id，做了简单的Snackbar的展示，开发者可以根据自己需要实现更复杂的逻辑 1234567public boolean onOptionsItemSelected(MenuItem item) { switch (item.getItemId()) { case R.id.action_info: Snackbar.make(rootlayout, \" Info \", Snackbar.LENGTH_SHORT).show(); break; ……} 效果图 使用Action View上面的例子中有个比较特殊的Menu Item 12345678&lt;item android:id=\"@+id/action_search\" android:icon=\"@drawable/ic_search_black_24dp\" app:actionViewClass=\"android.support.v7.widget.SearchView\" android:title=\"Search\" android:inputType=\"textCapWords\" android:imeOptions=\"actionSearch\" android:orderInCategory=\"80\" app:showAsAction=\"ifRoom|collapseActionView\"/&gt; 这里使用了actionViewClass，这个要设置shwoAsAction为 ifRoom|collapseActionView使用才行,其实删除collapseActionView，也是可以正常使用，只是体现的方式不一样。获取SearchView的方式 12MenuItem item = menu.findItem(R.id.action_search);SearchView searchView = (SearchView) item.getActionView(); SerachView 对象拿到之后可以对其属性进行操作。给Action View添加展开和收起的事件监听，实现方式 12345678910111213141516171819public boolean onCreateOptionsMenu(Menu menu) { getMenuInflater().inflate(R.menu.main_menu, menu); MenuItem searchitem = menu.findItem(R.id.action_search); SearchView searchView = (SearchView) searchitem.getActionView(); MenuItemCompat.setOnActionExpandListener(searchitem, new MenuItemCompat.OnActionExpandListener() { @Override public boolean onMenuItemActionExpand(MenuItem item) { Snackbar.make(rootlayout, \" onMenuItemActionExpand \", Snackbar.LENGTH_SHORT).show(); return true; } @Override public boolean onMenuItemActionCollapse(MenuItem item) { Snackbar.make(rootlayout, \" onMenuItemActionCollapse \", Snackbar.LENGTH_SHORT).show(); return true; } }); return true;} 拿到searchItem之后，执行MenuItemCompat.setOnActionExpandListener(searchitem, new MenuItemCompat.OnActionExpandListener() )； 效果图 使用ActionProviderClassmenu文件中使用 12345&lt;item android:title=\"Share\" android:actionProviderClass=\"android.widget.ShareActionProvider\" android:orderInCategory=\"100\" app:showAsAction=\"always\" /&gt; 类似的方式获取ActionProvider 1234MenuItem shareItem = menu.findItem(R.id.action_share);ShareActionProvider mShareActionProvider = (ShareActionProvider) MenuItemCompat.getActionProvider(shareItem);mShareActionProvider.setShareIntent(……); 针对ActionProvider可以实现自定义的ActionProvider，继承基础类ActionProvider ActionBar导航启用ActionBar图标导航的功能，可以允许用户根据当前应用的位置来在不同界面之间切换。比如，A界面展示了一个列表，点击某一项之后进入了B界面，这时B界面就应该启用ActionBar图标导航功能，这样就可以回到A界面。我们可以通过调用setDisplayHomeAsUpEnabled()方法来启用ActionBar图标导航功能 123Toolbar toolbar = (Toolbar) findViewById(R.id.toolbar);setSupportActionBar(toolbar);getSupportActionBar().setDisplayHomeAsUpEnabled(true); 此时ActionBar左侧会出现一个返回的按钮 针对这返回按钮的事件响应还是在public boolean onOptionsItemSelected(MenuItem item) 方法中实现，它有一个固定的资源Id—- android.R.id.home 123case android.R.id.home: finish(); break; 简单的执行下和返回键相同的操作。结束当前activity 实现Activity之间的快速切换新建一个ParentActivity.java 12345678910111213141516171819202122232425262728package mraz.com.actionbardemo;import android.content.Context;import android.content.Intent;import android.support.v7.app.AppCompatActivity;import android.os.Bundle;import android.view.View;import android.widget.TextView;public class ParentActivity extends AppCompatActivity { @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_parent); final Context mContext = this; TextView textView = (TextView) findViewById(R.id.tv_parent); textView.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View v) { Intent intent = new Intent(); intent.setClass(mContext , MainActivity.class); startActivity(intent); } }); }} AndroidManifest.xml文件中做如下修改 1234567891011121314151617&lt;application ……&gt; &lt;activity android:name=\".ParentActivity\"&gt; &lt;intent-filter&gt; &lt;action android:name=\"android.intent.action.MAIN\" /&gt; &lt;category android:name=\"android.intent.category.LAUNCHER\" /&gt; &lt;/intent-filter&gt; &lt;/activity&gt; &lt;activity android:name=\".MainActivity\" android:parentActivityName=\"mraz.com.actionbardemo.ParentActivity\"&gt; &lt;/activity&gt;&lt;/application&gt; 这一句很关键android:parentActivityName=“mraz.com.actionbardemo.ParentActivity”&gt;设置父Activity的名称，ParentActivity为启动Activity同时是MainActivity的父Activity然后在MainActivity中针对这个返回按钮做一下处理，不再是简单的结束掉当前的这个Activity了，需要做出对应的导航的处理逻辑 1234567891011case android.R.id.home: Intent upIntent = NavUtils.getParentActivityIntent(this); if (NavUtils.shouldUpRecreateTask(this, upIntent)) { TaskStackBuilder.create(this) .addNextIntentWithParentStack(upIntent) .startActivities(); } else { upIntent.addFlags(Intent.FLAG_ACTIVITY_CLEAR_TOP); NavUtils.navigateUpTo(this, upIntent); } break; 其中，调用NavUtils.getParentActivityIntent()方法可以获取到跳转至父Activity的Intent，然后如果父Activity和当前Activity是在同一个Task中的，则直接调用navigateUpTo()方法进行跳转，如果不是在同一个Task中的，则需要借助TaskStackBuilder来创建一个新的Task。这样，就按照标准的规范成功实现ActionBar导航的功能了。 效果图","link":"/2016/06/23/《Android 基础（六）》 ActionBar/"},{"title":"《Android 基础（十七）》 ViewPager","text":"简介 Layout manager that allows the user to flip left and rightthrough pages of data. You supply an implementation of a{@link PagerAdapter} to generate the pages that the view shows. ViewPager is most often used in conjunction with {@link android.app.Fragment},which is a convenient way to supply and manage the lifecycle of each page.There are standard adapters implemented for using fragments with the ViewPager,which cover the most common use cases. These are{@link android.support.v4.app.FragmentPagerAdapter} and{@link android.support.v4.app.FragmentStatePagerAdapter}; each of theseclasses have simple code showing how to build a full user interfacewith them. Views which are annotated with the {@link DecorView} annotation are treated aspart of the view pagers ‘decor’. Each decor view’s position can be controlled viaits {@code android:layout_gravity} attribute. For example: 12345678&lt;android.support.v4.view.ViewPager android:layout_width=\"match_parent\" android:layout_height=\"match_parent\"&gt; &lt;android.support.v4.view.PagerTitleStrip android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:layout_gravity=\"top\" /&gt; &lt;/android.support.v4.view.ViewPager&gt; 翻译：ViewPager允许用户通过载有数据的页面实现左右滑动。开发者需要自己实现PagerAdapter来生成需要显示的页面。ViewPager通常回合Fragment结合起来使用，这样实现起来比较简单同时也便于管理每个页面的生命周期。Android存在标准的适配器模板针对Fragment和ViewPager结合使用的方式：android.support.v4.app.FragmentPagerAdapterandroid.support.v4.app.FragmentStatePagerAdapter每个类都有简单的说明，告诉开发者如何通过他们来实现与用户的交互。 被注释成DecorView的视图均可当做ViewPager的一部分，每一个DecorView的位置可以通过 android:layout_gravity属性来控制，例如： 12345678&lt;android.support.v4.view.ViewPager android:layout_width=\"match_parent\" android:layout_height=\"match_parent\"&gt; &lt;android.support.v4.view.PagerTitleStrip android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:layout_gravity=\"top\" /&gt; &lt;/android.support.v4.view.ViewPager&gt; 类结构 常用成员的功能介绍 成员 功能 ViewPager() 构造方法 addOnAdapterChangeListener 添加一个OnAdapterChangeListener removeOnAdapterChangeListener 移除一个OnAdapterChangeListener setCurrentItem 设置当前Pager的index addOnePageChangeListener 设置一个页面改变监听器 addOnePageChangeListener 移除一个页面改变监听器 clearOnPageChangeListener 移除所有的页面改变监听器 setPageTransformer 设置页面之间切换的过程中PageTransformer 其他的一些方法从使用程度上来看比较的少见，源码内容大家通过AS都是可以查看到的。 基本使用简单显示布局文件 1234567891011121314&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;RelativeLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:tools=\"http://schemas.android.com/tools\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" tools:context=\"mraz.com.opensourcedemo.MainActivity\"&gt; &lt;android.support.v4.view.ViewPager android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:id=\"@+id/viewpager\" &gt; &lt;/android.support.v4.view.ViewPager&gt;&lt;/RelativeLayout&gt; 代码内容MainActivity.java 1234567891011121314151617181920212223242526272829package mraz.com.opensourcedemo;import android.support.v4.view.ViewPager;import android.support.v4.widget.ViewDragHelper;import android.support.v7.app.AppCompatActivity;import android.os.Bundle;import android.util.Log;import android.view.View;import android.view.Window;import java.util.ArrayList;public class MainActivity extends AppCompatActivity { ArrayList&lt;String&gt; sourceList; private static final float MIN_SCALE = 0.5f; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); ViewPager viewPager = (ViewPager) findViewById(R.id.viewpager); MyPagerAdapter myPagerAdapter = new MyPagerAdapter(getSupportFragmentManager()); viewPager.setAdapter(myPagerAdapter); }} Adapter类 1234567891011121314151617181920212223242526272829303132333435package mraz.com.opensourcedemo;import android.support.v4.app.Fragment;import android.support.v4.app.FragmentManager;import android.support.v4.app.FragmentPagerAdapter;/** * Created by Mraz on 2016/7/8. */public class MyPagerAdapter extends FragmentPagerAdapter { public static final String[] titles = {\"Android\",\" Pet\",\"Gift\"}; public MyPagerAdapter(FragmentManager fm) { super(fm); } @Override public Fragment getItem(int position) { switch (position) { case 0: return new FirstFragment(); case 1: return new SecondFragment(); case 2: return new ThreeFragment(); } return null; } @Override public int getCount() { return 3; }} MyPagerAdapter 继承FragmentPagerAdapter，当创建这个类并继承FragmentPagerAdapter的时候，AS会提示开发者需要实现两个方法，并且要添加一个构造函数，getItem就是根据位置返回对应的Fragment，getCount就是返回页面数，这里我是直接返回的对应的内容，数目也是固定的，在实际开发过程中，使用ArrayList等数据结构来传递合适的参数，可以更灵活的设置Adapter的内容，使ViewPager的内容更丰富。这里的 FirstFragment，SecondFragment，ThreeFragment内容只是一个简单的图片资源，对应的布局文件也比较简单，不贴代码了。 实际效果 添加PageTransformer代码内容 1234567891011121314151617181920212223242526272829303132333435363738394041private static final float MIN_SCALE = 0.5f;...viewPager.setPageTransformer(true, new ViewPager.PageTransformer() { @Override public void transformPage(View view, float position) { int pageWidth = view.getWidth(); if (position &lt; -1) { // [-Infinity,-1) // This page is way off-screen to the left. view.setAlpha(0); } else if (position &lt;= 0) { // [-1,0] // Use the default slide transition when moving to the left page view.setAlpha(1 + position); view.setTranslationX(0); float scaleFactor = MIN_SCALE + (1 - MIN_SCALE) * (1 - Math.abs(position)); view.setScaleX(scaleFactor); view.setScaleY(scaleFactor); } else if (position &lt;= 1) { // (0,1] // Fade the page out. view.setAlpha(1 - position); // Counteract the default slide transition view.setTranslationX(pageWidth * -position); // Scale the page down (between MIN_SCALE and 1) float scaleFactor = MIN_SCALE + (1 - MIN_SCALE) * (1 - Math.abs(position)); view.setScaleX(scaleFactor); view.setScaleY(scaleFactor); } else { // (1,+Infinity] // This page is way off-screen to the right. view.setAlpha(0); } }}); 上面是参照例子写的一个页面切换效果，主要关注的是透明度和大小的改变，在页面切换的过程中，对于离开的页面变透明，变小，进入的页面变明显，变大。看下ViewPager.PageTransformer这个接口 1234567891011121314151617181920/** * A PageTransformer is invoked whenever a visible/attached page is scrolled. * This offers an opportunity for the application to apply a custom transformation * to the page views using animation properties. * * &lt;p&gt;As property animation is only supported as of Android 3.0 and forward, * setting a PageTransformer on a ViewPager on earlier platform versions will * be ignored.&lt;/p&gt; */public interface PageTransformer { /** * Apply a property transformation to the given page. * * @param page Apply the transformation to this page * @param position Position of page relative to the current front-and-center * position of the pager. 0 is front and center. 1 is one full * page position to the right, and -1 is one page position to the left. */ public void transformPage(View page, float position);} 只需要实现一个方法transformPage，传入的参数，第一个参数是页面视图，第二个参数很重要，指的是当前页面所处的一种状态，根据position来判断，我们添加的所有效果，都是要依据这个值来做处理，当我们滑动页面的时候，这个值在不停的变化，并且不同的page的值不相同。 取值 含义 [-Infinity,-1) 这个范围的视图已经看不见了 [-1,0] 即将退出界面的page的变化范围，从0慢慢变成-1 [0,1] 即将进入界面的page的变化范围，从1慢慢变成0 (1,+Infinity] 这个范围的视图已经看不见了 可以把这个取值范围和数据概念——数轴——联系起来，就比较容易理解了，通过上面这个过场和下面的实际效果图，应该可以看出一二，通过这个例子，也可以尝试着实现自定义的过场效果 实际效果 添加OnPageChangeListener代码内容 12345678910111213141516viewPager.addOnPageChangeListener(new ViewPager.OnPageChangeListener() { @Override public void onPageScrolled(int position, float positionOffset, int positionOffsetPixels) { Log.e(TAG, \"onPageScrolled position = \" + position + \" positionOffset = \" + positionOffset + \" positionOffsetPixels = \" + positionOffsetPixels); } @Override public void onPageSelected(int position) { Log.e(TAG, \"onPageSelected position = \" + position); } @Override public void onPageScrollStateChanged(int state) { Log.e(TAG, \"onPageScrollStateChanged state = \" + state); }}); 可以看到当滑动页面的时候，会有一大串的Log打印出来 看下OnPagerChangeListener这个接口的定义 123456789101112131415161718192021222324252627282930313233343536/** * Callback interface for responding to changing state of the selected page. */public interface OnPageChangeListener { /** * This method will be invoked when the current page is scrolled, either as part * of a programmatically initiated smooth scroll or a user initiated touch scroll. * * @param position Position index of the first page currently being displayed. * Page position+1 will be visible if positionOffset is nonzero. * @param positionOffset Value from [0, 1) indicating the offset from the page at position. * @param positionOffsetPixels Value in pixels indicating the offset from position. */ public void onPageScrolled(int position, float positionOffset, int positionOffsetPixels); /** * This method will be invoked when a new page becomes selected. Animation is not * necessarily complete. * * @param position Position index of the new selected page. */ public void onPageSelected(int position); /** * Called when the scroll state changes. Useful for discovering when the user * begins dragging, when the pager is automatically settling to the current page, * or when it is fully stopped/idle. * * @param state The new scroll state. * @see ViewPager#SCROLL_STATE_IDLE * @see ViewPager#SCROLL_STATE_DRAGGING * @see ViewPager#SCROLL_STATE_SETTLING */ public void onPageScrollStateChanged(int state);} 值得的一提的是 positionOffset 这个参数可以在onPageScrolled回调中拿到，而这个数值呢 就是和我们上面自定义过场的时候用到的 transformPage方法中传入的第二个参数position 有联系，只是这里的positionOffset取值范围为[0, 1)，上面的position中取值范围更广，但是从实际上来看，对我们影响比较大的就是当前切换的两个Page，也就是[-1,1]这个取值范围，所谓的负值可以理解成是相对概念，所以，这两个变量之间是存在关系的，如果不理解上面PageTransformer， 可以结合这个positionOffset变量的打印值加以理解。","link":"/2016/07/09/《Android 基础（十七）》 ViewPager/"},{"title":"《Android 基础（十三）》 shape","text":"介绍 简单来说，shape就是用来在xml文件中定义形状，代码解析之后就可以当做Drawable一样使用 官方说明 关于shape定义的drawable 文件位置：res/drawable/filename.xml 编译资源类型：*GradientDrawable* 文件引用： In Java: R.drawable.filename In XML: @[package:]drawable/filename 语法： 123456789101112131415161718192021222324252627282930313233343536&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;shape xmlns:android=\"http://schemas.android.com/apk/res/android\" android:shape=[\"rectangle\" | \"oval\" | \"line\" | \"ring\"] &gt; &lt;corners android:radius=\"integer\" android:topLeftRadius=\"integer\" android:topRightRadius=\"integer\" android:bottomLeftRadius=\"integer\" android:bottomRightRadius=\"integer\" /&gt; &lt;gradient android:angle=\"integer\" android:centerX=\"integer\" android:centerY=\"integer\" android:centerColor=\"integer\" android:endColor=\"color\" android:gradientRadius=\"integer\" android:startColor=\"color\" android:type=[\"linear\" | \"radial\" | \"sweep\"] android:useLevel=[\"true\" | \"false\"] /&gt; &lt;padding android:left=\"integer\" android:top=\"integer\" android:right=\"integer\" android:bottom=\"integer\" /&gt; &lt;size android:width=\"integer\" android:height=\"integer\" /&gt; &lt;solid android:color=\"color\" /&gt; &lt;stroke android:width=\"integer\" android:color=\"color\" android:dashWidth=\"integer\" android:dashGap=\"integer\" /&gt;&lt;/shape&gt; 这里只做简单的描述，主要看看使用方式。关于元素的详细说明，请看 shape说明 基本使用矩形填充（solid）123456&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;shape xmlns:android=\"http://schemas.android.com/apk/res/android\" android:shape=\"rectangle\"&gt; &lt;!--填充颜色 --&gt; &lt;solid android:color=\"@color/colorAccent\" /&gt;&lt;/shape&gt; 描边（stroke）12345678910111213141516&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;shape xmlns:android=\"http://schemas.android.com/apk/res/android\" android:shape=\"rectangle\"&gt; &lt;!--填充颜色 --&gt; &lt;solid android:color=\"@color/colorAccent\" /&gt; &lt;!--描边颜色--&gt; &lt;!--android:dashGap 虚线间距，这里设置为0则显示的为实线--&gt; &lt;!--android:dashWidth 虚线宽度--&gt; &lt;stroke android:width=\"3dp\" android:color=\"@color/colorPrimaryDark\" android:dashGap=\"0dp\" android:dashWidth=\"10dp\" /&gt;&lt;/shape&gt; 圆角（corner）1234567891011121314151617181920212223242526&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;shape xmlns:android=\"http://schemas.android.com/apk/res/android\" android:shape=\"rectangle\"&gt; &lt;!--填充颜色 --&gt; &lt;solid android:color=\"@color/colorAccent\" /&gt; &lt;!--描边颜色--&gt; &lt;!--android:dashGap 虚线间距，这里设置为0则显示的为实线--&gt; &lt;!--android:dashWidth 虚线宽度--&gt; &lt;stroke android:width=\"3dp\" android:color=\"@color/colorPrimaryDark\" android:dashGap=\"4dp\" android:dashWidth=\"10dp\" /&gt; &lt;!--圆角--&gt; &lt;!--android:randius 设置4个叫的圆角半径,会被特定的圆角设定覆盖--&gt; &lt;!--android:bottomLeftRadius 左下角的圆角半径--&gt; &lt;!--android:bottomRightRadius 右下角的圆角半径--&gt; &lt;!--android:topLeftRandius 左上角的圆角半径--&gt; &lt;!--android:topRightRadius 右上角的圆角半径--&gt; &lt;corners android:bottomLeftRadius=\"60dp\" android:radius=\"30dp\" android:topRightRadius=\"120dp\" /&gt;&lt;/shape&gt; 渐变（gradient）：linear123456789101112131415161718192021222324252627282930&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;shape xmlns:android=\"http://schemas.android.com/apk/res/android\" android:shape=\"rectangle\"&gt; &lt;!--描边颜色--&gt; &lt;!--android:dashGap 虚线间距，这里设置为0则显示的为实线--&gt; &lt;!--android:dashWidth 虚线宽度--&gt; &lt;stroke android:width=\"3dp\" android:color=\"@color/colorPrimaryDark\" android:dashGap=\"4dp\" android:dashWidth=\"10dp\" /&gt; &lt;!--圆角--&gt; &lt;!--android:randius 设置4个叫的圆角半径--&gt; &lt;!--android:bottomLeftRadius 左下角的圆角半径--&gt; &lt;!--android:bottomRightRadius 右下角的圆角半径--&gt; &lt;!--android:topLeftRandius 左上角的圆角半径--&gt; &lt;!--android:topRightRadius 右上角的圆角半径--&gt; &lt;corners android:bottomLeftRadius=\"60dp\" android:radius=\"30dp\" android:topRightRadius=\"120dp\" /&gt; &lt;!--渐变--&gt; &lt;gradient android:angle=\"45\" android:centerColor=\"@color/stone\" android:endColor=\"@color/pink\" android:startColor=\"@color/yellow\" /&gt;&lt;/shape&gt; 渐变（gradient）：radial1234567&lt;gradient android:angle=\"90\" android:startColor=\"@color/colorPrimary\" android:centerColor=\"@color/pink\" android:endColor=\"@color/yellow\" android:gradientRadius=\"400dp\" android:type=\"radial\"/&gt; 渐变（gradient）：sweep123456&lt;gradient android:startColor=\"@color/colorPrimary\" android:centerColor=\"@color/pink\" android:endColor=\"@color/yellow\" android:gradientRadius=\"400dp\" android:type=\"sweep\"/&gt; 圆形正圆1234567891011&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;shape xmlns:android=\"http://schemas.android.com/apk/res/android\"android:shape=\"oval\"&gt;&lt;gradient android:centerColor=\"@color/pink\" android:endColor=\"@color/yellow\" android:startColor=\"@color/colorPrimary\" /&gt;&lt;size android:width=\"400dp\" android:height=\"400dp\" /&gt;&lt;/shape&gt; 椭圆123456789&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;shape xmlns:android=\"http://schemas.android.com/apk/res/android\"android:shape=\"oval\"&gt;&lt;gradient android:angle=\"90\" android:centerColor=\"@color/pink\" android:endColor=\"@color/yellow\" android:startColor=\"@color/colorPrimary\" /&gt;&lt;/shape&gt; 线条1234567&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;shape xmlns:android=\"http://schemas.android.com/apk/res/android\" android:shape=\"line\"&gt; &lt;stroke android:width=\"9dp\" android:color=\"@color/pink\" /&gt;&lt;/shape&gt; 环形1234567891011&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;shape xmlns:android=\"http://schemas.android.com/apk/res/android\" android:shape=\"ring\" android:innerRadius=\"100dp\" android:thickness=\"50dp\" android:useLevel=\"false\" &gt; &lt;gradient android:startColor=\"@color/colorAccent\" android:endColor=\"@color/yellow\" android:centerColor=\"@color/pink\"/&gt;&lt;/shape&gt; android:useLevel=”false”这个属性值一定要设置成false，根据google官网上的解释： 以下属性只能在 android:shape=&quot;ring&quot; 的时候使用： 属性 意义 android:innerRadius 尺寸，内环的半径 android:thickness 尺寸，环的厚度 android:innerRadiusRatio 浮点型，以环的宽度比率来表示内环的径， 例如，如果android:innerRadiusRatio=5，表示内环半径等于的宽度除以5，这个值是可以被android:innerRadius的值覆盖，默认9. android:thicknessRatio 浮点型，以环的宽度比率来表示环的度，例如，如果android:thicknessRatio=2， 那么环的厚度就等于的宽度除以2。这个值是可以被android:thickness覆盖的，默认值是3. android:useLevel boolean值，如果当做LevelListDrawable使用时值为true，否则为false.这个值一般false,否则你的环可能不会出现 其他说明这些自己定义的shape为根节点的drawable xml文件，可以用来当成背景使用在Button,TextView等视图上，同时由于可以设置size大小，也可以用来制作简单的图标等。总而言之，每个细小的东西，都有挖掘的价值，感觉这里面还有一些东西我没有注意到，还要好好的看一下文档。 最后，google镜像网站，xsoftlab，当然有条件的建议使用Google官网。","link":"/2016/07/04/《Android 基础（十三）》 shape/"},{"title":"《Android 基础（十九）》 CoordinatorLayout","text":"介绍CoordinatorLayout，中文翻译，协调布局，顾名思义，此布局中的子View之间，子View与父布局之间应该是可以协调工作的，如何协调，Behavior。 今天看下Android Studio给我们提供的一个模板Activity Android Studio创建Scrolling ActivityFile - &gt; New - &gt; Activity -&gt; Scrolling Activity 或者在New Project的时候选择初始化Activity为 Scrolling Activity Sample效果其实从上面的图已经可以看出一点效果来 Sample代码AS提供的这个Sample的关键除了布局，还是布局，主要有两个布局activity_scrolling.xml 12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;android.support.design.widget.CoordinatorLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:app=\"http://schemas.android.com/apk/res-auto\" xmlns:tools=\"http://schemas.android.com/tools\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:fitsSystemWindows=\"true\" tools:context=\"mraz.com.coordinatorlayoutdemo.ScrollingActivity\"&gt; &lt;android.support.design.widget.AppBarLayout android:id=\"@+id/app_bar\" android:layout_width=\"match_parent\" android:layout_height=\"@dimen/app_bar_height\" android:fitsSystemWindows=\"true\" android:theme=\"@style/AppTheme.AppBarOverlay\"&gt; &lt;android.support.design.widget.CollapsingToolbarLayout android:id=\"@+id/toolbar_layout\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:fitsSystemWindows=\"true\" app:contentScrim=\"?attr/colorPrimary\" app:layout_scrollFlags=\"scroll|exitUntilCollapsed\"&gt; &lt;android.support.v7.widget.Toolbar android:id=\"@+id/toolbar\" android:layout_width=\"match_parent\" android:layout_height=\"?attr/actionBarSize\" app:layout_collapseMode=\"pin\" app:popupTheme=\"@style/AppTheme.PopupOverlay\" /&gt; &lt;/android.support.design.widget.CollapsingToolbarLayout&gt; &lt;/android.support.design.widget.AppBarLayout&gt; &lt;include layout=\"@layout/content_scrolling\" /&gt; &lt;android.support.design.widget.FloatingActionButton android:id=\"@+id/fab\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:layout_margin=\"@dimen/fab_margin\" android:src=\"@android:drawable/ic_dialog_email\" app:layout_anchor=\"@id/app_bar\" app:layout_anchorGravity=\"bottom|end\" /&gt;&lt;/android.support.design.widget.CoordinatorLayout&gt; 这个布局中又包含了另外一个布局content_scrolling.xml 1234567891011121314151617&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;android.support.v4.widget.NestedScrollView xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:app=\"http://schemas.android.com/apk/res-auto\" xmlns:tools=\"http://schemas.android.com/tools\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" app:layout_behavior=\"@string/appbar_scrolling_view_behavior\" tools:context=\"mraz.com.coordinatorlayoutdemo.ScrollingActivity\" tools:showIn=\"@layout/activity_scrolling\"&gt; &lt;TextView android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:layout_margin=\"@dimen/text_margin\" android:text=\"@string/large_text\" /&gt;&lt;/android.support.v4.widget.NestedScrollView&gt; 一般都是这样的使用方式，考虑到它之所以这样子将两个布局分开，主要是方便开发者替换自己的实现内容，也就是content_scrolling.xml中的内容，而activity_scrolling.xml文件中定义的一些内容可以理解成使用的框架，这样子就可以理解为什么AS在提供Sample的时候会使用两个布局。android.support.design.widget.CoordinatorLayout |———-&gt;AppBarLayout |—————&gt;CollapsingToolbarLayout |———————&gt;ToolBar |———-&gt;NestedScrollView |———-&gt;FloatingActionButton 关于这几个LayoutAppBarLayoutAppBarLayout是一个垂直方向上的LinearLayout，它实现了如滚动手势等材料设计app bar的特性。AppBarLayout的子View必须通过LayoutParams#setScrollFlags(int)或者xml中的属性值app:layout_scrollFlags 提供他们想要的滚动行为。这个Layout基本上只能在CoordinatorLayout下使用，如果在其他的ViewGroup下使用的话，很多功能都不能使用。AppBarLaytou同时需要一个和他配合的可以滚动的视图，通过ScrollingViewBehavior来互相绑定，如Sample中的 app:layout_behavior=”@string/appbar_scrolling_view_behavior” 指代的就是 android.support.design.widget.AppBarLayout$ScrollingViewBehavior 或者指定一个其他的Behavior，但是这个字符串要是这个类的全类名。这里的这个ScrollingViewBehavior在AppBarLayout.java中定义，继承HeaderScrollingViewBehavior，而它就继承ViewOffsetBehavior&lt; View&gt;，而它又继承自CoordinatorLayout.Behavior&lt; V&gt;，所以最后的父类还是这个Behavior。这里暂时先不看，后面我自己学习之后再来另写一篇，应该有点搞头。 layout_scrollFlags有几个对应的属性 属性名 意义 scroll 要滚动出屏幕的view都需要设置这个flag-没有设置这个flag的view将被固定在屏幕顶部 enterAlways 所有的下滑动作都会导致该视图的出现，启“快速返回”模式 enterAlwaysCollapsed 定义了一个最小高度（minHeight）同enterAlways也定义了，那么view将在到达这个最小高度的时候开始示，并且从这个时候开始慢慢展开，当滚动到顶部的时候展开完 exitUntilCollapsed 当你定义了一个minHeight，这个view将在动到达这个最小高度的时候消失 CollapsingToolbarLayoutCollapsingToolbarLayout是ToolBar的封装类，实现可伸缩的Toolbar，它被设计用来当做AppBarLayout的直接子布局，CollapsingToolbarLayout 包含如下特性： Collapsing title当toolbar伸展开时显示的相对较大，当移除屏幕的时候会慢慢变小，过setTitle(CharSequence)设置，title的外观可以用collapsedTextAppearance和expandedTextAppearance分别设置 Content Scrim当滚动位置达到一个固定值的时候出现或者消失的内容，setContentScrim(Drawable)或者属性值app:contentScrim设置 Status bar scrim当滚动值达到一个固定值的时候出现在状态栏后面的内容，通setStatusBarScrim(Drawable)，这个特性只能在L版本上实现，并且要设置android:fitsSystemWindows=“true” Parallax scrolling children视差滚动子布局，当内容滚动的时候，子布局中的内容可以跟着一起动滚动视差因子可以通过setParallaxMultiplier(float)或layout_collapseParallaxMultiplier设置，与此对应的折叠模式要成layout_collapseMode=“parallax”。Sample中设置的Toolbarlayout_collapseMode为”pin” 属性 用法 pin CollapsingToolbarLayout完全收缩后，Toolbar还可以保留在幕上 parallax 在内容滚动时，CollapsingToolbarLayout中的View（比ImageView)也可以同时滚动，实现视差滚动效果，通常layout_collapseParallaxMultiplier(设置视差因子)搭配使用 一般Toolbar设置为pin，CollapsingToolbarLayout中的其他视图可尝试使用parallax属性 Pinned position children上面已经讲解了，如Sample中的Toolbar Sample代码修改实战CollapsingToolbarLayout中加个图片看看1234567891011121314151617181920212223&lt;android.support.design.widget.CollapsingToolbarLayout android:id=\"@+id/toolbar_layout\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:fitsSystemWindows=\"true\" app:contentScrim=\"?attr/colorPrimary\" app:layout_scrollFlags=\"scroll|enterAlways\"&gt; &lt;ImageView android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:scaleType=\"centerCrop\" android:src=\"@mipmap/bg\" app:layout_collapseMode=\"parallax\" app:layout_collapseParallaxMultiplier=\"0.7\" /&gt; &lt;android.support.v7.widget.Toolbar android:id=\"@+id/toolbar\" android:layout_width=\"match_parent\" android:layout_height=\"?attr/actionBarSize\" app:layout_collapseMode=\"pin\" app:popupTheme=\"@style/AppTheme.PopupOverlay\" /&gt; &lt;/android.support.design.widget.CollapsingToolbarLayout&gt; 效果： CollapsingToolbarLayout的标题颜色变变12345678910&lt;android.support.design.widget.CollapsingToolbarLayout android:id=\"@+id/toolbar_layout\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:fitsSystemWindows=\"true\" app:title=\"Beautiful Title\" app:expandedTitleTextAppearance=\"@style/MyExpandedText\"//只定义一个字体颜色 app:collapsedTitleTextAppearance=\"@style/MyCollapsedText\"//同上 app:contentScrim=\"?attr/colorPrimaryDark\" app:layout_scrollFlags=\"scroll|exitUntilCollapsed\"&gt; 效果： 备注：当我直接在xml文件中直接在app:expandedTitleTextAppearance后面设置color的时候，得到的结果不是改变字体颜色，而是改变了整个背景的颜色，你们可以试试 FloatingActionButton的位置改改12345678&lt;android.support.design.widget.FloatingActionButton android:id=\"@+id/fab\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:layout_margin=\"@dimen/fab_margin\" android:src=\"@android:drawable/ic_dialog_email\" app:layout_anchor=\"@id/toolbar\" app:layout_anchorGravity=\"bottom|center\" /&gt; 换个坐标系，也就是layout_anchor就是基准点，相对于它在bottom和center是相对于这个基准点的位置效果：","link":"/2016/08/13/《Android 基础（十九）》 CoordinatorLayout/"},{"title":"《Android 基础（十五）》 Alert Dialog","text":"简介 The AlertDialog class allows you to build a variety of dialog designs and is often the only dialog class you’ll need. there are three regions of an alert dialog: 1.TitleThis is optional and should be used only when the content area is occupied by a detailed message, a list, or custom layout. If you need to state a simple message or question (such as the dialog in figure 1), you don’t need a title. 2.Content areaThis can display a message, a list, or other custom layout. 3.Action buttonsThere should be no more than three action buttons in a dialog. 一般的AlertDialog分为2个部分，头部，内容和Action Button，头部包含图标和文字，内容部分可以自定义，也可以使用一些常见的列表，单选项，多选项等内容，Action Button就是常见的OK啊， Cancel啊等等。 类结构AlertDialog 重点关注一下Builder类的结构 关于这些方法的使用说明，这里不做一一介绍，后面通过实例可以看出端倪，不过可以通过查阅API文档熟悉一下，AlertDialog.Builder 基本使用Simple AlertDialog代码12345678910111213141516171819202122232425262728293031private void showSimpleAlertDialog() { //创建alertdialog builder AlertDialog.Builder builder = new AlertDialog.Builder(mContext); //设置图标，标题，消息内容 builder.setIcon(getResources().getDrawable(R.drawable.ic_adb_black_24dp)) .setTitle(R.string.title) .setMessage(R.string.content); //设置Acton Buttons builder.setNegativeButton(R.string.cancel, new DialogInterface.OnClickListener() { @Override public void onClick(DialogInterface dialogInterface, int i) { Toast.makeText(mContext, \"Cancal is clicked\", Toast.LENGTH_SHORT).show(); } }); builder.setPositiveButton(R.string.ok, new DialogInterface.OnClickListener() { @Override public void onClick(DialogInterface dialogInterface, int i) { Toast.makeText(mContext, \"OK is clicked\", Toast.LENGTH_SHORT).show(); } }); builder.setNeutralButton(R.string.reminder, new DialogInterface.OnClickListener() { @Override public void onClick(DialogInterface dialogInterface, int i) { Toast.makeText(mContext, \"Remind me later is clicked\", Toast.LENGTH_SHORT).show(); } }); //显示alert dialog 这个是AlertDialog的show()方法是等价的 builder.show();} 效果 备注_ Action Button 意义 setNegativeButton 做取消、返回等操作，如Cancel setPositiveButton 做确认、提交等操作，如OK setNeutralButton 做中性操作，如Update Later AlertDialog.Builder中的show()方法和AlertDialog的show()方法是等价的 AlertDialog With Array代码12345678910111213141516171819202122public void showAlertDialogWithArray() { AlertDialog.Builder builder = new AlertDialog.Builder(mContext); builder.setIcon(getResources().getDrawable(R.drawable.ic_assessment_black_24dp)) .setTitle(R.string.title) .setItems(R.array.dialoglist, new DialogInterface.OnClickListener() { @Override public void onClick(DialogInterface dialogInterface, int i) { switch (i) { case 0: showTwo.setBackgroundResource(R.color.pink); break; case 1: showTwo.setBackgroundResource(R.color.stone); break; case 2: showTwo.setBackgroundResource(R.color.yellow); break; } } }); builder.create().show();} 效果 备注 方法 含义 setItems 通过array来设置dialog的内容 setAdapter 通过ListAdapter来设置dialog的内容 ListAdapter可以显示的内容应该比Array要丰富，但是现在开源库很多，针对Dialog的美观的开源库也不少，一般开发过程中会使用现成的。 AlertDialog With MultiChoice代码1234567891011121314151617181920212223public void showAlertDialogWithMutiChoice() { final ArrayList&lt;String&gt; selecteditems = new ArrayList&lt;&gt;(); AlertDialog.Builder builder = new AlertDialog.Builder(mContext); builder.setIcon(R.drawable.ic_event_seat_black_24dp) .setTitle(R.string.title) .setMultiChoiceItems(R.array.fruits, null, new DialogInterface.OnMultiChoiceClickListener() { @Override public void onClick(DialogInterface dialogInterface, int which, boolean isChecked) { if (isChecked) { selecteditems.add(getResources() .getStringArray(R.array.fruits)[which]); Toast.makeText(mContext, selecteditems.toString(), Toast.LENGTH_SHORT).show(); } else { selecteditems.remove(getResources() .getStringArray(R.array.fruits)[which]); Toast.makeText(mContext, selecteditems.toString(), Toast.LENGTH_SHORT).show(); } } }); builder.create().show();} 效果 AlertDialog With Single Choice代码123456789101112131415public void showAlertDialogWithSingleChoice() { AlertDialog.Builder builder = new AlertDialog.Builder(mContext); builder.setIcon(R.drawable.ic_build_black_24dp) .setTitle(R.string.title); builder.setSingleChoiceItems(R.array.places, -1, new DialogInterface.OnClickListener() { @Override public void onClick(DialogInterface dialogInterface, int i) { Toast.makeText(mContext, getResources().getStringArray(R.array.places)[i] + \" is selected\", Toast.LENGTH_SHORT).show(); } }); builder.create().show();} 效果 Custom Alert Dialog代码1234567public void showCustomAlertDialog() { AlertDialog.Builder builder = new AlertDialog.Builder(mContext); builder.setIcon(R.drawable.ic_assessment_black_24dp).setTitle(R.string.login); builder.setView(R.layout.custom_alert); builder.setCustomTitle(LayoutInflater.from(mContext).inflate(R.layout.custom_title , null )); builder.create().show();} 自定义布局文件Title自定义 12345678910111213141516171819202122&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" android:layout_width=\"match_parent\" android:layout_height=\"60dp\" android:background=\"@drawable/shape_title\" android:orientation=\"horizontal\"&gt; &lt;ImageView android:layout_width=\"60dp\" android:layout_height=\"60dp\" android:paddingLeft=\"20dp\" android:src=\"@drawable/ic_adb_black_24dp\" /&gt; &lt;TextView android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:layout_gravity=\"center_vertical\" android:layout_marginLeft=\"40dp\" android:text=\"Custom Title\" android:textSize=\"15pt\" android:textStyle=\"bold\" /&gt;&lt;/LinearLayout&gt; Content Area自定义 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:app=\"http://schemas.android.com/apk/res-auto\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:layout_margin=\"@dimen/activity_horizontal_margin\" android:orientation=\"vertical\"&gt; &lt;android.support.design.widget.TextInputLayout android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:layout_marginTop=\"10dp\"&gt; &lt;EditText android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:hint=\"UserName\" /&gt; &lt;/android.support.design.widget.TextInputLayout&gt; &lt;android.support.design.widget.TextInputLayout android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" app:counterEnabled=\"true\" app:counterMaxLength=\"40\"&gt; &lt;EditText android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:fontFamily=\"sans-serif\" android:hint=\"Password\" android:inputType=\"textPassword\" /&gt; &lt;/android.support.design.widget.TextInputLayout&gt; &lt;LinearLayout android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:layout_margin=\"@dimen/activity_vertical_margin\" android:orientation=\"horizontal\"&gt; &lt;Button android:layout_width=\"wrap_content\" android:layout_height=\"match_parent\" android:layout_weight=\"1\" android:background=\"@drawable/shaperect\" android:text=\"Submit\" /&gt; &lt;Button android:layout_width=\"wrap_content\" android:layout_height=\"match_parent\" android:layout_weight=\"1\" android:background=\"@drawable/shape_two\" android:text=\"Reset\" /&gt; &lt;/LinearLayout&gt;&lt;/LinearLayout&gt; 效果 备注自定义标题栏和显示的内容，Action Button可以通过在Content中添加Button的方式来实现，丰富了Alert Dialog的显示内容，Alert Dialog中应该还有很多东西待挖掘，锄头需要挥起来~","link":"/2016/07/06/《Android 基础（十五）》 Alert Dialog/"},{"title":"《Android 基础（八）》 Palette","text":"介绍 Palette， 英文翻译，调色板，意思比较接近，Google给它的定位应该是颜色萃取器。看下Source CodePalette , A helper class to extract prominent colors from an image.A number of colors with different profiles are extracted from the image 支持的颜色类型 颜色 类型 Vibrant 有活力 Vibrant Dark 有活力 暗色 Vibrant Light 有活力 亮色 Muted 柔和 Muted Dark 柔和 暗色 Muted Light 柔和 亮色 使用方法：123456789// Synchronous 同步Palette p = Palette.from(bitmap).generate();&gt;// Asynchronous 异步&gt;Palette.from(bitmap).generate(new PaletteAsyncListener() { public void onGenerated(Palette p) { // Use generated instance } }); 举例说明布局设置activity_main.xml 12345678910111213141516171819&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:tools=\"http://schemas.android.com/tools\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:orientation=\"vertical\" tools:context=\"mraz.com.palettedemo.MainActivity\"&gt; &lt;android.support.v7.widget.Toolbar android:id=\"@+id/toolbar\" android:layout_width=\"match_parent\" android:layout_height=\"?attr/actionBarSize\" android:background=\"@color/colorPrimaryDark\"&gt;&lt;/android.support.v7.widget.Toolbar&gt; &lt;android.support.v7.widget.RecyclerView android:id=\"@+id/rv_content\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\"&gt;&lt;/android.support.v7.widget.RecyclerView&gt;&lt;/LinearLayout&gt; RecyclerView中使用Item的布局设置：card_item.xml 1234567891011121314151617&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:app=\"http://schemas.android.com/apk/res-auto\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:orientation=\"vertical\" android:padding=\"6dp\"&gt; &lt;com.makeramen.roundedimageview.RoundedImageView android:id=\"@+id/riv_content\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" app:riv_border_color=\"@color/colorAccent\" app:riv_border_width=\"1dp\" app:riv_corner_radius=\"20dp\" /&gt;&lt;/LinearLayout&gt; ActionBar上使用的menu资源：main_menu.xml 12345678910111213141516&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;menu xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:app=\"http://schemas.android.com/apk/res-auto\"&gt; &lt;item android:id=\"@+id/action_add\" android:icon=\"@drawable/ic_add_black_24dp\" android:title=\"@string/add\" app:showAsAction=\"ifRoom\" /&gt; &lt;item android:id=\"@+id/action_del\" android:icon=\"@drawable/ic_remove_black_24dp\" android:title=\"@string/del\" app:showAsAction=\"ifRoom\" /&gt;&lt;/menu&gt; 代码使用123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105package mraz.com.palettedemo;import android.graphics.Bitmap;import android.graphics.BitmapFactory;import android.graphics.Color;import android.os.Bundle;import android.support.v7.app.AppCompatActivity;import android.support.v7.graphics.Palette;import android.support.v7.widget.DefaultItemAnimator;import android.support.v7.widget.LinearLayoutManager;import android.support.v7.widget.RecyclerView;import android.support.v7.widget.Toolbar;import android.util.Log;import android.view.Menu;import android.view.MenuItem;import java.util.ArrayList;public class MainActivity extends AppCompatActivity { private final int[] resIds = {R.drawable.p_1, R.drawable.p_2, R.drawable.p_3, R.drawable.p_4, R.drawable.p_5, R.drawable.p_6, R.drawable.p_7};//资源图片Id private final String[] titles = {\"Vibrant\", \"DarkVibrant\", \"LightVibrant\", \"Muted\", \"DarkMuted\", \"LightMuted\"};//6种萃取出来的颜色对应的英文翻译 private Toolbar toolbar;//toolbar private ArrayList&lt;Integer&gt; colorList;//存储从Palette中萃取出来的6中颜色 private int clickCount = 0;//点击数 @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); colorList = new ArrayList&lt;&gt;(); toolbar = (Toolbar) findViewById(R.id.toolbar); setSupportActionBar(toolbar);//设置ActionBar RecyclerView recyclerView = (RecyclerView) findViewById(R.id.rv_content); RecyclerView.LayoutManager layoutManager = new LinearLayoutManager(this, LinearLayoutManager.HORIZONTAL, false); MyRecyclerAdapter myRecyclerAdapter = new MyRecyclerAdapter();//初始化RecyclerView recyclerView.setAdapter(myRecyclerAdapter); recyclerView.setLayoutManager(layoutManager); recyclerView.setOnScrollListener(new RecyclerView.OnScrollListener() { @Override public void onScrolled(RecyclerView recyclerView, int dx, int dy) { int offset = recyclerView.computeHorizontalScrollOffset(); int width = recyclerView.getChildAt(0).getWidth(); int current = offset / width; int secondoffset = offset % width; if (secondoffset &gt;= width / 2) { current = current + 1; } setActionBarColor(current); clickCount = 0; super.onScrolled(recyclerView, dx, dy); } });//设置recyclerView的滚动事件监听，以此来改变actionbar支持的颜色 setActionBarColor(0);//首次使用初始化 } @Override public boolean onCreateOptionsMenu(Menu menu) { getMenuInflater().inflate(R.menu.main_menu, menu);//初始化菜单资源 return super.onCreateOptionsMenu(menu); } private void setActionBarColor(int position) { Bitmap bitmap = BitmapFactory.decodeResource(getResources(), resIds[position]); Palette.PaletteAsyncListener paletteAsyncListener = new Palette.PaletteAsyncListener() { @Override public void onGenerated(Palette palette) { colorList.clear(); colorList.add(palette.getVibrantColor(Color.WHITE)); colorList.add(palette.getDarkVibrantColor(Color.WHITE)); colorList.add(palette.getLightVibrantColor(Color.WHITE)); colorList.add(palette.getMutedColor(Color.WHITE)); colorList.add(palette.getDarkMutedColor(Color.WHITE)); colorList.add(palette.getLightMutedColor(Color.WHITE));//萃取出六种颜色 toolbar.setBackgroundColor(colorList.get(0)); toolbar.setTitle(titles[0]); } }; Palette.from(bitmap).generate(paletteAsyncListener); } @Override public boolean onOptionsItemSelected(MenuItem item) { switch (item.getItemId()) { case R.id.action_add: { clickCount++; int index = clickCount % (colorList.size()); toolbar.setBackgroundColor(colorList.get(index)); //通过点击事件切换ActionBar的背景色和标题 toolbar.setTitle(titles[index]); break; } case R.id.action_del: { if (clickCount &gt; 0) clickCount--; int index = clickCount % (colorList.size()); toolbar.setBackgroundColor(colorList.get(index)); toolbar.setTitle(titles[index]); break; } } return super.onOptionsItemSelected(item); }} 关于Palette的使用分为两种：1.同步使用Palette p = Palette.from(bitmap).generate();2.异步使用 12345Palette.from(bitmap).generate(new PaletteAsyncListener() { public void onGenerated(Palette p) { // Use generated instance }}); 效果 操作 效果图 左右滑动ActionBar背景色改变 切换ActionBar背景色 API简介 Palette相关API 直接获取颜色的方法 通过创建的Palette直接获取其中的颜色，用来设置UI界面中的一些元素 获取Swatch的方法 这里获取的Swatch中的内容更丰富通过Swatch可以获取更丰富的颜色内容，如 :getTitleTextColor()getBodyTextColor()getRgb()getHsl()示例中只是使用了一部分的方法，具体的其他方法使用情况类似，根据Bitmap的颜色格，设置对应的字体颜色，UI资源颜色，可以使界面看上去更加的和谐和美好。","link":"/2016/06/26/《Android 基础（八）》 Palette/"},{"title":"《Android 基础（四十三）》 SnapHelper","text":"1. 简介 先看看英文介绍 /** Class intended to support snapping for a {@link RecyclerView}. SnapHelper tries to handle fling as well but for this to work properly, the {@link RecyclerView.LayoutManager} must implement the {@link ScrollVectorProvider} interface or you should override {@link #onFling(int, int)} and handle fling manually. */ 可以看出SnapHelper是对RecyclerView的一种拓展功能，支持snapping。SnapHelper通过处理RecyclerView的fling，来达到要展示的效果，但是这需要一个前提条件，就是RecyclerView的LayoutManager必须实现ScrollVectorProvider接口或者手动实现onFling接口，自己实现fling处理。 SnapHelper的实现原理是监听RecyclerView.OnFlingListener中的onFling接口。LinearSnapHelper&amp;PagerSnapHelper是抽象类SnapHelper的具体实现。区别在于：LinerSnapHelper，可滑动多页，居中显示；PagerSnapHelper，每次只能滑动一页，居中显示； 2. 基本实现2.1 横向LinearSnapHelper1234567LinearLayoutManager llm = new LinearLayoutManager(this, LinearLayoutManager.HORIZONTAL, false);CardAdapter cardAdapter = new CardAdapter(this);LinearSnapHelper linearSnapHelper = new LinearSnapHelper();mRvContent.setLayoutManager(llm);mRvContent.setAdapter(cardAdapter);linearSnapHelper.attachToRecyclerView(mRvContent); 2.2 纵向LinearSnapHelper1234567LinearLayoutManager llm = new LinearLayoutManager(this, LinearLayoutManager.VERTICAL, false);CardAdapter cardAdapter = new CardAdapter(this);LinearSnapHelper linearSnapHelper = new LinearSnapHelper();mRvContent.setLayoutManager(llm);mRvContent.setAdapter(cardAdapter);linearSnapHelper.attachToRecyclerView(mRvContent); 2.3 PagerSnapHelper(以横向为例)1234567LinearLayoutManager llm = new LinearLayoutManager(this, LinearLayoutManager.HORIZONTAL, false);CardAdapter cardAdapter = new CardAdapter(this);PagerSnapHelper pagerSnapHelper = new PagerSnapHelper();mRvContent.setLayoutManager(llm);mRvContent.setAdapter(cardAdapter);pagerSnapHelper.attachToRecyclerView(mRvContent); 一般步骤： 创建SnapHelper； attachToRecyclerView。 3. 源码分析 SnapHelper源码结构： SnapHelper是一个抽象类，无构造方法。其中有三个抽象方法是需要子类去实现的 方法名 | 描述 ---------------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------- calculateDistanceToFinalSnap | 计算第二个参数对应的ItemView当前的坐标与需要对齐的坐标之间的距离。返回一个int[2]数组，分别对应x轴和y轴方向上的距离 findSnapView | 找到最接近对齐位置的view，该view称为SanpView，对应的position称为SnapPosition。如果返回null，就表示没有需要对齐的View，也就不会做滚动对齐调整 findTargetSnapPosition | 根据Fling操作的速率（参数velocityX和参数velocityY）找到需要滚动到的targetSnapPosition，该位置对应的View就是targetSnapView。如果找不到targetSnapPosition，就返回RecyclerView.NO_POSITION3.1 attachToRecyclerView12345678910111213141516public void attachToRecyclerView(@Nullable RecyclerView recyclerView) throws IllegalStateException { if (mRecyclerView == recyclerView) { return; // nothing to do } if (mRecyclerView != null) { destroyCallbacks(); } mRecyclerView = recyclerView; if (mRecyclerView != null) { setupCallbacks(); mGravityScroller = new Scroller(mRecyclerView.getContext(), new DecelerateInterpolator()); snapToTargetExistingView(); }} 1.判断绑定的RecyclerView 和之前的是否相同，不重复绑定； 2.如果传入的RecyclerView不为空，则执行destoryCallbacks(), 移除滚动监听和onFlingListener 1234private void destroyCallbacks() { mRecyclerView.removeOnScrollListener(mScrollListener); mRecyclerView.setOnFlingListener(null); } 3.赋值成员变量mRecyclerView 4.setupCallbacks()和destoryCallbacks()对应 12345678private void setupCallbacks() throws IllegalStateException { //如果onFlingListener已经设置过，则抛出异常 if (mRecyclerView.getOnFlingListener() != null) { throw new IllegalStateException(&quot;An instance of OnFlingListener already set.&quot;); } mRecyclerView.addOnScrollListener(mScrollListener); mRecyclerView.setOnFlingListener(this); } 5.创建mGravityScroller 6.snapToTargetExistingView() 这个方法在这里调用一次，其实更关键的调用地方是在OnScrollListener中 12345678910111213141516171819202122// Handles the snap on scroll case.private final RecyclerView.OnScrollListener mScrollListener = new RecyclerView.OnScrollListener() { boolean mScrolled = false; @Override public void onScrollStateChanged(RecyclerView recyclerView, int newState) { super.onScrollStateChanged(recyclerView, newState); if (newState == RecyclerView.SCROLL_STATE_IDLE &amp;&amp; mScrolled) { mScrolled = false; //当滑动状态为idle状态时并且刚结束滚动 snapToTargetExistingView(); } } @Override public void onScrolled(RecyclerView recyclerView, int dx, int dy) { if (dx != 0 || dy != 0) { mScrolled = true; } } }; 12345678910111213141516171819void snapToTargetExistingView() { if (mRecyclerView == null) { return; } LayoutManager layoutManager = mRecyclerView.getLayoutManager(); if (layoutManager == null) { return; } //找到SnapView View snapView = findSnapView(layoutManager); if (snapView == null) { return; } //计算偏移量然后平滑的滑动过去 int[] snapDistance = calculateDistanceToFinalSnap(layoutManager, snapView); if (snapDistance[0] != 0 || snapDistance[1] != 0) { mRecyclerView.smoothScrollBy(snapDistance[0], snapDistance[1]); }} 3.2 onFling Fling操作： 手指在屏幕上滑动RecyclerView后松手，RecyclerView中的内容会靠着惯性继续往之前滑动的方向继续滚动直到停止，这个过程叫做Fling。Fling操作从手指离开屏幕瞬间被触发，在滚动停止时结束。 刚才在setupCallbacks()中设置的onFlingerListener 123456789101112131415public boolean onFling(int velocityX, int velocityY) { LayoutManager layoutManager = mRecyclerView.getLayoutManager(); if (layoutManager == null) { return false; } RecyclerView.Adapter adapter = mRecyclerView.getAdapter(); if (adapter == null) { return false; } //获取触发fling的最小速度 int minFlingVelocity = mRecyclerView.getMinFlingVelocity(); //横向或者纵向必须有一个滑动速度可以触发fling，snapFromFling和上面滚动监听器中的实现思路类似 return (Math.abs(velocityY) &gt; minFlingVelocity || Math.abs(velocityX) &gt; minFlingVelocity) &amp;&amp; snapFromFling(layoutManager, velocityX, velocityY);} 123456789101112131415161718192021222324private boolean snapFromFling(@NonNull LayoutManager layoutManager, int velocityX, int velocityY) { //这就是为何前文中提到需要实现ScrollVectorProvider否则旧得自己实现onFling接口 if (!(layoutManager instanceof ScrollVectorProvider)) { return false; } //创建scroller RecyclerView.SmoothScroller smoothScroller = createSnapScroller(layoutManager); if (smoothScroller == null) { return false; } //找到目标snap位置 int targetPosition = findTargetSnapPosition(layoutManager, velocityX, velocityY); if (targetPosition == RecyclerView.NO_POSITION) { return false; } //平滑的滚动过去 smoothScroller.setTargetPosition(targetPosition); layoutManager.startSmoothScroll(smoothScroller); return true;} 有兴趣的盆友可以去查阅下LinearSnapHelper和PagerSnapHelper的源码。 推荐源码阅读网站 androidxref.com 4. 源码 RecyclerViewGallery 5. 推荐开源库 RecyclerViewSnap","link":"/2017/09/16/《Android 基础（四十三）》 SnapHelper/"},{"title":"《Android 基础（四十七）》FileProvider","text":"简介 FileProvider，是ContentProvider的子类，通过构建以”content://”开头的Uri取代之前以”file://”开头的Uri，以此实现应用间的文件共享。 由来 官文Android7.0行为变更说明： 对于面向 Android 7.0 的应用，Android 框架执行的 StrictMode API 政策禁止在应用外部公开 file:// URI。如果一项包含文件 URI 的 intent 离开您的应用，则应用出现故障，并出现 FileUriExposedException 异常。 要在应用间共享文件，需要改用content:// 格式的URI，并授予 URI 临时访问权限。 实现此类操作最简单的方法就是使用FileProvider。 使用方式定义FileProvider FileProvider本身就能根据file生成content:// Uri，所以我们并没有必要去写一个单独的FileProvider子类。但是在某些情况下，我们可以简单的继承FileProvider，修改类名来实现与FileProvider在名字上的区分，毕竟在AndroidManifest.xml中，名字相同的provider是不被允许的。 AndroidManifest.xml中申明FileProvider 12345678910111213141516&lt;manifest&gt; ... &lt;application&gt; ... &lt;provider android:name=&quot;android.support.v4.content.FileProvider&quot; android:authorities=&quot;${applicationId}.fileprovider&quot; android:exported=&quot;false&quot; android:grantUriPermissions=&quot;true&quot;&gt; &lt;meta-data android:name=&quot;android.support.FILE_PROVIDER_PATHS&quot; android:resource=&quot;@xml/file_paths&quot; /&gt; &lt;/provider&gt; ... &lt;/application&gt;&lt;/manifest&gt; 明确可用文件 上面明确来resource文件为”@xml/file_paths”。那么我们就在file_paths中明确我们的可用位置。 FileProvider只能为你事先指定的目录中的文件生成内容URI。 要指定目录，请使用&lt; paths &gt;元素的子元素指定其存储区域和XML路径。 例如，以下路径元素告诉FileProvider你打算请求私有文件目录下的images /子目录的内容URI 1234&lt;paths xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt; &lt;files-path name=&quot;my_images&quot; path=&quot;images/&quot;/&gt; ...&lt;/paths&gt; paths元素 | 对应目录 ------------------------------------------------------ | --------------------------------------------------------------------- &amp;lt; root-path/&amp;gt; | “/” &amp;lt; files-path name=”name” path=”path” /&amp;gt; | Context.getFilesDir() &amp;lt; cache-path name=”name” path=”path” /&amp;gt; | Context.getCacheDir() &amp;lt; external-path name=”name” path=”path” /&amp;gt; | Environment.getExternalStorageDirectory() &amp;lt; external-files-path name=”name” path=”path” /&amp;gt; | Context#getExternalFilesDir(String) Context.getExternalFilesDir(null) &amp;lt; external-cache-path name=”name” path=”path” /&amp;gt; | Context.getExternalCacheDir() &amp;lt; external-media-path name=”name” path=”path” /&amp;gt; | Context.getExternalMediaDirs()(API21+) 这样看可能不太明显，随意新建一个Android工程，打印如上内容，示例工程包名为 cn.onlyloveyd.lazyshare 为File生成Content Uri 创建需要用Uri表示的文件File 使用getUriForFile()方法获取对应的Uri. 官方示例: 123File imagePath = new File(Context.getFilesDir(), &quot;images&quot;);File newFile = new File(imagePath, &quot;default_image.jpg&quot;);Uri contentUri = getUriForFile(getContext(), &quot;com.mydomain.fileprovider&quot;, newFile); 生成的Uri就是 1content://com.mydomain.fileprovider/my_images/default_image.jpg. 临时授权Uri 给通过getUriForFile()方法返回的Uri授权的步骤： 调用Context.grantUriPermission(package, Uri, mode_flags)。package为包名，Uri为需要临时授权的content Uri。mode_flags可以为FLAG_GRANT_READ_URI_PERMISSION, FLAG_GRANT_WRITE_URI_PERMISSION，根据需求而定。通过revokeUriPermission() 或者重启取消授权。 Intent中setData方法设置Uri Intent setFlags方法设置FLAG_GRANT_READ_URI_PERMISSION 或者FLAG_GRANT_WRITE_URI_PERMISSION。 发送Intent到另一个App 传递Uri到另一个应用将content:\\ Uri提供给客户端应用程序的方式很多。 一种常见的方法是客户端应用程序通过调用startActivityResult()来启动应用程序，发送一个Intent以启动一个Activity，然后通过setResult() 的方式返回给客户端。 另一种方式是通过调用Intent.setClipData()方法将content:\\ Uri放入ClipData对象中，然后将该对象添加到发送给客户端应用程序的Intent中即可。 源码看看类结构 SimplePathStrategy123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100static class SimplePathStrategy implements PathStrategy { private final String mAuthority; private final HashMap&lt;String, File&gt; mRoots = new HashMap&lt;String, File&gt;(); SimplePathStrategy(String authority) { mAuthority = authority; } /** * Add a mapping from a name to a filesystem root. The provider only offers * access to files that live under configured roots. */ //读取xml配置文件，建立名称和目录的映射表 void addRoot(String name, File root) { //名字不能为空 if (TextUtils.isEmpty(name)) { throw new IllegalArgumentException(&quot;Name must not be empty&quot;); } try { // Resolve to canonical path to keep path checking fast root = root.getCanonicalFile(); } catch (IOException e) { throw new IllegalArgumentException( &quot;Failed to resolve canonical path for &quot; + root, e); } mRoots.put(name, root); } @Override public Uri getUriForFile(File file) { String path; try { //获取路径 path = file.getCanonicalPath(); } catch (IOException e) { throw new IllegalArgumentException(&quot;Failed to resolve canonical path for &quot; + file); } // Find the most-specific root path Map.Entry&lt;String, File&gt; mostSpecific = null; //遍历查找文件路径对应的名称 for (Map.Entry&lt;String, File&gt; root : mRoots.entrySet()) { final String rootPath = root.getValue().getPath(); if (path.startsWith(rootPath) &amp;&amp; (mostSpecific == null || rootPath.length() &gt; mostSpecific.getValue().getPath().length())) { mostSpecific = root; } } //查询未果，说明在xml中未定义 if (mostSpecific == null) { throw new IllegalArgumentException( &quot;Failed to find configured root that contains &quot; + path); } // Start at first char of path under root final String rootPath = mostSpecific.getValue().getPath(); if (rootPath.endsWith(&quot;/&quot;)) { path = path.substring(rootPath.length()); } else { path = path.substring(rootPath.length() + 1); } // Encode the tag and path separately path = Uri.encode(mostSpecific.getKey()) + &apos;/&apos; + Uri.encode(path, &quot;/&quot;); //构建content Uri,这就是最后我们拿到的内容 return new Uri.Builder().scheme(&quot;content&quot;) .authority(mAuthority).encodedPath(path).build(); } @Override public File getFileForUri(Uri uri) { String path = uri.getEncodedPath(); //通过uri反向寻找，和上面的原理差不多，不赘述 final int splitIndex = path.indexOf(&apos;/&apos;, 1); final String tag = Uri.decode(path.substring(1, splitIndex)); path = Uri.decode(path.substring(splitIndex + 1)); final File root = mRoots.get(tag); if (root == null) { throw new IllegalArgumentException(&quot;Unable to find configured root for &quot; + uri); } File file = new File(root, path); try { file = file.getCanonicalFile(); } catch (IOException e) { throw new IllegalArgumentException(&quot;Failed to resolve canonical path for &quot; + file); } if (!file.getPath().startsWith(root.getPath())) { throw new SecurityException(&quot;Resolved path jumped beyond configured root&quot;); } return file; }} parsePathStrategy1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465private static PathStrategy parsePathStrategy(Context context, String authority) throws IOException, XmlPullParserException { final SimplePathStrategy strat = new SimplePathStrategy(authority); //获取Provider信息 final ProviderInfo info = context.getPackageManager() .resolveContentProvider(authority, PackageManager.GET_META_DATA); // 获取&quot;android.support.FILE_PROVIDER_PATHS&quot;对应的xml文件解析对吸纳个; final XmlResourceParser in = info.loadXmlMetaData( context.getPackageManager(), META_DATA_FILE_PROVIDER_PATHS); if (in == null) { throw new IllegalArgumentException( &quot;Missing &quot; + META_DATA_FILE_PROVIDER_PATHS + &quot; meta-data&quot;); } int type; while ((type = in.next()) != END_DOCUMENT) { if (type == START_TAG) { final String tag = in.getName(); final String name = in.getAttributeValue(null, ATTR_NAME); String path = in.getAttributeValue(null, ATTR_PATH); File target = null; //&quot;root-path&quot; if (TAG_ROOT_PATH.equals(tag)) { target = DEVICE_ROOT; //&quot;files-path&quot; } else if (TAG_FILES_PATH.equals(tag)) { target = context.getFilesDir(); //&quot;cache-path&quot; } else if (TAG_CACHE_PATH.equals(tag)) { target = context.getCacheDir(); //&quot;external-path&quot; } else if (TAG_EXTERNAL.equals(tag)) { target = Environment.getExternalStorageDirectory(); //&quot;external-files-path&quot; } else if (TAG_EXTERNAL_FILES.equals(tag)) { File[] externalFilesDirs = ContextCompat.getExternalFilesDirs(context, null); if (externalFilesDirs.length &gt; 0) { //取数组中的第一个 target = externalFilesDirs[0]; } // &quot;external-cache-path&quot; } else if (TAG_EXTERNAL_CACHE.equals(tag)) { File[] externalCacheDirs = ContextCompat.getExternalCacheDirs(context); if (externalCacheDirs.length &gt; 0) { target = externalCacheDirs[0]; } // &quot;external-media-path&quot; L版本以上才有 } else if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.LOLLIPOP &amp;&amp; TAG_EXTERNAL_MEDIA.equals(tag)) { File[] externalMediaDirs = context.getExternalMediaDirs(); if (externalMediaDirs.length &gt; 0) { target = externalMediaDirs[0]; } } if (target != null) { strat.addRoot(name, buildPath(target, path)); } } } return strat; } 从上面这个方法可以很直观的了解到在AndroidManifest.xml文件中定义provider以及对应的共享文件路径定义xml的解析过程。以及xml中tag与真实文件路径的对应关系。 使用场景拍照12345678910111213141516171819202122232425262728Intent takePictureIntent = new Intent(MediaStore.ACTION_IMAGE_CAPTURE); if (takePictureIntent.resolveActivity(getPackageManager()) != null) { String filename = new SimpleDateFormat(&quot;yyyyMMdd-HHmmss&quot;, Locale.CHINA) .format(new Date()) + &quot;.png&quot;; File file = new File(Environment.getExternalStorageDirectory(), filename); mCurrentPhotoPath = file.getAbsolutePath(); Uri fileUri; if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.N) { fileUri = getUriForFile(context, context.getPackageName() +&quot;.fileprovider&quot;, file); } else { fileUri = Uri.fromFile(file); } takePictureIntent.putExtra(MediaStore.EXTRA_OUTPUT, fileUri); startActivityForResult(takePictureIntent, REQUEST_CODE_TAKE_PHOTO); }……@Override protected void onActivityResult(int requestCode, int resultCode, Intent data) { super.onActivityResult(requestCode, resultCode, data); if (resultCode == RESULT_OK &amp;&amp; requestCode == REQUEST_CODE_TAKE_PHOTO) { mIvPhoto.setImageBitmap(BitmapFactory.decodeFile(mCurrentPhotoPath)); } // else tip? } 应用安装1234567891011121314// 需要自己修改安装包路径File file = new File(Environment.getExternalStorageDirectory(), &quot;/onlyloveyd/base.apk&quot;);Intent intent = new Intent(Intent.ACTION_VIEW);intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK); if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.N) { intent.setDataAndType(getUriForFile(context, file), &quot;application/vnd.android.package-archive&quot;); intent.addFlags(Intent.FLAG_GRANT_READ_URI_PERMISSION); intent.addFlags(Intent.FLAG_GRANT_WRITE_URI_PERMISSION);} else { intent.setDataAndType(Uri.fromFile(file), &quot;application/vnd.android.package-archive&quot;);}startActivity(intent);","link":"/2018/06/30/《Android 基础（四十七）》FileProvider/"},{"title":"《Android 基础（四十五）》 RecyclerView.ItemDecoration源码浅析","text":"前言 RecyclerView目前来说，是日常开发中使用最多的控件，功能强大而且复杂。而Item Decoration作为RecyclerView开发过程中不可或缺的部分，需要深入的了解一下。 源码分析12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788/** * An ItemDecoration allows the application to add a special drawing and layout offset * to specific item views from the adapter&apos;s data set. This can be useful for drawing dividers * between items, highlights, visual grouping boundaries and more. * * &lt;p&gt;All ItemDecorations are drawn in the order they were added, before the item * views (in {@link ItemDecoration#onDraw(Canvas, RecyclerView, RecyclerView.State) onDraw()} * and after the items (in {@link ItemDecoration#onDrawOver(Canvas, RecyclerView, * RecyclerView.State)}.&lt;/p&gt; */public abstract static class ItemDecoration { /** * Draw any appropriate decorations into the Canvas supplied to the RecyclerView. * Any content drawn by this method will be drawn before the item views are drawn, * and will thus appear underneath the views. * * @param c Canvas to draw into * @param parent RecyclerView this ItemDecoration is drawing into * @param state The current state of RecyclerView */ public void onDraw(Canvas c, RecyclerView parent, State state) { onDraw(c, parent); } /** * @deprecated * Override {@link #onDraw(Canvas, RecyclerView, RecyclerView.State)} */ @Deprecated public void onDraw(Canvas c, RecyclerView parent) { } /** * Draw any appropriate decorations into the Canvas supplied to the RecyclerView. * Any content drawn by this method will be drawn after the item views are drawn * and will thus appear over the views. * * @param c Canvas to draw into * @param parent RecyclerView this ItemDecoration is drawing into * @param state The current state of RecyclerView. */ public void onDrawOver(Canvas c, RecyclerView parent, State state) { onDrawOver(c, parent); } /** * @deprecated * Override {@link #onDrawOver(Canvas, RecyclerView, RecyclerView.State)} */ @Deprecated public void onDrawOver(Canvas c, RecyclerView parent) { } /** * @deprecated * Use {@link #getItemOffsets(Rect, View, RecyclerView, State)} */ @Deprecated public void getItemOffsets(Rect outRect, int itemPosition, RecyclerView parent) { outRect.set(0, 0, 0, 0); } /** * Retrieve any offsets for the given item. Each field of &lt;code&gt;outRect&lt;/code&gt; specifies * the number of pixels that the item view should be inset by, similar to padding or margin. * The default implementation sets the bounds of outRect to 0 and returns. * * &lt;p&gt; * If this ItemDecoration does not affect the positioning of item views, it should set * all four fields of &lt;code&gt;outRect&lt;/code&gt; (left, top, right, bottom) to zero * before returning. * * &lt;p&gt; * If you need to access Adapter for additional data, you can call * {@link RecyclerView#getChildAdapterPosition(View)} to get the adapter position of the * View. * * @param outRect Rect to receive the output. * @param view The child view to decorate * @param parent RecyclerView this ItemDecoration is decorating * @param state The current state of RecyclerView. */ public void getItemOffsets(Rect outRect, View view, RecyclerView parent, State state) { getItemOffsets(outRect, ((LayoutParams) view.getLayoutParams()).getViewLayoutPosition(), parent); }} 注意看英文注释，ItemDecoration是用于装饰RecyclerView的Item的，主要关注如下三个方法 getItemOffsets参数 | 意义 ------- | ---------------------------- outRect | ItemView的外围矩形 view | ItemView parent | RecyclerView,ItemView的Parent state | RecyclerView的状态 直接这样子说看不出效果，上几张图区分一下 12345outRect.top =20;outRect.bottom =20;outRect.left=60;outRect.right =60; 12345outRect.top =20;outRect.bottom =20;outRect.left=60;outRect.right =0; 12345outRect.top =60;outRect.bottom =60;outRect.left=20;outRect.right =20; 看上去设置outRect设置top,left,right,bottom有一种padding的效果，但是实际上只是它是ItemView外围的空间，你可以将其理解成RecyclerView针对每个ItemView设置的Padding，而不是ItemView自身的padding。 onDraw参数 | 意义 ------ | ---------------------------- c | RecyclerView的Canvas parent | RecyclerView,ItemView的Parent state | RecyclerView的状态 onDraw操作是在RecyclerView所在的画布上绘制内容，也就是在ItemView的背后绘制内容，重叠部分会被ItemView遮挡。 比如我们在Item View的背后画一个圆圈圈。 12345678910111213141516171819public YdDividerItemDecoration(){ mPaint = new Paint(); mPaint.setColor(Color.GREEN); mPaint.setAntiAlias(true);}@Overridepublic void onDraw(Canvas c, RecyclerView parent, RecyclerView.State state) { super.onDraw(c, parent, state); Logger.d(&quot;yidong -- onDraw&quot;); int width = parent.getWidth(); int height = parent.getHeight(); int radius = Math.min(width, height)/2; c.drawCircle(width/2, height/2, radius, mPaint);} 这个是为了说明，我们操作的画布是RecyclerView的画布，而不是针对ItemView，所以一般情况下，我们需要针对每个ItemView做操作，比如画分割线，官方给出的DividerItemDecoration的onDraw方法 123456789101112@Overridepublic void onDraw(Canvas c, RecyclerView parent, RecyclerView.State state) { if (parent.getLayoutManager() == null || mDivider == null) { return; } if (mOrientation == VERTICAL) { drawVertical(c, parent); } else { drawHorizontal(c, parent); }} 1234567891011121314151617181920212223242526private void drawVertical(Canvas canvas, RecyclerView parent) { canvas.save(); final int left; final int right; //noinspection AndroidLintNewApi - NewApi lint fails to handle overrides. if (parent.getClipToPadding()) { left = parent.getPaddingLeft(); right = parent.getWidth() - parent.getPaddingRight(); canvas.clipRect(left, parent.getPaddingTop(), right, parent.getHeight() - parent.getPaddingBottom()); } else { left = 0; right = parent.getWidth(); } final int childCount = parent.getChildCount(); for (int i = 0; i &lt; childCount; i++) { final View child = parent.getChildAt(i); parent.getDecoratedBoundsWithMargins(child, mBounds); final int bottom = mBounds.bottom + Math.round(child.getTranslationY()); final int top = bottom - mDivider.getIntrinsicHeight(); mDivider.setBounds(left, top, right, bottom); mDivider.draw(canvas); } canvas.restore(); } 可以看出都是便利RecyclerView的Item来做操作的。 onDrawOver参数 | 意义 ------ | ---------------------------- c | RecyclerView的Canvas parent | RecyclerView,ItemView的Parent state | RecyclerView的状态 参数类型和意义和onDraw一模一样，但是效果确实在RecyclerView的ItemView之上。 还是换个圆圈圈，代码和上面一样，只是移动到onDrawOver方法下执行。 可以很明显的看到，我们的圆圈圈覆盖了ItemView。至于谁覆盖谁，显然是绘制顺序的问题。 可以看到执行顺序，onDrawOver是在onDraw之后的，但是ItemView的绘制是否在这个两个操作之前，从最后的效果来看，是的，但是需要代码证实。直接看RecyclerView绘制相关的方法即可。 12345678910111213@Overridepublic void draw(Canvas c) { //这里是RecyclerView的绘制过程，和View的绘制过程类似，先是背景，然后是调用 //recyclerview的onDraw方法绘制自身，然后通过dispatchDraw来绘制子View // 而onDraw(下面)执行的就是ItemDecoration的onDraw方法，所以顺序很明显了。 //ItemDecoration－&gt; ItemView -&gt; ItemDecoration.onDrawOver super.draw(c); // 执行ItemDecoration onDrawOver方法，最顶层 final int count = mItemDecorations.size(); for (int i = 0; i &lt; count; i++) { mItemDecorations.get(i).onDrawOver(c, this, mState); } …… 12345678910@Overridepublic void onDraw(Canvas c) { super.onDraw(c); // 执行ItemDecoration的onDraw方法，最底层 final int count = mItemDecorations.size(); for (int i = 0; i &lt; count; i++) { mItemDecorations.get(i).onDraw(c, this, mState); }} 总结 看清楚了ItemDecoration的实现原理，具体通过什么方式绘制出什么样的图形，应该只是设计和时间的问题，Github上有不错的一些实现，大家有空可以去学习借鉴一下。","link":"/2018/04/09/《Android 基础（四十五）》 RecyclerView.ItemDecoration源码浅析/"},{"title":"《Android 基础（四十八）》ConstrainLayout【译】","text":"原文地址 https://developer.android.google.cn/reference/android/support/constraint/ConstraintLayout 介绍 ConstrainLayout是一个允许开发者灵活地设置控件的位置和大小的ViewGroup。 只要你使用的Android系统版本在9以上，你便可以通过添加依赖的方式来使用ConstrainLayout. 使用添加依赖 implementation ‘com.android.support.constraint:constraint-layout:1.1.3’ 常用约束相对定位(Relative positioning) 相对定位是ConstrainLayout构建布局的一种基本方式。相对定位约束可以帮助我们通过一个给定的Widget来摆放另外一个Widget。我们可以在横纵两个方向上约束Widget。 横向: left, right, start and end sides 纵向: top, bottom sides and text baseline 一般思路是将一个 Widget的给定侧约束到其他Widget的另一侧。 比如，把button B放置到button A的右侧(下图) 实现可以如下 123&lt;Button android:id=&quot;@+id/buttonA&quot; ... /&gt;&lt;Button android:id=&quot;@+id/buttonB&quot; ... app:layout_constraintLeft_toRightOf=&quot;@+id/buttonA&quot; /&gt; 上述代码就是告诉系统，我们想让button B的左侧约束到button A的右侧。这样一个位置约束意味着，系统将让button A的右侧和button B的左侧在X轴上具有相同的位置。 此类相对位置属性还有很多，具体如下： layout_constraintLeft_toLeftOf layout_constraintLeft_toRightOf layout_constraintRight_toLeftOf layout_constraintRight_toRightOf layout_constraintTop_toTopOf layout_constraintTop_toBottomOf layout_constraintBottom_toTopOf layout_constraintBottom_toBottomOf layout_constraintBaseline_toBaselineOf layout_constraintStart_toEndOf layout_constraintStart_toStartOf layout_constraintEnd_toStartOf layout_constraintEnd_toEndOf 这些属性通过引用id来代表一个Widget，或者使用parent来代表父布局 12&lt;Button android:id=&quot;@+id/buttonB&quot; ... app:layout_constraintLeft_toLeftOf=&quot;parent&quot; /&gt; 边距(Margins) 如果设置了边距，则它们将应用于相应的约束，将边距强制设置为目标Widget和源Widget之间的空间。通常的布局边距属性就可以达到此效果。 android:layout_marginStart android:layout_marginEnd android:layout_marginLeft android:layout_marginTop android:layout_marginRight android:layout_marginBottom 注意: 边距只能是正数或等于零，采用Dimension形式。 约束目标GONE后边距处理 (Margins when connected to a GONE widget) 当约束目标的可见性为View.GONE时，你还可以使用以下属性指示要使用的不同边距值： layout_goneMarginStart layout_goneMarginEnd layout_goneMarginLeft layout_goneMarginTop layout_goneMarginRight layout_goneMarginBottom 居中定位和位置偏差ConstraintLayout的一个有用方面是它如何处理“不可能”的约束。例如，如果我们有如下代码： 12345&lt;android.support.constraint.ConstraintLayout ...&gt; &lt;Button android:id=&quot;@+id/button&quot; ... app:layout_constraintLeft_toLeftOf=&quot;parent&quot; app:layout_constraintRight_toRightOf=&quot;parent&quot;/&gt; &lt;/&gt; 除非ConstraintLayout恰好具有与Button完全相同的大小，否则两个约束不能同时满足（双方都不能成为我们想要它们的位置）。 在这种情况下，约束的作用就像是相反的力量将Widget拉平（上图）;这样Widget最终将会在父容器中居中显示。这种使用方式在纵轴方向上同样适用。 偏差(Bias) 遇到这种相反的约束时的默认设置是使Widget居中;但是你可以使用偏差属性调整定位以使一侧偏向另一侧。 layout_constraintHorizontal_bias layout_constraintVertical_bias 例如，如下代码将使左侧具有30％的偏差而不是默认的50％，使得左侧将更短，Widget更倾向于左侧（具体效果如下图）： 123456&lt;android.support.constraint.ConstraintLayout ...&gt; &lt;Button android:id=&quot;@+id/button&quot; ... app:layout_constraintHorizontal_bias=&quot;0.3&quot; app:layout_constraintLeft_toLeftOf=&quot;parent&quot; app:layout_constraintRight_toRightOf=&quot;parent/&gt; &lt;/&gt; 使用偏差属性，你可以制作更好地适应屏幕尺寸变化的用户界面。 环形定位(Circular positioning (Added in 1.1)) 你可以以距离或者角度来约束一个Widget中心相对于另一个Widget的中心。这样我们就可以将Widget放置到一个圆环上。具体属性如下： layout_constraintCircle : 引用widget ID layout_constraintCircleRadius : 到另一个widget的距离 layout_constraintCircleAngle : widget需要摆放在哪个角度 (0-360) 12345&lt;Button android:id=&quot;@+id/buttonA&quot; ... /&gt; &lt;Button android:id=&quot;@+id/buttonB&quot; ... app:layout_constraintCircle=&quot;@+id/buttonA&quot; app:layout_constraintCircleRadius=&quot;100dp&quot; app:layout_constraintCircleAngle=&quot;45&quot; /&gt; 可见性行为(Visibility behavior) ConstraintLayout对于可见性为View.GONE的Widget有明确的处理方式。 GONE widget，一般情况下，将不会显示在界面上，同时也不再是布局中的一部分。 但就布局计算而言，GONE Widget仍然是其中的一部分，这是有很大区别的。 对于布局传递，它们的尺寸将被视为零（基本上，它们将被解析为一个点） 如果他们对其他Widget有限制，这些限制仍然会得到体现，但任何边距都会等于零 这种特定的行为可以满足你在不破坏布局的情况下构建布局，只需要暂时将对应的Widget标记为GONE即可，这在构建简单的布局动画时是很有用的。 如上图，当A GONE后，B使用的左边距是B相对于A的边距。在某些情况下，这个边距可能并不是你所需要的(比如，A相对于容器存在20dp的左边距，B相对于A有40dp的左边距，当A被标记为GONE后，B相对于容器就会存在40dp的左边距)。因此，你可以指定在连接到的Widget标记为GONE时的margin作为备用边距值。具体看上一章节的【约束目标GONE后边距处理】。 尺寸约束(Dimensions constraints)ConstraintLayout最小尺寸和最大尺寸 通过如下属性你可以给ConstrainLayout定义最大或是最小尺寸。 android:minWidth set the minimum width for the layout android:minHeight set the minimum height for the layout android:maxWidth set the maximum width for the layout android:maxHeight set the maximum height for the layout 当其尺寸设置为WRAP_CONTENT时，这些最小和最大尺寸将会被ConstraintLayout使用到。 Widgets尺寸约束 Widgets的尺寸需要通过如下三种方式设置android:layout_width和android:layout_height来明确。 使用一个明确的尺寸大小 (数字值如123dp或者是一个尺寸引用) 使用WRAP_CONTENT, 让控件自己计算其大小 使用0dp, 等价于 “MATCH_CONSTRAINT” 前两种设置的效果和其他布局一样。最后一个将以匹配所设置的约束的方式调整Widget的大小（上图中（a）wrap_content,（b）0dp）。如果设置来边距，它们也将被计算在内（上图中（c）0dp with margin）。 重要 针对ConstrainLayout中的Widget，我们不推荐使用MATCH_PARENT。我们可以通过使用MATCH_CONSTRAINT配合约束 Widget 的left/right或者top/bottom 到“parent”来定义类似的行为。 WRAP_CONTENT：强制执行约束 (Added in 1.1) 如果一个尺寸设置为WRAP_CONTENT，在1.1版本之前，他们将会被定义为数值类的尺寸大小，约束将不会限制结果尺寸。一般情况下这样已经足够满足需求并且运行速度也是很快的，但是在某些情况下，你可能想用WRAP_CONTENT来设置尺寸，同时也想强制约束来限制结果布局尺寸。这种情况下，你可以使用如下属性： app:layout_constrainedWidth=”true|false” app:layout_constrainedHeight=”true|false” MATCH_CONSTRAINT(Added in 1.1)当Widget的尺寸被设置为MATCH_CONSTRAINT时，默认的结果就是使用所有可用的空间。如下几个额外的属性可以被使用到： layout_constraintWidth_min and layout_constraintHeight_min : 将为这个尺寸设置最小值 layout_constraintWidth_max and layout_constraintHeight_max : 将为这个尺寸设置最大值 layout_constraintWidth_percent and layout_constraintHeight_percent : 将按相对父布局的百分比来设置尺寸 最小值和最大值(Min and Max)为min和max指示的值可以是Dp单位，也可以是“wrap”，它将使用与WRAP_CONTENT将执行的值相同的值 百分比尺寸(Percent dimension) 要使用百分比，你需要做如下配置： 尺寸设置为MATCH_CONSTRAINT（0dp） 默认值设置为percent** app:layout_constraintWidth_default=“percent”** 或者app:layout_constraintHeight_default=”percent” (备注: 在版本1.1-beta1 and 1.1-beta2中这些配置是需要的, 但是在后续的版本中只要百分比属性被定义，便不再需要这些配置) 然后设置layout_constraintWidth_percent或者 layout_constraintHeight_percent属性值，范围0-1 比率你可以定义Widget的宽高比例。为了实现这个效果，宽高中至少又一个设置为0dp(i.e.,MATCH_CONSTRAINT)， 然后给** layout_constraintDimensionRatio**指定一个比例值，如下 123&lt;Button android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;0dp&quot; app:layout_constraintDimensionRatio=&quot;1:1&quot; /&gt; 这段代码将设置button的宽高一样。比例值可以通过如下两种方式设置： float值, 代表宽高的比例 比例值按照“width:height”的格式书写 在宽高都设置为MATCH_CONSTRAINT(0dp)时，我们仍然能够使用比例属性。在这种情况下，系统设置满足所有约束的最大尺寸并保持指定的纵横比。要根据另一个的尺寸约束一个特定边，可以预先附加“W,”或“H,”分别约束宽度或高度。比如，一个尺寸被两个目标约束(宽度0dp并且在父布局居中)，你可以通过在比例值前添加“W(约束宽度)”或者“H(约束高度)”，来指明约束宽度或者高度。 12345&lt;Button android:layout_width=&quot;0dp&quot; android:layout_height=&quot;0dp&quot; app:layout_constraintDimensionRatio=&quot;H,16:9&quot; app:layout_constraintBottom_toBottomOf=&quot;parent&quot; app:layout_constraintTop_toTopOf=&quot;parent&quot;/&gt; 如上代码，将按照16:9的比例来设置button的高度，而宽度将匹配父布局的约束。也就是这种情况下宽度:高度=16:9，由宽度来决定高度。 链(chain) 链在单个轴（水平或垂直）上提供组群行为。另一个轴可以独立约束 创建一个链 如果一组Widgets通过双向连接链接在一起，则它们被视为链。（下图展示的是一个由两个Widget组成的最小的链） 链头 链由在链的第一个元素上设置的属性控制(我们可以将其视为链的“头”) 头部是水平链的最左侧Widget，垂直链的最顶部Widget。 链间边距 如果在双向连接上指定了边距，则他们将会被计算在内。在扩散链的情况下，将从分配的空间中减去这些边距 链Style 在链的第一个元素上设置属性layout_constraintHorizo​​ntal_chainStyle或layout_constraintVertical_chainStyle时，链的行为将根据指定的样式更改（默认为CHAIN_SPREAD） CHAIN_SPREAD – 元素将等间距散开(默认style) Weighted链 – CHAIN_SPREAD 模式, 当一些Widgets设置为MATCH_CONSTRAINT,他们将被分配所有可用空间。 CHAIN_SPREAD_INSIDE – 相似地, 但是链的两端不会被分配空间。 CHAIN_PACKED – 链上元素会被打包在一起。子项的水平或垂直偏差属性将影响整个打包元素的定位。 权重链 链的默认行为是在可用空间中平均分布元素。如果一个或多个元素使用MATCH_CONSTRAINT，则它们将使用可用的空白空间(他们之间平等分配)。 layout_constraintHorizo​​ntal_weight和layout_constraintVertical_weight属性将控制如何使用MATCH_CONSTRAINT在元素之间分配空间。例如，在使用MATCH_CONSTRAINT的包含两个元素的链上，第一个元素使用权重2，第二个元素使用权重1，第一个元素占用的空间将是第二个元素占用的空间的两倍。 边距和链（1.1版本） 在链中的元素上使用边距时，边距是相加的 例如，在水平链上，如果一个元素定义了10dp的右边距而下一个元素定义了5dp的左边距，则这两个元素之间产生的边距为15dp。 在计算链用于定位项目的剩余空间时，会同时考虑项目及其边距。剩余空间不包含边距。 虚拟助手(Virtual Helper objects) 除了之前详述的内在功能外，您还可以使用ConstraintLayout中的特殊帮助程序对象来帮助您进行布局。现在，Guideline可以帮助你创建相对于ConstraintLayout容器定位的水平和垂直Guideline。然后Widgets可以被约束到这些Guideline上。在1.1版本中，Barrier和Group也别加入进来。 优化器(in 1.1) 在1.1版本中，我们提供约束优化器。你可以通过将标记app：layout_optimizationLevel添加到ConstraintLayout元素来决定应用哪些优化。 none : 不做任何优化 standard : 默认值. 只优化 direct 和 barrier 约束 direct : 优化 direct 约束 barrier : 优化 barrier 约束 chain : 优化 chain 约束 (试验版) dimensions : 优化 dimensions 测量 (试验版), 减少match constrains元素的测量次数。 此属性是一个掩码，因此您可以通过列出所需的优化来决定打开或关闭特定的优化。例如 1app:layout_optimizationLevel=&quot;direct|barrier|chain&quot;","link":"/2018/10/01/《Android 基础（四十八）》ConstrainLayout【译】/"},{"title":"《Android 基础（四十四）》 View事件分发机制","text":"1. 前言 View的事件分发机制，指的时当一个点击事件或者一个触摸事件发生时，Android系统如何讲这个事件进行处理，“分发“表示这里存在上下级关系，就如同部门经理分发任务一样，这就涉及到任务从何而来，分发到谁手上，是否继续分发或者返回上级，直到最终确定任务谁来处理，如何处理。 2. 小测试 写一个简单的测试Demo，看看运行过程 2.1 ChildView ChildView继承AppCompatButton,然后添加一些log 1234567891011121314151617181920212223242526public class ChildView extends android.support.v7.widget.AppCompatButton { public ChildView(Context context) { super(context); } public ChildView(Context context, @Nullable AttributeSet attrs) { super(context, attrs); } public ChildView(Context context, @Nullable AttributeSet attrs, int defStyleAttr) { super(context, attrs, defStyleAttr); } @Override public boolean onTouchEvent(MotionEvent event) { System.err.println(&quot;yidong -- ChildView onTouchEvent event = &quot; + event.getAction()); return super.onTouchEvent(event); } @Override public boolean dispatchTouchEvent(MotionEvent event) { System.err.println(&quot;yidong -- ChildView dispatchTouchEvent event = &quot; + event.getAction()); return super.dispatchTouchEvent(event); }} 2.2 ParentLayout ParentLayout继承LinearLayout，而LinearLayout时继承ViewGroup的添加一些log 1234567891011121314151617181920212223242526272829303132public class ParentLayout extends LinearLayout { public ParentLayout(Context context) { super(context); } public ParentLayout(Context context, @Nullable AttributeSet attrs) { super(context, attrs); } public ParentLayout(Context context, @Nullable AttributeSet attrs, int defStyleAttr) { super(context, attrs, defStyleAttr); } @Override public boolean onTouchEvent(MotionEvent event) { System.err.println(&quot;yidong -- ParentLayout onTouchEvent event = &quot; + event.getAction()); return super.onTouchEvent(event); } @Override public boolean onInterceptTouchEvent(MotionEvent ev) { System.err.println(&quot;yidong -- ParentLayout onInterceptTouchEvent event = &quot; + ev.getAction()); //return super.onInterceptTouchEvent(ev); return false; } @Override public boolean dispatchTouchEvent(MotionEvent ev) { System.err.println(&quot;yidong -- ParentLayout dispatchTouchEvent event = &quot; + ev.getAction()); return super.dispatchTouchEvent(ev); }} 2.3 布局文件123456789101112131415&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;cn.onlyloveyd.androideventdispatchdemo.ParentLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:tools=&quot;http://schemas.android.com/tools&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:id=&quot;@+id/parentLayout&quot; tools:context=&quot;cn.onlyloveyd.androideventdispatchdemo.MainActivity&quot;&gt; &lt;cn.onlyloveyd.androideventdispatchdemo.ChildView android:id=&quot;@+id/childview&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;ChildView&quot;/&gt;&lt;/cn.onlyloveyd.androideventdispatchdemo.ParentLayout&gt; 2.4 MainActivity 测试一下事件的传递过程 123456789101112131415161718192021222324252627282930313233343536373839public class MainActivity extends AppCompatActivity { private ParentLayout parentLayout; private ChildView childView; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); parentLayout = (ParentLayout) findViewById(R.id.parentLayout); childView = (ChildView) findViewById(R.id.childview); parentLayout.setOnTouchListener(new View.OnTouchListener() { @Override public boolean onTouch(View view, MotionEvent motionEvent) { System.err.println(&quot;yidong -- ParentLayout onTouch event = &quot; + motionEvent.getAction()); return false; } }); childView.setOnTouchListener(new View.OnTouchListener() { @Override public boolean onTouch(View view, MotionEvent motionEvent) { System.err.println(&quot;yidong -- ChildView onTouch event = &quot; + motionEvent.getAction()); return false; } }); childView.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View view) { System.err.println(&quot;yidong -- ChildView onClick&quot;); } }); }} 2.4.1 ParentLayout不拦截事件 ParentLayout的onInterceptTouchEvent方法直接return false；虽然使用super方法也是返回false，因为ViewGroup中就是直接返回的false。 12345@Overridepublic boolean onInterceptTouchEvent(MotionEvent ev) { System.err.println(&quot;yidong -- ParentLayout onInterceptTouchEvent event = &quot; + ev.getAction()); return false;} 点击Button 解释： ACTION_DOWN事件由ParentLayout开始分发（暂时不考虑从Activity开始，只考虑View和ViewGroup），经过dispatchTouchEvent方法，首先判断是否拦截该事件，由于我们没有设置拦截，事件继续传递到ChildView，ChildView拿到事件之后，也是通过dispatchTouchEvent来进行分发，由于没有子View，开始执行设置的onTouch方法，由于我们onTouch返回的是false，表示没有消耗事件，继续交给ChildView的onTouchEvent处理，而ChildView继承的时AppCompatButton，在onTouchEvent中会消耗掉事件，这样后续的ACTION_UP事件才会继续被处理，最后会ACTION_DOWN和ACTION_UP一起形成onClick事件。这里假设在ChildView的onTouchEvent返回的时false，我们将会看到另外一种log。 解释： 由于ChildView在onTouch和onTouchEvent中都没有消耗掉ACTION_DOWN事件，事件被返回给ParentLayout，而ParentLayout的onTouch和onTouchEvent中也都是返回的false，表示没有消耗事件，因此，这个事件一直都没有被处理。就好像领导给你一个任务，你竟然说你完成不了，后续的任务，你觉得会给你嘛？所以后面的ACTION_UP的影子都看不到。假如我们在ParentLayout的onTouch或者onTouchEvent中返回true。 若ParentLayout.onTouch返回true 可以看到对于ACTION_DOWN事件在ParentLayout.onTouch结束，没有执行ParentLayout.onTouchEvent方法。而ACTION_UP在没有执行拦截判断的情况下，直接把事件交给ParentLayout的onTouch处理。就好像一个项目中的同一个模块的第一个任务，你很好的完成来，那么第二个任务，自然就是你的。因为你有能力完成，并且两个任务也是同一个模块。 若ParentLayout.onTouchEvetn返回true 前提时ParentLayout.onTouch方法return false 结果和上面的差不多，只是终点换来一个位置而已。 点击Button外空白区域 解释： 由于ParentLayout的onTouch和onTouchEvent都是返回的false，ACTION_DOWN 事件并没有被消耗，所以后续的ACTION_UP事件自然是没有的，假如我们在onTouch或者onTouchEvent中return true。 若ParentLayout.onTouch返回true 若PatentLayout.onTouchEvent返回true 解释基本和上面的一毛一样，不做赘述。 2.4.2 ParentLayout拦截事件123456@Overridepublic boolean onInterceptTouchEvent(MotionEvent ev) { System.err.println(&quot;yidong -- ParentLayout onInterceptTouchEvent event = &quot; + ev.getAction()); //return super.onInterceptTouchEvent(ev); return true;} 结果可想而知，你的组长把活都自己做来，作为组员的你，自然时看不到任务的。运行结果和上面不拦截的情况下点击Button外部相同。具体的log要看ParentLayout的onTouch和onTouchEvent的执行结果。 2.5 总结 2.6 测试代码 AndroidEventDispatchDemo","link":"/2017/09/20/《Android 基础（四十四）》 View事件分发机制/"},{"title":"《Android 基础（四）》 RecyclerView","text":"###介绍 RecyclerView是ListView的豪华增强版。它主要包含以下几处新的特性，如ViewHolder，ItemDecorator，LayoutManager，SmothScroller以及增加或删除item时item动画等。官方推荐我们采用RecyclerView来取代ListView。 ###相对优势 ViewHolder ListView需要自己实现ViewHolder来提高性能，或者不使用ViewHolder,但是使用ViewHolder来绑定对象是一个很好的习惯。RecyclerView很好的帮我们解决了这个问题，RecyclerView.ViewHolder在使用RecyclerView过程中必须实现，因为它是一个抽象类无法直接创建，需要自己完成对应子类的建立然后使用 LayoutManager ListView只能在垂直方向上滚动，不支持其他的滚动方式，当然开发者有很多自定义的方式完成这些功能，这里就不做争辩，从设计的角度上看，ListView设计之初应该就没有想过让它完成这些复杂的功能，只是为了单纯的列表显示。但是RecyclerView相较于ListView，在滚动上面的功能扩展了许多。它可以支持多种类型列表的展示要求，主要如下： GridLayoutManager ，支持网格展示，可以水平或者竖直滚动，如展示图片的画廊。 LinearLayoutManager ，可以支持水平和竖直方向上滚动的列表。 StaggeredGridLayoutManager ，可以支持交叉网格风格的列表，类似于瀑布流或者Pinterest。 ItemAnimation ItemAnimation是RecyclerView中子项在增加，删除或者移动的情况下显示的动画效果，Google越来越重视用户体验，从属性动画的推出开始，这就是一个趋势，开发者在这里可以自己实现自己想要添加的动画效果，当然，如果你是个懒汉，请使用new DefaultItemAnimator() 。 ItemDecoration ItemDecoration，名字起的很文艺，子项的装饰，RecyclerView在默认情况下并不在item之间展示间隔符。如果你想要添加间隔符，你必须使用RecyclerView.ItemDecoration类来实现。懒汉请使用DividerItemDecoration.java。 ###Recycler示例####实际效果图 上面这个效果图是使用的StaggeredGridLayoutManager ####代码层面布局文件activity_main.xml 123456789101112131415161718192021222324252627282930313233343536373839404142&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:id=&quot;@+id/root_layout&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:orientation=&quot;vertical&quot; android:background=&quot;@color/colorMainBackground&quot;&gt; &lt;include layout=&quot;@layout/toolbar&quot;&gt;&lt;/include&gt; &lt;FrameLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:tools=&quot;http://schemas.android.com/tools&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; tools:context=&quot;.model.View.MainActivity&quot;&gt; &lt;android.support.v7.widget.RecyclerView android:id=&quot;@+id/rv_content&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot;&gt; &lt;/android.support.v7.widget.RecyclerView&gt; &lt;android.support.design.widget.FloatingActionButton android:id=&quot;@+id/fab_add&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:layout_gravity=&quot;bottom|right&quot; android:layout_marginBottom=&quot;30dp&quot; android:layout_marginRight=&quot;30dp&quot; android:src=&quot;@drawable/addone&quot; /&gt; &lt;android.support.design.widget.FloatingActionButton android:id=&quot;@+id/fab_del&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:layout_gravity=&quot;bottom|left&quot; android:layout_marginBottom=&quot;30dp&quot; android:layout_marginLeft=&quot;30dp&quot; android:src=&quot;@drawable/delone&quot; /&gt; &lt;/FrameLayout&gt;&lt;/LinearLayout&gt; recycler_item.xml 12345678910111213141516171819202122&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;FrameLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;&gt; &lt;android.support.v7.widget.CardView android:layout_margin=&quot;10dp&quot; android:id=&quot;@+id/cv_bg&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; app:cardCornerRadius=&quot;20dp&quot; app:cardElevation=&quot;5dp&quot;&gt; &lt;TextView android:id=&quot;@+id/tv_name&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:gravity=&quot;center&quot; /&gt; &lt;/android.support.v7.widget.CardView&gt;&lt;/FrameLayout&gt; 主Activity 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465public class MainActivity extends AppCompatActivity { @Bind(R.id.rv_content) RecyclerView rvContent; @Bind(R.id.fab_add) FloatingActionButton fabAdd; @Bind(R.id.fab_del) FloatingActionButton fabDel; @Bind(R.id.root_layout) LinearLayout rootLayout; private LayoutManager mLayoutManager; //LayoutManager private RVAdapter recyclerAdapter; //RecyclerView对应的Adapter private ArrayList&lt;String&gt; mContentList; //内容list这里只是使用了字符串，当然也可以替换成其他的JavaBean类 private Random mRandom = new Random(); //用于产生随机字符串 private int mSum = 50; //初始化子项数目 @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); ButterKnife.bind(this); //ButterKnife注入，减少代码负担 mContentList = new ArrayList&lt;String&gt;(); for (int i = 0; i &lt; mSum; i++) { mContentList.add(getRandomString()); } //随机生成数据 recyclerAdapter = new RVAdapter(mContentList); mLayoutManager = new StaggeredGridLayoutManager(3, LinearLayoutManager.VERTICAL); //3列纵向 rvContent.setAdapter(recyclerAdapter); rvContent.setLayoutManager(mLayoutManager); rvContent.setItemAnimator(new DefaultItemAnimator()); //设置动画效果，可以看下上面的效果图，动画效果还是比较明显的 } @OnClick({R.id.fab_add, R.id.fab_del}) public void onClick(View view) { switch (view.getId()) { case R.id.fab_add: recyclerAdapter.addData(1); //加一个 makeSnackBar(rootLayout, &quot;添加一个 :)&quot;, null, null);//显示一个Snackbar break; case R.id.fab_del: recyclerAdapter.removeData(1); //去掉一个 makeSnakeBar(rootLayout, &quot;删除一个 :(&quot;, null, null); //显示一个Snackbar break; default: break; } } //用于产生随机字符串的方法 public String getRandomString() { String src = &quot;abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ1234567890&quot;; StringBuilder dst = new StringBuilder(4); for (int i = 0; i &lt; 4; i++) { dst.append(src.charAt(mRandom.nextInt(62))); } return dst.toString(); } //构建一个Snackbar并显示出来 private void makeSnackBar(View view, String message, String buttonText, View.OnClickListener onClickListener) { Snackbar.make(view, message, Snackbar.LENGTH_SHORT) .setAction(buttonText, onClickListener) .show(); }} 适配器 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455public class RVAdapter extends RecyclerView.Adapter&lt;RVAdapter.MyViewHolder&gt;{ ArrayList&lt;String&gt; mContentList; Random mRandom = new Random(); //ViewHolder继承自RecyclerView.ViewHolder 子View拿到方便后面访问 public class MyViewHolder extends RecyclerView.ViewHolder { TextView textView; CardView cardView; public MyViewHolder(View itemView) { super(itemView); textView = (TextView) itemView.findViewById(R.id.tv_name); cardView = (CardView) itemView.findViewById(R.id.cv_bg); } } public RVAdapter(ArrayList&lt;String&gt; mContentList) { this.mContentList = mContentList; } //创建ViewHolder，由于RecyclerView.ViewHolder是一个抽象类无法实例化，所以必须实现一个子类才能使用，这里自己尝试的过程中走了一些弯路，注意inflate最后一个参数设置成false不然可能会出现crash @Override public MyViewHolder onCreateViewHolder(ViewGroup parent, int viewType) { View view = LayoutInflater.from(parent.getContext()).inflate(R.layout.recycler_item, parent, false); return new MyViewHolder(view); } //onBindView 用于设置需要显示的View中的内容和一些属性值 @Override public void onBindViewHolder(MyViewHolder holder, int position) { holder.cardView.setCardBackgroundColor(getRandomColor()); holder.textView.setText(mContentList.get(position)); holder.itemView.getLayoutParams().height = getRandomHeight(200,400);//产生随机高度，看上去像瀑布 } @Override public int getItemCount() { return mContentList.size(); } //产生随机颜色 private int getRandomColor() { return (0xff000000|mRandom.nextInt(0x00ffffff)); } //产生随机高度 private int getRandomHeight(int min , int max) { return (mRandom.nextInt(max - min) + min ); } //添加一个子项 public void addData(int position) { mContentList.add(position, &quot;Insert One&quot;); notifyItemInserted(position);//不调用这个没有动画效果 } //删除一个子项 public void removeData(int position) { mContentList.remove(position); notifyItemRemoved(position);//不调用这个没有动画效果 }} 需要注意的几个地方： 实现自己的ViewHolder继承recyclerView,ViewHolder，因为抽象类不能实例化 inflate子项的时候，最后一个参数设置成false 动画效果需要在Adapter中调用notifyItem方法才行 *StaggeredGridLayoutManager的效果图上面已经有显示了 ###其他效果 LinearLayoutManager效果图 对应修改代码 12mLayoutManager = new LinearLayoutManager(this);rvContent.addItemDecoration(new DividerItemDecoration(this, StaggeredGridLayoutManager.VERTICAL)); GridLayoutManager效果图 对应修改代码 12mLayoutManager = new GridLayoutManager(this, 3);//3列rvContent.addItemDecoration(new DividerItemDecoration(this, StaggeredGridLayoutManager.VERTICAL)); StaggeredGridLayoutManager.HORIZONTAL横向的效果图 对应修改代码 1234mLayoutManager = new StaggeredGridLayoutManager(3, StaggeredGridLayoutManager.HORIZONTAL);RVAdapter.java中onBindViewHolderholder.itemView.getLayoutParams().width = getRandomHeight(200,400); ###关于ItemDecoration 这里附上Google Sample中的DividerItemDecoration.java代码 希望可以帮助到大家 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980public class DividerItemDecoration extends RecyclerView.ItemDecoration { private static final int[] ATTRS = new int[]{ android.R.attr.listDivider }; public static final int HORIZONTAL_LIST = LinearLayoutManager.HORIZONTAL; public static final int VERTICAL_LIST = LinearLayoutManager.VERTICAL; private Drawable mDivider; private int mOrientation; public DividerItemDecoration(Context context, int orientation) { final TypedArray a = context.obtainStyledAttributes(ATTRS); mDivider = a.getDrawable(0); a.recycle(); setOrientation(orientation); } public void setOrientation(int orientation) { if (orientation != HORIZONTAL_LIST &amp;&amp; orientation != VERTICAL_LIST) { throw new IllegalArgumentException(&quot;invalid orientation&quot;); } mOrientation = orientation; } @Override public void onDraw(Canvas c, RecyclerView parent) { if (mOrientation == VERTICAL_LIST) { drawVertical(c, parent); } else { drawHorizontal(c, parent); } } public void drawVertical(Canvas c, RecyclerView parent) { final int left = parent.getPaddingLeft(); final int right = parent.getWidth() - parent.getPaddingRight(); final int childCount = parent.getChildCount(); for (int i = 0; i &lt; childCount; i++) { final View child = parent.getChildAt(i); final RecyclerView.LayoutParams params = (RecyclerView.LayoutParams) child .getLayoutParams(); final int top = child.getBottom() + params.bottomMargin + Math.round(ViewCompat.getTranslationY(child)); final int bottom = top + mDivider.getIntrinsicHeight(); mDivider.setBounds(left, top, right, bottom); mDivider.draw(c); } } public void drawHorizontal(Canvas c, RecyclerView parent) { final int top = parent.getPaddingTop(); final int bottom = parent.getHeight() - parent.getPaddingBottom(); final int childCount = parent.getChildCount(); for (int i = 0; i &lt; childCount; i++) { final View child = parent.getChildAt(i); final RecyclerView.LayoutParams params = (RecyclerView.LayoutParams) child .getLayoutParams(); final int left = child.getRight() + params.rightMargin + Math.round(ViewCompat.getTranslationX(child)); final int right = left + mDivider.getIntrinsicHeight(); mDivider.setBounds(left, top, right, bottom); mDivider.draw(c); } } @Override public void getItemOffsets(Rect outRect, int itemPosition, RecyclerView parent) { if (mOrientation == VERTICAL_LIST) { outRect.set(0, 0, 0, mDivider.getIntrinsicHeight()); } else { outRect.set(0, 0, mDivider.getIntrinsicWidth(), 0); } }} ###备注 Android源码中有很多关于这些View的使用方法，大家可以查阅并参考使用。 博文中部分代码： http://download.csdn.net/detail/poorkick/9541326","link":"/2016/06/04/《Android 基础（四）》 RecyclerView/"},{"title":"《Android 应用 之路》 天气预报（二）","text":"####界面组成 载入界面 显示界面 Activity两个，一个用来显示载入界面，一个用来显示天气信息 主要代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184public class MyActivity extends Activity { private static final String TAG = &quot;WelcomeActiivty&quot;; private ProgressBar mLoadingBar; //载入进度条 private TextView mVersionName; //载入界面显示版本信息 private AsyncTask mLoadingTask; //后台载入异步任务 private ArrayList&lt;WeatherInfo&gt; weatherInfoList; //用来保存天气信息 //天气信息接口 private static final String frontUrl = &quot;http://www.weather.com.cn/data/cityinfo/&quot;; private static final String suffix = &quot;.html&quot;; //与上面配合使用，中间添加城市code,如 //http://www.weather.com.cn/data/cityinfo/101010100.html //所有城市的列表 private int[] mCityCodeList = {101010100, 101010300, 101010400, 101010500, 101010600, 101010700, 101010800, 101010900, 101011000, 101011100, 101011200, 101011300, 101011400, 101011500, 101011600, 101011700, 101011800, 101011900, 101012000, 101012100, 101012200, 101010200, 101030100, 101030300, 101030400, 101030500, 101030600, 101031400, 101030800, 101030900, 101031000, 101031100, 101031200, 101030200, 101030700, 101020100, 101020300, 101020500, 101020600, 101021300, 101020800, 101020900, 101021000, 101021100, 101021200, 101020200, 101020700, 101090101, 101090301, 101090402, 101090501, 101091101, 101090701, 101090801, 101090901, 101091001, 101090201, 101090601, 101180101, 101180301, 101180401, 101180501, 101180601, 101180701, 101180801, 101180901, 101181001, 101181101, 101181201, 101181301, 101181401, 101181501, 101181601, 101181701, 101181801, 101180201, 101220101, 101220301, 101220401, 101220501, 101220601, 101220701, 101220801, 101220901, 101221001, 101221101, 101221201, 101221301, 101221401, 101221501, 101221601, 101221701, 101220201, 101210101, 101211101, 101210201, 101210301, 101210901, 101210501, 101210601, 101210701, 101210801, 101211001, 101210401, 101040100, 101040300, 101040400, 101040500, 101040600, 101040700, 101040800, 101040900, 101041000, 101041100, 101041200, 101041300, 101041400, 101041500, 101041600, 101041700, 101041800, 101041900, 101042000, 101042100, 101042200, 101042300, 101042400, 101042500, 101042600, 101042700, 101042800, 101042900, 101043000, 101043100, 101043200, 101043300, 101043400, 101043600, 101043700, 101040200, 101230101, 101230501, 101230601, 101230701, 101230509, 101230901, 101230201, 101230301, 101230401, 101230801, 101160101, 101160301, 101160401, 101160501, 101160601, 101161401, 101160801, 101160901, 101161001, 101161101, 101161201, 101161301, 101160201, 101160701, 101280101, 101280301, 101280401, 101280501, 101280601, 101280701, 101280800, 101280901, 101281001, 101281101, 101281201, 101281301, 101281401, 101281501, 101281601, 101281701, 101281801, 101281901, 101282001, 101282101, 101280201, 101300101, 101300301, 101300401, 101300501, 101300601, 101301401, 101300801, 101300901, 101301001, 101301101, 101301201, 101301301, 101300201, 101300701, 101260101, 101260301, 101260401, 101260906, 101260601, 101260701, 101260801, 101260201, 101260501, 101290101, 101290301, 101290601, 101290701, 101290801, 101290901, 101291001, 101291101, 101291201, 101291301, 101291401, 101291501, 101291601, 101290201, 101290401, 101290501, 101080101, 101080301, 101080401, 101080501, 101081201, 101080701, 101080801, 101080901, 101081000, 101081101, 101080201, 101080601, 101240101, 101240301, 101240401, 101240501, 101241101, 101240701, 101240801, 101240901, 101241001, 101240201, 101240601, 101200101, 101200501, 101200801, 101200901, 101201001, 101201101, 101201201, 101201301, 101201401, 101201501, 101201601, 101201701, 101200201, 101200301, 101200401, 101200601, 101200701, 101270101, 101270301, 101270401, 101270501, 101270601, 101270701, 101270801, 101270901, 101271001, 101271101, 101271201, 101271301, 101271401, 101271501, 101271601, 101271701, 101271801, 101271901, 101272001, 101272101, 101270201, 101170101, 101170501, 101170401, 101170201, 101170301, 101150101, 101150301, 101150801, 101150501, 101150601, 101150701, 101150201, 101150401, 101120101, 101120601, 101120901, 101121001, 101121101, 101121201, 101121301, 101121401, 101121501, 101121601, 101121701, 101120201, 101120301, 101120401, 101120501, 101120701, 101120801, 101110101, 101110300, 101110401, 101111001, 101110601, 101110701, 101110801, 101110901, 101110200, 101110501, 101100101, 101100701, 101100801, 101100901, 101101001, 101100501, 101100201, 101100301, 101100401, 101100601, 101101100, 101130101, 101130301, 101130401, 101130501, 101130601, 101130701, 101130801, 101130901, 101131001, 101131101, 101131201, 101131301, 101131401, 101131501, 101131601, 101130201, 101140101, 101140301, 101140701, 101140501, 101140601, 101140201, 101140401, 101340101, 101340201, 101340401, 101310101, 101310201, 101310202, 101310203, 101310204, 101310205, 101310206, 101310207, 101310208, 101310209, 101310210, 101310211, 101310212, 101310214, 101310215, 101310216, 101310217, 101310220, 101310221, 101310222, 101310102, 101250101, 101250301, 101250401, 101250501, 101250601, 101250700, 101250801, 101250901, 101251001, 101251101, 101251201, 101251301, 101251401, 101251501, 101250201, 101190101, 101190301, 101190401, 101190501, 101190601, 101191301, 101190801, 101190901, 101191001, 101191101, 101191201, 101190201, 101190701, 101050101, 101050301, 101050401, 101050501, 101050601, 101051301, 101050801, 101050901, 101051002, 101051101, 101051201, 101050201, 101050701, 101060101, 101060301, 101060401, 101060901, 101060601, 101060701, 101060801, 101060201, 101060501, 101070101, 101070301, 101070401, 101070501, 101070601, 101071401, 101070801, 101070901, 101071001, 101071101, 101071201, 101071301, 101070201, 101070701}; private int mAvailableLinks = mCityCodeList.length;//用来保存可用的查询结果，后面用来判断载入是否完成 @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); requestWindowFeature(Window.FEATURE_NO_TITLE);//没有标题的界面效果 setContentView(R.layout.welcome); weatherInfoList = new ArrayList&lt;WeatherInfo&gt;(); mLoadingBar = (ProgressBar) findViewById(R.id.loadingbar); mLoadingBar.setProgress(0); mLoadingBar.setMax(mCityCodeList.length);//进度条 mVersionName = (TextView) findViewById(R.id.versionname); mVersionName.setText(getString(R.string.app_name).toString() + &quot; &quot; + getLocalVersionName(this)); final RequestQueue mRequestQueue = Volley.newRequestQueue(this); AsyncTask mLoadingDataTask = new AsyncTask() { @Override protected void onProgressUpdate(Object[] values) { super.onProgressUpdate(values); int progress = mLoadingBar.getProgress(); mLoadingBar.setProgress(progress + 1);//更新进度条 if (mLoadingBar.getProgress() == mAvailableLinks) { showWeatherInfo(); } } @Override protected Object doInBackground(Object[] objects) { //查询所有的信息并解析出来保存到ArrayList中 for (int i = 0; i &lt; mCityCodeList.length; i++) { String uri = frontUrl + String.valueOf(mCityCodeList[i]) + suffix; JsonObjectRequest jsonObjectRequest = new JsonObjectRequest(uri, null, new Response.Listener&lt;JSONObject&gt;() { @Override public void onResponse(JSONObject jsonObject) { try { JSONObject weatherinfojson = jsonObject.getJSONObject(&quot;weatherinfo&quot;); WeatherInfo newWeatherInfo = new WeatherInfo( weatherinfojson.getString(&quot;city&quot;), weatherinfojson.getString(&quot;cityid&quot;), weatherinfojson.getString(&quot;temp1&quot;), weatherinfojson.getString(&quot;temp2&quot;), weatherinfojson.getString(&quot;weather&quot;), weatherinfojson.getString(&quot;img1&quot;), weatherinfojson.getString(&quot;img2&quot;), weatherinfojson.getString(&quot;ptime&quot;)); publishProgress(); weatherInfoList.add(newWeatherInfo); } catch (Exception e) { mAvailableLinks--; e.printStackTrace(); } } }, new Response.ErrorListener() { @Override public void onErrorResponse(VolleyError volleyError) { mAvailableLinks--; Log.e(&quot;TAG&quot;, volleyError.getMessage(), volleyError); } }); //添加到RequestQueue中 mRequestQueue.add(jsonObjectRequest); } return null; } }; mLoadingDataTask.execute(); } /** * 获取本地软件版本名称 */ public static String getLocalVersionName(Context ctx) { String localVersion = &quot;&quot;; try { PackageInfo packageInfo = ctx.getApplicationContext() .getPackageManager() .getPackageInfo(ctx.getPackageName(), 0); localVersion = packageInfo.versionName; } catch (PackageManager.NameNotFoundException e) { e.printStackTrace(); } return localVersion; } //跳转到显示天气信息的界面，并传递List数据 private void showWeatherInfo() { Bundle bundle = new Bundle(); bundle.putSerializable(Utils.WEATHERINFO, (Serializable) weatherInfoList); Intent intent = new Intent(MyActivity.this, MainActivity.class); intent.putExtra(Utils.WEATHERINFO, bundle); startActivity(intent); finish();//finish掉这个Activity,否则返回键可以回到载入界面 那就尴尬了！ }} Activity之前传递数据的方式 Bundle public void putAll(Bundle bundle) public boolean hasFileDescriptors() public void putByte(String key, byte value) public void putChar(String key, char value) public void putShort(String key, short value) public void putFloat(String key, float value) public void putCharSequence(String key, CharSequence value) public void putParcelable(String key, Parcelable value) public void putSize(String key, Size value) public void putSizeF(String key, SizeF value) public void putParcelableArray(String key, Parcelable[] value) public void putParcelableArrayList(String key, ArrayList&lt; xx extends Parcelable&gt; value) public void putSparseParcelableArray(String key, SparseArray&lt; xx extends Parcelable&gt; value) public void putIntegerArrayList(String key, ArrayList value) public void putStringArrayList(String key, ArrayList value) public void putCharSequenceArrayList(String key, ArrayList value) public void putSerializable(String key, Serializable value) public void putByteArray(String key, byte[] value) public void putShortArray(String key, short[] value) public void putCharArray(String key, char[] value) public void putFloatArray(String key, float[] value) public void putCharSequenceArray(String key, CharSequence[] value) public void putBundle(String key, Bundle value) public void putBinder(String key, IBinder value) 很多类似的方法，Bundle就是一个载体，用什么方式封装后传递，在对应端就用什么方式把它解读出来 通过showWeatherInfo方法跳转到查询到的所有天气的显示界面。下一篇文章讲解。 看下效果图：","link":"/2016/05/03/《Android 应用 之路》 天气预报（二）/"},{"title":"《Android 应用 之路》 天气预报（五）","text":"####前言 写了上一篇文章，讲了下这个实现天气预报的使用内容，现在又到了看代码的时候，主要还是贴代码，然后添加足够的注释。 ####聚合数据SDK配置 将juhe_sdk_v_X_X.jar以及armeabi文件夹(内包含libJuheSDK_v_X_X.so)添加到工程中libs文件夹下 打开Moudle setting -&gt; app -&gt; Dependencies,添加juhe_sdk_v_X_X.jar, 在AndroidManifest.xml中,加入所需权限: 12345&lt;uses-permission android:name=&quot;android.permission.READ_PHONE_STATE&quot; /&gt;&lt;uses-permission android:name=&quot;android.permission.INTERNET&quot; /&gt;&lt;uses-permission android:name=&quot;android.permission.ACCESS_NETWORK_STATE&quot; /&gt;&lt;uses-permission android:name=&quot;android.permission.ACCESS_WIFI_STATE&quot; /&gt;&lt;uses-permission android:name=&quot;android.permission.ACCESS_COARSE_LOCATION&quot; /&gt; 添加所申请的openid(这个是在Juhe官网上申请的).在继承Application类之后, 在AndroidManifest.xml中,加入android:name属性,值为继承Application的类的路径. 初始化聚合数据SDK 1234567891011import android.app.Application;public class MyApplication extends Application { @Override public void onCreate() { // TODO Auto-generated method stub super.onCreate(); JuheSDKInitializer.initialize(getApplicationContext()); }} ####工程代码MyApplication.java 1234567891011package com.onlyloveyd.weather;import android.app.Application;import com.thinkland.sdk.android.JuheSDKInitializer;public class MyApplication extends Application { @Override public void onCreate() { // TODO Auto-generated method stub super.onCreate(); JuheSDKInitializer.initialize(getApplicationContext());//初始化Juhe数据SDK }} 城市选择界面 ChooseCityActivity.java 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108package com.onlyloveyd.weather;import ......;public class ChooseCityActivity extends Activity { public static final String TAG = &quot;ChooseCityActivity&quot;; @Bind(R.id.tv_choose_city_title) TextView tvChooseCityTitle; @Bind(R.id.et_search_city) EditText etSearchCity; @Bind(R.id.tv_hotcity) TextView tvHotcity; @Bind(R.id.gv_hotcity) GridView gvHotcity; private ArrayList&lt;CityItem&gt; mSupportCityList;//所有城市List private ArrayList&lt;CityItem&gt; mSearchCityList;//城市查询结果List private CityAdapter mCityAdapter;//城市GridView的Adapter @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); requestWindowFeature(Window.FEATURE_NO_TITLE); setContentView(R.layout.citylist);//城市选择界面 ButterKnife.bind(this);//依赖注入 mSupportCityList = new ArrayList&lt;CityItem&gt;(); mSearchCityList = new ArrayList&lt;CityItem&gt;(); //设置带shape模式的编辑框的背景颜色 //GradientDrawable myGrad = (GradientDrawable)mSearchEditView.getBackground(); //myGrad.setColor(getResources().getColor(R.color.choosecitysearchbackground)); //给城市名编译框添加文本变化的观察者 etSearchCity.addTextChangedListener(new TextWatcher() { @Override public void beforeTextChanged(CharSequence charSequence, int i, int i1, int i2) { } @Override public void onTextChanged(CharSequence charSequence, int i, int i1, int i2) { mSearchCityList.clear();//城市查询结果list清空 String searchkey = charSequence.toString(); Log.e(TAG, &quot; city size &quot; + mSupportCityList.size()); for (int j = 0; j &lt; mSupportCityList.size(); j++) { CityItem item = mSupportCityList.get(j); if (searchkey.contains(item.getDistrict()) || item.getDistrict().contains(searchkey)) {//遍历查询 mSearchCityList.add(item); } } mCityAdapter.setCityList(mSearchCityList); mCityAdapter.notifyDataSetChanged(); } @Override public void afterTextChanged(Editable editable) { } }); mCityAdapter = new CityAdapter(this, mSupportCityList); gvHotcity.setAdapter(mCityAdapter); getSupportCity(this); } private void getSupportCity(Context context) { /**Juhe SDK 封装的方法 * 请求的方法 参数: 第一个参数 当前请求的context 第二个参数 接口id 第三二个参数 接口请求的url 第 四个参数 接口请求的方式 * 第五个参数 接口请求的参数,键值对com.thinkland.sdk.android.Parameters类型; 第六个参数 * 请求的回调方法,com.thinkland.sdk.android.DataCallBack; * */ JuheData.executeWithAPI(context, 39, &quot;http://v.juhe.cn/weather/citys&quot;, JuheData.GET, null, new DataCallBack() { @Override public void onSuccess(int statusCode, String responseString) { try { //解析JSON数据 JSONObject jsonObject = new JSONObject(responseString); JSONArray result = jsonObject.getJSONArray(&quot;result&quot;); for (int i = 0; i &lt; result.length(); i++) { JSONObject object = (JSONObject) result.get(i); CityItem item = new CityItem(object.getString(&quot;id&quot;), object.getString(&quot;province&quot;), object.getString(&quot;city&quot;), object.getString(&quot;district&quot;)); mSupportCityList.add(item);//查询结果添加 mCityAdapter.notifyDataSetChanged();//notify数据变化 } } catch (JSONException e) { e.printStackTrace(); } } @Override public void onFinish() { } @Override public void onFailure(int statusCode, String responseString, Throwable throwable) { Log.e(TAG, responseString); } }); } @Override protected void onResume() { super.onResume(); } @Override protected void onPause() { etSearchCity.setText(null);//避免onBackPress的时候编辑框中还有数据 super.onPause(); }} 聚合数据针对支持的城市返回的JSON数据格式为 { “resultcode”:“200”, “reason”:“successed”, “result”:[ { “id”:“1”, /城市ID/ “province”:“北京”,/省份名称/ “city”:“北京”, /城市/ “district”:“北京” /城市/区名称/ }, { “id”:“2”, “province”:“北京”, “city”:“北京”, “district”:“海淀” }, } } 按照这种格式解析出JSON数据 //天气显示界面 WeatherActivity.java 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187package com.onlyloveyd.weather;import XXXX;public class WeatherActivity extends Activity { private static final String TAG = &quot;MainActivity&quot;; @Bind(R.id.imageview) ImageView imageview; @Bind(R.id.tv_cityname) TextView tvCityname; @Bind(R.id.tv_date) TextView tvDate; @Bind(R.id.iv_zhengfu) ImageView ivZhengfu; @Bind(R.id.iv_tenth) ImageView ivTenth; @Bind(R.id.iv_geth) ImageView ivGeth; @Bind(R.id.iv_du) ImageView ivDu; @Bind(R.id.iv_weather_fa) ImageView ivWeatherFa; @Bind(R.id.tv_weather) TextView tvWeather; @Bind(R.id.iv_weather_fb) ImageView ivWeatherFb; @Bind(R.id.tv_temp) TextView tvTemp; @Bind(R.id.tv_humidity) TextView tvHumidity; @Bind(R.id.tv_wind) TextView tvWind; @Bind(R.id.tv_refreshtime) TextView tvRefreshtime; @Bind(R.id.gv_future) GridView gvFuture; WeatherInfo.ResultBean.SkBean mSk; WeatherInfo.ResultBean.TodayBean mToday; FutureAdapter mFutureAdapter; ArrayList&lt;WeatherInfo.ResultBean.FutureBean&gt; mFutureList; private Context mContext; private String mCityName = null; /** * Called when the activity is first created. */ @Override public void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); mContext = this; requestWindowFeature(Window.FEATURE_NO_TITLE); setContentView(R.layout.weather); ButterKnife.bind(this);//依赖注入 Intent intent = getIntent(); mCityName = intent.getStringExtra(&quot;cityname&quot;);//从选择城市界面选择城市传递到这个Activity mFutureList = new ArrayList&lt;WeatherInfo.ResultBean.FutureBean&gt;();//未来7天预报的List mFutureAdapter = new FutureAdapter(this, mFutureList);//未来天气预报的GridView的Adapter gvFuture.setAdapter(mFutureAdapter); } @Override protected void onResume() { super.onResume(); mFutureList.clear(); getWeatherInfoByCity(this, mCityName);//查询天气信息，包含的内容比较多，速度还算快，没有单独使用线程 tvCityname.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View view) { onBackPressed(); } }); } private void getWeatherInfoByCity(Context context, String city) { Log.e(TAG, &quot;getWeatherInfoByCity&quot;); Parameters param = new Parameters(); param.add(&quot;cityname&quot;, city); param.add(&quot;format&quot;, 2); JuheData.executeWithAPI(context, 39, &quot;http://v.juhe.cn/weather/index&quot;, JuheData.GET, param, new DataCallBack() { @Override public void onSuccess(int statusCode, String responseString) { Gson gson = new Gson(); try { JSONObject jsonObject = new JSONObject(responseString); JSONObject resultjson = jsonObject.getJSONObject(&quot;result&quot;); JSONObject skjson = resultjson.getJSONObject(&quot;sk&quot;); JSONObject todayjson = resultjson.getJSONObject(&quot;today&quot;); JSONArray futurejson = resultjson.getJSONArray(&quot;future&quot;); mSk = gson.fromJson(skjson.toString(), WeatherInfo.ResultBean.SkBean.class); mToday = gson.fromJson(todayjson.toString(), WeatherInfo.ResultBean.TodayBean.class); Log.e(TAG, futurejson.get(2).toString()); for (int i = 0; i &lt; futurejson.length(); i++) { WeatherInfo.ResultBean.FutureBean futureBean = gson.fromJson(futurejson.get(i).toString(), WeatherInfo.ResultBean.FutureBean.class); Log.e(TAG, futureBean.toString()); mFutureList.add(futureBean); } mFutureAdapter.setmFutureList(mFutureList); gvFuture.setAdapter(mFutureAdapter); mFutureAdapter.notifyDataSetChanged(); tvCityname.setText(mCityName); tvDate.setText(mToday.getDate_y() + &quot; &quot; + mToday.getWeek()); tvWeather.setText(mToday.getWeather()); tvTemp.setText(mToday.getTemperature()); tvHumidity.setText(mSk.getHumidity()); tvWind.setText(mSk.getWind_direction() + &quot; &quot; + mSk.getWind_strength()); tvRefreshtime.setText(getString(R.string.refreshtimesuffix) + mSk.getTime()); String fa = mToday.getWeather_id().getFa(); String fb = mToday.getWeather_id().getFb(); if (fa.equals(fb)) { ivWeatherFa.setImageResource(getWeatherDrawableByWeatherId(&quot;w_&quot;, fa)); ivWeatherFb.setImageDrawable(null); } else { ivWeatherFa.setImageResource(getWeatherDrawableByWeatherId(&quot;w_&quot;, fa)); ivWeatherFb.setImageResource(getWeatherDrawableByWeatherId(&quot;w_&quot;, fb)); } int tmp = Integer.valueOf(mSk.getTemp()); if (tmp &lt; 0) { ivZhengfu.setImageResource(R.drawable.fuhao); int tenth = (0 - tmp) / 10; int geth = (0 - tmp) % 10; ivTenth.setImageResource(getWeatherDrawableByWeatherId(&quot;org4_widget_nw&quot;, String.valueOf(tenth))); ivGeth.setImageResource(getWeatherDrawableByWeatherId(&quot;org4_widget_nw&quot;, String.valueOf(geth))); } else { ivZhengfu.setImageDrawable(null); int tenth = tmp / 10; int geth = tmp % 10; ivTenth.setImageResource(getWeatherDrawableByWeatherId(&quot;org4_widget_nw&quot;, String.valueOf(tenth))); ivGeth.setImageResource(getWeatherDrawableByWeatherId(&quot;org4_widget_nw&quot;, String.valueOf(geth))); } } catch (JSONException e) { e.printStackTrace(); } } @Override public void onFinish() { // TODO Auto-generated method stub //Toast.makeText(getApplicationContext(), &quot;finish&quot;, Toast.LENGTH_SHORT).show(); } @Override public void onFailure(int statusCode, String responseString, Throwable throwable) { // TODO Auto-generated method stub Log.e(TAG, responseString); } }); } private int getWeatherDrawableByWeatherId(String suffix, String fa) { String res = suffix + fa; int resid = getResources().getIdentifier(res, &quot;drawable&quot;, getPackageName()); return resid; } @Override public boolean onTouchEvent(MotionEvent event) { final int action = event.getAction(); float startX = 0; switch (action) { case MotionEvent.ACTION_DOWN: startX = event.getRawX(); break; case MotionEvent.ACTION_UP: float endX = event.getRawX(); if ((int) (endX - startX) &gt; 10) { onBackPressed(); } break; default: break; } return true; }} 具体的内容请查阅源代码： https://code.csdn.net/poorkick/weatherclient/tree/master 有看不懂的内容可以留言，晚上统一回复。 介绍一个Intellij插件 —– Gson Format, 通过Json格式快速生成Java Bean类，提高开发效率 其实有很多很好用的插件可供选择，不仅可以提高效率，还可以增加自己对开发的兴趣，可以去多了解一下。 谢谢。","link":"/2016/05/17/《Android 应用 之路》 天气预报（五）/"},{"title":"《Android 应用 之路》 百度地图API使用（4）","text":"###前言 百度地图的定位功能和基础地图功能是分开的，使用的是另外的jar包和so库文件，详情请关注官网： 百度定位SDK ###配置 下载对应的jar包和so库，然后移动到lib目录下 AS中注意事项 12345sourceSets { main { jniLibs.srcDirs = [&apos;libs&apos;] }} 在application标签中声明service组件,每个app拥有自己单独的定位service 12&lt;service android:name=&quot;com.baidu.location.f&quot; android:enabled=&quot;true&quot; android:process=&quot;:remote&quot;&gt;&lt;/service&gt; 这个很重要 ，不要以为和基础地图的使用方式相同就忽略了对定位SDK配置官方说明的阅读 声明使用权限 123456789101112131415161718&lt;!-- 这个权限用于进行网络定位--&gt;&lt;uses-permission android:name=&quot;android.permission.ACCESS_COARSE_LOCATION&quot;&gt;&lt;/uses-permission&gt;&lt;!-- 这个权限用于访问GPS定位--&gt;&lt;uses-permission android:name=&quot;android.permission.ACCESS_FINE_LOCATION&quot;&gt;&lt;/uses-permission&gt;&lt;!-- 用于访问wifi网络信息，wifi信息会用于进行网络定位--&gt;&lt;uses-permission android:name=&quot;android.permission.ACCESS_WIFI_STATE&quot;&gt;&lt;/uses-permission&gt;&lt;!-- 获取运营商信息，用于支持提供运营商信息相关的接口--&gt;&lt;uses-permission android:name=&quot;android.permission.ACCESS_NETWORK_STATE&quot;&gt;&lt;/uses-permission&gt;&lt;!-- 这个权限用于获取wifi的获取权限，wifi信息会用来进行网络定位--&gt;&lt;uses-permission android:name=&quot;android.permission.CHANGE_WIFI_STATE&quot;&gt;&lt;/uses-permission&gt;&lt;!-- 用于读取手机当前的状态--&gt;&lt;uses-permission android:name=&quot;android.permission.READ_PHONE_STATE&quot;&gt;&lt;/uses-permission&gt;&lt;!-- 写入扩展存储，向扩展卡写入数据，用于写入离线定位数据--&gt;&lt;uses-permission android:name=&quot;android.permission.WRITE_EXTERNAL_STORAGE&quot;&gt;&lt;/uses-permission&gt;&lt;!-- 访问网络，网络定位需要上网--&gt;&lt;uses-permission android:name=&quot;android.permission.INTERNET&quot; /&gt;&lt;!-- SD卡读取权限，用户写入离线定位数据--&gt;&lt;uses-permission android:name=&quot;android.permission.MOUNT_UNMOUNT_FILESYSTEMS&quot;&gt;&lt;/uses-permission&gt; 注意事项： 在Android6.0也就是M版本的手机上实现Demo时，由于M版本Google引入了动态权限分配的机制，如果没有在代码中申请权限，默认权限是不会被打开的，作为调试的注意事项，你需要到设置中手动的为Demo程序打开权限，方便定位能够正确的进行。 AK配置 参照基础地图使用的AK配置即可 ###Demo实现 布局文件 12345678910111213141516171819202122232425262728293031&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:tools=&quot;http://schemas.android.com/tools&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:orientation=&quot;vertical&quot; tools:context=&quot;mapdemo.example.com.selfbaidumap.MainActivity&quot;&gt; &lt;LinearLayout android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:orientation=&quot;horizontal&quot;&gt; &lt;EditText android:layout_weight=&quot;3&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;match_parent&quot; android:id=&quot;@+id/et_locationresult&quot;/&gt; &lt;Button android:layout_weight=&quot;1&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;match_parent&quot; android:id=&quot;@+id/bt_locate&quot; android:text=&quot;定位&quot;/&gt; &lt;/LinearLayout&gt; &lt;com.baidu.mapapi.map.MapView android:id=&quot;@+id/bmapView&quot; android:layout_width=&quot;fill_parent&quot; android:layout_height=&quot;fill_parent&quot; android:clickable=&quot;true&quot; /&gt;&lt;/LinearLayout&gt; 代码实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184public class MainActivity extends AppCompatActivity { private MapView bmapView; private BitmapDescriptor bitmap = null; private BaiduMap mBaiduMap = null; private LocationClient mLocationClient = null; private BDLocationListener myListener = new MyLocationListener(); private EditText editTextLocationResult; private Button doLocateButton; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); SDKInitializer.initialize(getApplicationContext()); setContentView(R.layout.activity_main); bmapView = (MapView) findViewById(R.id.bmapView); mBaiduMap = bmapView.getMap(); //设置Marker的点击事件监听 mBaiduMap.setOnMarkerClickListener(new BaiduMap.OnMarkerClickListener() { @Override public boolean onMarkerClick(Marker marker) { if (marker.getExtraInfo() != null) { Bundle bundle = marker.getExtraInfo();//获取传递过来的信息 LatLng latlng = bundle.getParcelable(&quot;LatLng&quot;);//拿到经纬度 String address = bundle.getString(&quot;ADDRESS&quot;);//拿到地址信息 TextView tv = new TextView(MainActivity.this); tv.setBackgroundResource(R.drawable.marker_info_bg); tv.setTextColor(Color.WHITE); tv.setText(address); InfoWindow info = new InfoWindow(tv, latlng, -47);//创建弹出窗覆盖物 mBaiduMap.showInfoWindow(info);//展示 } return false; } }); doLocateButton = (Button) findViewById(R.id.bt_locate); doLocateButton.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View view) { startLocate();//开始定位 } }); editTextLocationResult = (EditText) findViewById(R.id.et_locationresult); bitmap = BitmapDescriptorFactory .fromResource(R.drawable.icon_gcoding); mLocationClient = new LocationClient(getApplicationContext()); //声明LocationClient类 mLocationClient.registerLocationListener(myListener); //注册监听函数 initLocation();//初始化定位的一些配置 } private void initLocation() { LocationClientOption option = new LocationClientOption(); option.setLocationMode(LocationClientOption.LocationMode.Hight_Accuracy );//可选，默认高精度，设置定位模式，高精度，低功耗，仅设备 option.setCoorType(&quot;bd09ll&quot;);//可选，默认gcj02，设置返回的定位结果坐标系 int span = 1000; option.setScanSpan(span);//可选，默认0，即仅定位一次，设置发起定位请求的间隔需要大于等于1000ms才是有效的 option.setIsNeedAddress(true);//可选，设置是否需要地址信息，默认不需要 option.setOpenGps(true);//可选，默认false,设置是否使用gps option.setLocationNotify(true);//可选，默认false，设置是否当gps有效时按照1S1次频率输出GPS结果 option.setIsNeedLocationDescribe(true);//可选，默认false，设置是否需要位置语义化结果，可以在BDLocation.getLocationDescribe里得到，结果类似于“在北京天安门附近” option.setIsNeedLocationPoiList(true);//可选，默认false，设置是否需要POI结果，可以在BDLocation.getPoiList里得到 option.setIgnoreKillProcess(false);//可选，默认true，定位SDK内部是一个SERVICE，并放到了独立进程，设置是否在stop的时候杀死这个进程，默认不杀死 option.SetIgnoreCacheException(false);//可选，默认false，设置是否收集CRASH信息，默认收集 option.setEnableSimulateGps(false);//可选，默认false，设置是否需要过滤gps仿真结果，默认需要 mLocationClient.setLocOption(option); } private void startLocate() { if (mLocationClient != null) { mLocationClient.start();//启动定位 } } @Override protected void onResume() { if (bmapView != null) { bmapView.onResume(); } super.onResume(); } @Override protected void onPause() { if (bmapView != null) { bmapView.onPause(); } super.onPause(); } @Override protected void onDestroy() { if (bmapView != null) { bmapView.onDestroy(); } if (bitmap != null) { bitmap.recycle(); } super.onDestroy(); } //这个是从Demo中拿过来的，我自己使用的时候可以不同这么复杂，拿到对应的信息即可 public class MyLocationListener implements BDLocationListener { @Override public void onReceiveLocation(BDLocation location) { //Receive Location StringBuffer sb = new StringBuffer(256); sb.append(&quot;time : &quot;); sb.append(location.getTime()); sb.append(&quot;\\nerror code : &quot;); sb.append(location.getLocType()); sb.append(&quot;\\nlatitude : &quot;); sb.append(location.getLatitude()); sb.append(&quot;\\nlontitude : &quot;); sb.append(location.getLongitude()); sb.append(&quot;\\nradius : &quot;); sb.append(location.getRadius()); if (location.getLocType() == BDLocation.TypeGpsLocation) {// GPS定位结果 sb.append(&quot;\\nspeed : &quot;); sb.append(location.getSpeed());// 单位：公里每小时 sb.append(&quot;\\nsatellite : &quot;); sb.append(location.getSatelliteNumber()); sb.append(&quot;\\nheight : &quot;); sb.append(location.getAltitude());// 单位：米 sb.append(&quot;\\ndirection : &quot;); sb.append(location.getDirection());// 单位度 sb.append(&quot;\\naddr : &quot;); sb.append(location.getAddrStr()); sb.append(&quot;\\ndescribe : &quot;); sb.append(&quot;gps定位成功&quot;); } else if (location.getLocType() == BDLocation.TypeNetWorkLocation) {// 网络定位结果 sb.append(&quot;\\naddr : &quot;); sb.append(location.getAddrStr()); //运营商信息 sb.append(&quot;\\noperationers : &quot;); sb.append(location.getOperators()); sb.append(&quot;\\ndescribe : &quot;); sb.append(&quot;网络定位成功&quot;); } else if (location.getLocType() == BDLocation.TypeOffLineLocation) {// 离线定位结果 sb.append(&quot;\\ndescribe : &quot;); sb.append(&quot;离线定位成功，离线定位结果也是有效的&quot;); } else if (location.getLocType() == BDLocation.TypeServerError) { sb.append(&quot;\\ndescribe : &quot;); sb.append(&quot;服务端网络定位失败，可以反馈IMEI号和大体定位时间到loc-bugs@baidu.com，会有人追查原因&quot;); } else if (location.getLocType() == BDLocation.TypeNetWorkException) { sb.append(&quot;\\ndescribe : &quot;); sb.append(&quot;网络不同导致定位失败，请检查网络是否通畅&quot;); } else if (location.getLocType() == BDLocation.TypeCriteriaException) { sb.append(&quot;\\ndescribe : &quot;); sb.append(&quot;无法获取有效定位依据导致定位失败，一般是由于手机的原因，处于飞行模式下一般会造成这种结果，可以试着重启手机&quot;); } sb.append(&quot;\\nlocationdescribe : &quot;); sb.append(location.getLocationDescribe());// 位置语义化信息 List&lt;Poi&gt; list = location.getPoiList();// POI数据 if (list != null) { sb.append(&quot;\\npoilist size = : &quot;); sb.append(list.size()); for (Poi p : list) { sb.append(&quot;\\npoi= : &quot;); sb.append(p.getId() + &quot; &quot; + p.getName() + &quot; &quot; + p.getRank()); } } Log.i(&quot;BaiduLocationApiDem&quot;, sb.toString()); editTextLocationResult.setText(location.getAddrStr());//显示查询结果 addMark(location.getLatitude(), location.getLongitude(), location.getAddrStr());//添加覆盖物 mLocationClient.stop(); } } private void addMark(double latitude, double longitude, String address) { LatLng latlng = new LatLng(latitude, longitude); Bundle bundle = new Bundle(); bundle.putString(&quot;ADDRESS&quot;, address); bundle.putParcelable(&quot;LatLng&quot;, latlng);//创建Bundle传递，用于在点击的时候创建弹出窗 OverlayOptions option = new MarkerOptions().icon(bitmap).extraInfo(bundle).position(latlng); if (mBaiduMap != null) { mBaiduMap.addOverlay(option); mBaiduMap.setMapStatus(MapStatusUpdateFactory.newLatLng(latlng));//移动到new marker } }} 实际效果 (个人地理位置信息被处理了，实际Demo以个人位置为准)","link":"/2016/09/17/《Android 应用 之路》 百度地图API使用（4）/"},{"title":"《Android 应用 之路》 简易手电筒","text":"###前言 快一个月没有写自己的博客了，由于最近换了工作，换了居住地，所以有一些杂事需要处理，从今天开始恢复正常，不赘述了。进入今天的主题 —– 简易的手电筒。 这个Demo中使用的是比较新的API，M版本之后添加的针对于手电筒的接口。这里使用的是Camera的API2接口，主要使用CameraManager中针对于闪光灯的一些方法，对于Camera API2的接口，后面在涉及相机应用的时候，API1和API2应该都会梳理一下，到时候再仔细的研究一下。 ###思路 实现一个简单的手电筒，考虑到M版本上新增的接口，可以直接通过setTorchMode来改变闪光灯的状态，实现开关，然后根据当前的闪光灯状态，有回调函数，若其他的应用打开了闪光灯或者是关闭了闪光灯，该应用要作出对应的调整，同时，开启和关闭的过程，需要有明显的用户感知和提示，这就要结合NotificationManager和CameraManager的接口一起实现了。 ###接口介绍 CameraManager.java(frameworks/base/core/java/android/hardware/camera2) 方法 | 含义 -------------------------------- | ---------------------------------------------------------- TorchCallback | 针对闪光灯的回调 AvailabilityCallback | 针对相机是否可用的回调 CameraManager() | 构造函数 getCameraIdList() | 获取相机的Id registerAvailabilityCallback() | 注册相机是否可用的回调 unregisterAvailabilityCallback() | 解除注册 registerTorchCallback() | 注册针对闪光灯状态的回调 unregisterTorchCallback() | 解除注册 getCameraCharacteristics() | 传入参数为相机的id，获取相机的一些参数信息，如支持的预览大小,支持的滤镜等等 openCamera() | 传入的参数为相机的id和状态的回调StateCallback,这个是在CameraDevice中定义的，打开相机操作 setTorchMode() | 设置闪光灯的状态 ###实战代码 ####1.布局文件 由于是手电筒，布局文件很简单，主布局中只有一个button activity_custom_button.xml 1234567891011121314151617&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;FrameLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:tools=&quot;http://schemas.android.com/tools&quot; android:id=&quot;@+id/flash_content&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:background=&quot;@color/black&quot; tools:context=&quot;.FlashActivity&quot;&gt; &lt;Button android:id=&quot;@+id/bt_flash&quot; android:layout_width=&quot;100dp&quot; android:layout_height=&quot;100dp&quot; android:layout_gravity=&quot;center&quot; android:background=&quot;@drawable/flash_open&quot; /&gt;&lt;/FrameLayout&gt; 显示当前闪光灯被占用的自定义Toast布局 busy_toast.xml 12345678910111213141516&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:orientation=&quot;vertical&quot;&gt; &lt;TextView android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:background=&quot;@drawable/busy_snackbar_bg&quot; android:gravity=&quot;center&quot; android:padding=&quot;@dimen/activity_horizontal_margin&quot; android:text=&quot;FlashLight is Busy , Sorry！&quot; android:textStyle=&quot;bold&quot; /&gt;&lt;/LinearLayout&gt; ####2.代码文件 主要就是两个类，一个是主Activity，一个就是用来执行notification的pendingintent的广播接收器 FlashActivity.java 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206package mraz.com.custombutton;import android.annotation.TargetApi;import android.app.Notification;import android.app.NotificationManager;import android.app.PendingIntent;import android.content.Context;import android.content.Intent;import android.content.res.Resources;import android.graphics.Bitmap;import android.graphics.BitmapFactory;import android.hardware.camera2.CameraAccessException;import android.hardware.camera2.CameraManager;import android.os.Build;import android.os.Bundle;import android.support.v7.app.AppCompatActivity;import android.support.v7.app.NotificationCompat;import android.view.Gravity;import android.view.View;import android.widget.Button;import android.widget.FrameLayout;import android.widget.Toast;@TargetApi(Build.VERSION_CODES.M)public class FlashActivity extends AppCompatActivity { public static final String CLOSE_FLASH_ACTION = &quot;android.intent.action.close_flash&quot;; private static final int NOTIFICATIONID = 0; private Button btFlash; private boolean mIsFlashOn = false; private CameraManager cameraManager = null; private String[] mCameraIds; private Notification mFlashOnNotification = null; private NotificationManager notificationManager = null; private boolean isFlashAvailbale = true; private FrameLayout mContentPanel = null; //闪光灯状态变化的回调 private CameraManager.TorchCallback torchCallback = new CameraManager.TorchCallback() { @Override public void onTorchModeUnavailable(String cameraId) { super.onTorchModeUnavailable(cameraId); //onTorchModeUnavailable 当前闪光灯不可用，如果当前闪光处于打开状态，则关闭它，并且对应的标志位 if (cameraId.equals(mCameraIds[0]) &amp;&amp; mIsFlashOn) { reverseFlashState(); } isFlashAvailbale = false; System.out.println(&quot;cameraId = &quot; + cameraId + &quot; onTorchModeUnavailable&quot;); } @Override public void onTorchModeChanged(String cameraId, boolean enabled) { super.onTorchModeChanged(cameraId, enabled); //onTorchModeChanged 闪光灯状态变化回调 enabled=false 闪光灯关闭 //enabled=true 闪光灯已经开启 //通过这个回调设置标志位,如果当前闪光灯开着但是收到了闪光灯已经被关闭的回调，则改变对应的状态 isFlashAvailbale = true; System.out.println(&quot;cameraid = &quot; + cameraId + &quot; enabled = &quot; + enabled + &quot; misFlashOn = &quot; + mIsFlashOn); if (cameraId.equals(mCameraIds[0]) &amp;&amp; enabled == false &amp;&amp; mIsFlashOn) { reverseFlashState(); } System.out.println(&quot;cameraId = &quot; + cameraId + &quot; onTorchModeChanged enabled = &quot; + enabled); } }; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_custom_button); //闪光灯开关按钮 btFlash = (Button) findViewById(R.id.bt_flash); //整个布局 mContentPanel = (FrameLayout) findViewById(R.id.flash_content); btFlash.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View view) { reverseFlashState(); } }); //根据当前闪光灯装填设置一下UI界面的颜色 changeFlashUi(mIsFlashOn); } //flash状态翻转 private void reverseFlashState() { //如果当前Flash 处于unavailable状态，说明当前闪光灯被占用，无法使用 if (!isFlashAvailbale) { //显示当前闪光灯被占用的提示 showFlashBusy(); return; } changeFlashState(mIsFlashOn);//开-&gt;关 关-&gt;开 mIsFlashOn = !mIsFlashOn;//标志位装换 changeFlashUi(mIsFlashOn);//界面UI切换，这里主要就是为了突出闪光灯开关的状态不同 applyNotification(mIsFlashOn);//闪光灯开启的提示显示和消除 } @TargetApi(Build.VERSION_CODES.JELLY_BEAN) private void applyNotification(boolean isFlashOn) { if (!isFlashOn) { dismissNotification(); return; } if (mFlashOnNotification != null &amp;&amp; notificationManager != null) { notificationManager.notify(NOTIFICATIONID, mFlashOnNotification); } } @Override protected void onResume() { super.onResume(); cameraManager = (CameraManager) getSystemService(CAMERA_SERVICE); notificationManager = (NotificationManager) getSystemService(NOTIFICATION_SERVICE); cameraManager.registerTorchCallback(torchCallback, null);//注册回调 getCameraList();//获取当前手机的摄像头个数 generateNotify();//生成需要显示的提示，方便后面显示 } @Override protected void onDestroy() { super.onDestroy(); cameraManager.unregisterTorchCallback(torchCallback);//ondestory的时候解除回调 } @TargetApi(Build.VERSION_CODES.M) //只有M版本的手机可以使用这个方法 private void changeFlashState(boolean isFlashOn) { if (cameraManager != null &amp;&amp; mCameraIds != null) { try { cameraManager.setTorchMode(mCameraIds[0], !isFlashOn); } catch (CameraAccessException e) { e.printStackTrace(); } } } @TargetApi(Build.VERSION_CODES.LOLLIPOP) //只有L版本的收集可以使用这个方法 private void getCameraList() { if (cameraManager != null) { try { mCameraIds = cameraManager.getCameraIdList(); } catch (CameraAccessException e) { e.printStackTrace(); } } } //按钮的背景图切换 private void changeFlashUi(boolean isFlashOn) { if (isFlashOn) { btFlash.setBackgroundResource(R.drawable.flash_open); } else { btFlash.setBackgroundResource(R.drawable.flash_close); } } //生成notification的大图标 private Bitmap createNotificationLargeIcon(Context c) { Resources res = c.getResources(); int width = (int) res.getDimension(android.R.dimen.notification_large_icon_width); int height = (int) res.getDimension(android.R.dimen.notification_large_icon_height); Bitmap result = Bitmap.createScaledBitmap(BitmapFactory.decodeResource(res, R.mipmap.ic_flash_on_normal), width, height, false); return result; } //生成notification private void generateNotify() { if (mFlashOnNotification != null) return; NotificationCompat.Builder builder = new NotificationCompat.Builder(this); builder.setLargeIcon(createNotificationLargeIcon(this)) .setContentTitle(&quot;手电筒已开启&quot;) .setContentText(&quot;点击可关闭手电筒&quot;) .setSmallIcon(R.mipmap.ic_flash_off_normal, 3) .setContentIntent(createCloseFlashPendingIntent()); mFlashOnNotification = builder.build(); } //消除notification private void dismissNotification() { if (notificationManager != null &amp;&amp; mFlashOnNotification != null) { notificationManager.cancel(NOTIFICATIONID); } } //创建点击notification对应的PendingIntent private PendingIntent createCloseFlashPendingIntent() { Intent intent = new Intent(); intent.setClass(this, FlashCloseReceiver.class); intent.setAction(CLOSE_FLASH_ACTION); return PendingIntent.getBroadcast(this, 0, intent, 0); } //显示一个手电筒忙碌的提示 private void showFlashBusy() { View toastContent = getLayoutInflater().inflate(R.layout.busy_toast, null, false); Toast toast = new Toast(this); toast.setView(toastContent); toast.setGravity(Gravity.CENTER, 0, 0); toast.setDuration(Toast.LENGTH_LONG); toast.show(); }} FlashCloseReceiver.java 123456789101112131415161718192021222324252627282930313233343536373839404142package mraz.com.custombutton;import android.annotation.TargetApi;import android.content.BroadcastReceiver;import android.content.Context;import android.content.Intent;import android.hardware.camera2.CameraAccessException;import android.hardware.camera2.CameraManager;import android.os.Build;public class FlashCloseReceiver extends BroadcastReceiver { CameraManager mCameraManager = null; String[] mCameraIds = null; public FlashCloseReceiver() { } @TargetApi(Build.VERSION_CODES.M) @Override public void onReceive(Context context, Intent intent) { System.out.println(&quot;onReceiver&quot;); mCameraManager = (CameraManager) context.getSystemService(Context.CAMERA_SERVICE); if (mCameraManager != null) { try { mCameraIds = mCameraManager.getCameraIdList(); } catch (CameraAccessException e) { e.printStackTrace(); } } String action = intent.getAction(); if (action.equals(FlashActivity.CLOSE_FLASH_ACTION)) { if (mCameraManager != null &amp;&amp; mCameraIds != null &amp;&amp; mCameraIds.length != 0) { try { System.out.println(&quot;setTorchMode&quot;); mCameraManager.setTorchMode(mCameraIds[0], false); } catch (CameraAccessException e) { e.printStackTrace(); } } } }} ###实际效果图 手电筒关闭状态 手电筒开启状态 手电筒开启状态提示信息 ###备注 由于开发时间比较短，测试可能不充分，有问题欢迎留言讨论~","link":"/2016/08/01/《Android 应用 之路》 简易手电筒/"},{"title":"《Android 应用 之路》简易贪吃蛇","text":"最简单的贪吃蛇 最近想着忙里偷闲写点简单的Android应用，增加一些生活乐趣，由于平时工作主要精力并不是集中在书写apk上，更多的是解决代码问题和维护模块稳定，但是写代码本身是一件比较有趣的事情，因为这个过程是从无到有的。 名称：贪吃蛇 开发环境：IntelliJ IDEA 14.0.3 思路： 定时刷新界面，因为蛇是不会停止的 随机产生食物 蛇体的更新 蛇体如何出现移动的效果 缺陷：没有结束，没有碰壁，没有追尾，除非推出（现在知道为什么是最简单的了吧） 代码分析： MyActivity， 主要作用就是定时刷新界面，让蛇不停的前进 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748private SnakeView mSnakeView; //填充窗口的View,刷新的对象private static final int REFRESH = 1; //定义消息 防止硬编码private static final int REFRESHINTERVAL = 300; //刷新的时间间隔private boolean isPaused = false; //线程的停止标志位private Handler mHandler = new Handler() { //thread handler 消息处理 @Override public void handleMessage(Message msg) { // TODO Auto-generated method stub super.handleMessage(msg); if(msg.arg1 == REFRESH) { if(mSnakeView != null) { mSnakeView.invalidate(); } } }};private Thread mRefreshThread; //用于发送刷新消息的线程//Activity的onCreate方法protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); mSnakeView = new SnakeView(this); setContentView(mSnakeView); isPaused = false; mRefreshThread = new Thread(&quot;TimerThread&quot;){ @Override public void run() { // TODO Auto-generated method stub super.run(); while(!isPaused) { Message msg = mHandler.obtainMessage(); msg.arg1 = REFRESH; mHandler.sendMessage(msg); try { Thread.sleep(REFRESHINTERVAL); //休眠一段时间后再发送消息刷新界面 } catch (InterruptedException e) { // TODO Auto-generated catch block e.printStackTrace(); } } } }; mRefreshThread.start(); //启动线程} SnakeView ，主游戏界面，蛇体，背景和食物的显示界面 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183//自定义Viewpublic class SnakeView extends View{ public static final String TAG = &quot;SnakeView&quot;; private int mWidth; //view的宽 private int mHeight; //View的高 private static final int sXOffset = 0 ; private static final int sYOffset = 0 ; // X坐标和Y坐标的偏移量，可以修改来缩小游戏范围 private final int BOXWIDTH = 30; //食物的边长，蛇体的宽度 private Random mRandom = new Random(); //用于产生随机数 private Point mFoodPosition; //食物的位置 private boolean mIsFoodDone = true; //食物是否已经被吃掉 private ArrayList&lt;Point&gt; mSnakeList; //蛇体可以看做是很多食物组成的 private Paint mSnakePaint; //用于画蛇的画笔 private int mSnakeDirection = 0; //蛇体运动的方向 private final int UP = 1; private final int DOWN = 2; private final int LEFT = 3; private final int RIGHT =4; private Paint mBgPaint;//游戏背景画笔 private Paint mFoodPaint;//食物画笔 public SnakeView(Context context) { super(context); // TODO Auto-generated constructor stub mSnakeList = new ArrayList&lt;Point&gt;(); mSnakePaint = new Paint(); mSnakePaint.setColor(Color.RED); mSnakePaint.setStyle(Paint.Style.FILL_AND_STROKE); mSnakeList.add(new Point(500,500)); mSnakeList.add(new Point(500,530)); //初始化一条丑陋的蛇 mSnakeDirection = RIGHT; mIsFoodDone = true; mFoodPosition= new Point(); mFoodPaint = new Paint(); mFoodPaint.setColor(Color.CYAN); mFoodPaint.setStyle(Paint.Style.FILL); mBgPaint = new Paint(); Paint paint = new Paint(); paint.setColor(Color.WHITE); //初始化各种画笔 } @Override public boolean onTouchEvent(MotionEvent event) { //通过手势来改变蛇体运动方向 // TODO Auto-generated method stub int x = (int)(event.getX()); int y = (int)(event.getY()); Log.e(TAG, &quot;x =&quot; + x + &quot; y = &quot; + y + &quot; mSnakeDirection = &quot; + mSnakeDirection); if(mSnakeDirection == UP || mSnakeDirection == DOWN) { if(x &lt; head.x) mSnakeDirection = LEFT; if(x &gt; head.x) mSnakeDirection = RIGHT; } else if(mSnakeDirection == LEFT || mSnakeDirection == RIGHT) { if(y &lt; head.y) mSnakeDirection = UP; if(y &gt; head.y) mSnakeDirection= DOWN; } //Log.e(TAG, &quot;after adjust mSnakeDirection = &quot; + mSnakeDirection); return super.onTouchEvent(event); } @Override protected void onDraw(Canvas canvas) { // TODO Auto-generated method stub //Log.e(TAG ,&quot;onDraw&quot;); super.onDraw(canvas); drawBg(canvas, mBgPaint); //画背景 drawFood(canvas, mFoodPaint);//画食物 drawSnake(canvas, mSnakePaint); //画蛇 } @Override protected void onSizeChanged(int w, int h, int oldw, int oldh) { // TODO Auto-generated method stub super.onSizeChanged(w, h, oldw, oldh); mWidth = w; mHeight = h; } //画背景 这里通过sXOffset, sYOffset可以实现对蛇活动区域的限制 private void drawBg(Canvas canvas, Paint paint) { canvas.drawColor(Color.WHITE); //Rect rect = new Rect(sXOffset, sYOffset, mWidth - sXOffset, mHeight - sYOffset); //canvas.drawRect(rect, paint); } //画蛇体 private void drawSnake(Canvas canvas, Paint paint) { for(int i = 0 ; i &lt; mSnakeList.size() ; i++ ) { Point point = mSnakeList.get(i); Rect rect = new Rect(point.x , point.y , point.x + BOXWIDTH , point.y + BOXWIDTH); canvas.drawRect(rect, paint); } //蛇移动，更新list为下一次刷新做准备 snakeMove(mSnakeList, mSnakeDirection); if(isFoodEaten()) { //如果吃了食物，长度加1 mIsFoodDone = true; } else { //如果没有吃食物，由于前进时加了一个 这里删除尾巴，出现移动的效果 mSnakeList.remove(mSnakeList.size() - 1); } } //画食物 private void drawFood(Canvas canvas, Paint paint) { if(mIsFoodDone) { //只在前一个食物被吃掉的情况下才产生食物 mFoodPosition.x = mRandom.nextInt(mWidth - 2*sXOffset - BOXWIDTH) + sXOffset ; mFoodPosition.y = mRandom.nextInt(mWidth - 2*sYOffset - BOXWIDTH) + sYOffset ; mIsFoodDone = false; } Rect food = new Rect(mFoodPosition.x , mFoodPosition.y , mFoodPosition.x + BOXWIDTH , mFoodPosition.y + BOXWIDTH); canvas.drawRect(food, paint); } public void snakeMove(ArrayList&lt;Point&gt; list , int direction) { //Log.e(TAG,&quot; snakeMove ArrayList = &quot; + list.toString()); Point orighead = list.get(0); Point newhead = new Point(); //蛇前进，实现原理就是头加尾减，若吃到食物，头加尾不减 switch(direction) { case UP: newhead.x = orighead.x; newhead.y = orighead.y - BOXWIDTH ; break; case DOWN: newhead.x = orighead.x; newhead.y = orighead.y + BOXWIDTH ; break; case LEFT: newhead.x = orighead.x - BOXWIDTH; newhead.y = orighead.y; break; case RIGHT: newhead.x = orighead.x + BOXWIDTH ; newhead.y = orighead.y; break; default: break; } adjustHead(newhead); list.add(0, newhead); } //边界判断 private boolean isOutBound(Point point) { if(point.x &lt; sXOffset || point.x &gt; mWidth - sXOffset) return true; if(point.y &lt; sYOffset || point.y &gt; mHeight - sYOffset) return true; return false; } //出了边界，重新回来 private void adjustHead(Point point) { //Log.e(TAG, &quot;checkBound = &quot; + isOutBound(point)); if(isOutBound(point)){ if(mSnakeDirection == UP) point.y = mHeight - sYOffset - BOXWIDTH; if(mSnakeDirection == DOWN) point.y = sYOffset; if(mSnakeDirection == LEFT) point.x = mWidth - sYOffset - BOXWIDTH; if(mSnakeDirection == RIGHT) point.x = sXOffset; } } //判断食物是否可以被吃 private boolean isFoodEaten() { if(!mIsFoodDone) { Rect foodrect = new Rect(mFoodPosition.x, mFoodPosition.y, mFoodPosition.x + BOXWIDTH, mFoodPosition.y + BOXWIDTH); Point head = mSnakeList.get(0); Rect headrect = new Rect(head.x, head.y, head.x + BOXWIDTH , head.y + BOXWIDTH); return foodrect.intersect(headrect); } return false; }} 效果展示：(制作Gif有点不流畅实际效果很流畅) 代码附件：http://download.csdn.net/detail/poorkick/9497370 欢迎讨论！","link":"/2016/04/20/《Android 应用 之路》简易贪吃蛇/"},{"title":"《Android 应用之路》 Android 开发技术选型（博客，新闻，阅读类）","text":"前言 最开始学习写应用的时候，发现类聚合数据这个平台可以提供一些免费数据接口，于是写了个人的第一个应用—– JuheNews，当时的知识储备稍显粗糙，虽然现在的知识也不咋滴，但是相对之前而言还是有些进步的，所以决定将应用重构一下，具体参考我的第二个个人开发的应用— GankIOClient，采用类似的技术思路，重构后两个应用在代码结构上是很相似的。 技术选型1. 下拉刷新 + 加载更多 采用BGARefreshLayout-Android，支持的下拉刷新样式基本可以满足我的需求，使用起来也比较简单，实现两个接口即可设置刷新动作和加载更多的动作。这位卓友的其他开源库也很好用，有兴趣的可以去看下。 使用方法： 123456789101112private void initBGALayout() { // 为BGARefreshLayout 设置代理 bgaRefreshLayout.setDelegate(this); // 设置下拉刷新和上拉加载更多的风格 参数1：应用程序上下文，参数2：是否具有上拉加载更多功能 BGANormalRefreshViewHolder refreshViewHolder = new BGANormalRefreshViewHolder(getContext(), true); refreshViewHolder.setLoadingMoreText(&quot;加载更多&quot;); refreshViewHolder.setLoadMoreBackgroundColorRes(R.color.white); refreshViewHolder.setRefreshViewBackgroundColorRes(R.color.white); bgaRefreshLayout.setRefreshViewHolder(refreshViewHolder);} 12345678910@Overridepublic void onBGARefreshLayoutBeginRefreshing(BGARefreshLayout refreshLayout) {//执行下拉刷新操作}@Overridepublic boolean onBGARefreshLayoutBeginLoadingMore(BGARefreshLayout refreshLayout) { //执行加载更多操作，返回false代表不支持加载更多 return false;} 2. 网络请求 Retrofit + RxJava2，这个就不用多做介绍了，最开始学习这两个内容的时候读过的文章分享一下： RxJava 与 Retrofit 结合的最佳实践 给 Android 开发者的 RxJava 详解 我的一个RxJava2文章收藏集 1这位朋友写的通俗易懂，不看Rxjava2的官文应该也能很快的了解Rxjava升级到2之后的变化。 使用方法： 12345678910111213141516public interface JuheApi { @GET Observable&lt;NewsBean&gt; getNews(@Url String url); @GET Observable&lt;FunnyBean&gt; getFunny(@Url String url); @GET Observable&lt;JokeBean&gt; getJoke(@Url String url); @GET Observable&lt;HistoryBean&gt; getTodayInHistory(@Url String url); @GET Observable&lt;QueryNewsBean&gt; getQueryNews(@Url String url);} 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980public class Retrofitance { public static final String BASE_URL = &quot;http://gank.io/api/&quot;; private static final int DEFAULT_TIMEOUT = 5; private Retrofit retrofit; private JuheApi mJuheApi; private OkHttpClient mOkHttpClient; //构造方法私有 private Retrofitance() { //手动创建一个OkHttpClient并设置超时时间 OkHttpClient.Builder httpClientBuilder = new OkHttpClient.Builder(); httpClientBuilder.connectTimeout(DEFAULT_TIMEOUT, TimeUnit.SECONDS); mOkHttpClient = httpClientBuilder.build(); retrofit = new Retrofit.Builder().client(mOkHttpClient) .addConverterFactory(GsonConverterFactory.create()) .addCallAdapterFactory(RxJava2CallAdapterFactory.create()) .baseUrl(BASE_URL) .build(); mJuheApi = retrofit.create(JuheApi.class); } //获取单例 public static Retrofitance getInstance() { return SingletonHolder.INSTANCE; } /** * 根据类型获取新闻信息 */ public void getNews(Observer&lt;NewsBean&gt; subscriber, String type) { String URL = &quot;&quot;; commonOp(mJuheApi.getNews(URL),subscriber); } /** * 获取趣图信息 */ public void getFunny(Observer&lt;FunnyBean&gt; subscriber, int pagenum) { String URL =&quot;&quot;; commonOp(mJuheApi.getFunny(URL), subscriber); } /** * 获取历史上的今天 */ public void getHistory(Observer&lt;HistoryBean&gt; subscriber) { Calendar now = Calendar.getInstance(); String URL = &quot;&quot;; commonOp(mJuheApi.getTodayInHistory(URL),subscriber); } /** * 获取笑话大全 */ public void getJoke(Observer&lt;JokeBean&gt; subscriber, int pagenum) { String URL =&quot;&quot;; commonOp(mJuheApi.getJoke(URL), subscriber); } public void getQueryNews(Observer&lt;QueryNewsBean&gt; subscriber, String keyword) { String URL = &quot;&quot;; commonOp(mJuheApi.getQueryNews(URL), subscriber); } private void commonOp(Observable observable, Observer subscriber) { observable.subscribeOn(Schedulers.io()) .unsubscribeOn(Schedulers.io()) .observeOn(AndroidSchedulers.mainThread()) .subscribe(subscriber); } //在访问HttpMethods时创建单例 private static class SingletonHolder { private static final Retrofitance INSTANCE = new Retrofitance(); }} 3. 响应式编程 不二选择，RxJava2 + RxAndoid，告别Thread和AsyncTask，不用写Handler了。 使用方法： 123456789101112131415161718192021222324252627282930313233343536public void getContent(int pagenum) { Observer&lt;FunnyBean&gt; observer = new Observer&lt;FunnyBean&gt;() { @Override public void onComplete() { endLoading(); } @Override public void onError(Throwable e) { e.printStackTrace(); endLoading(); onNetworkError(); } @Override public void onSubscribe(Disposable d) { } @Override public void onNext(FunnyBean funnyBean) { if (bgaRefreshLayout.isLoadingMore()) { } else { mVisitableList.clear(); } if (funnyBean.getResult() == null || funnyBean.getResult().getData() == null || funnyBean.getResult().getData().size() == 0) { onDataEmpty(); } else { mVisitableList.addAll(funnyBean.getResult().getData()); } mMultiRecyclerAdapter.setData(mVisitableList); } }; Retrofitance.getInstance().getFunny(observer, pagenum);} 4. 多类型RecyclerView Item实现 参考博文RecyclerView多类型Item的正确实现姿势 当然你也可以选择一些开源库，只是我习惯了使用这种方式，用起来也比较顺手。思路和实现方式也比较简单，使用接口化的数据和泛型，抽取抽象类，结构分明，扩展性强，聪明的你应该一看就会懂。 具体使用方法参考项目代码或者是上面这篇博文，涉及的代码比较多，主要是稍微有点结构化，不便列举。 5. 注解 butterknife，告别findViewById，但是有了Kotlin，我觉得我们也可以告别butterknife了，毕竟一把小刀。 使用方法： 1234567891011@BindView(R.id.tl_web)Toolbar tlWeb;@BindView(R.id.wv_content)WebView wvContent;@BindView(R.id.activity_web)LinearLayout activityWeb;@BindView(R.id.progressbar)ProgressBar progressbar;....ButterKnife.bind(this); 配合插件使用效果会更好喔。 6. 图片加载 我首选Glide，因为我有GIF的需求，Picasso不支持GIF，虽然体量比较小。 Glide的使用方法参考官文，最近Glide有大版本升级，改动比较多，有兴趣的可以关注下 使用方法： 1Glide.with(itemView.getContext()).load(pic1path).placeholder(R.mipmap.empty_data).into(imageView); Glide有更高阶的使用方法，根据需求学习吧。 7. 数据解析 Gson，Google的开源库，基本可以满足我的开发需求，暂时没有尝试过其他的。 使用的过程中配合Retrofit使用 1compile &apos;com.squareup.retrofit2:converter-gson:2.1.0&apos; 12345retrofit = new Retrofit.Builder().client(mOkHttpClient) /*This is the key*/ .addConverterFactory(GsonConverterFactory.create()) .addCallAdapterFactory(RxJava2CallAdapterFactory.create()) .baseUrl(BASE_URL) .build(); 配合插件使用效果会更好：GsonFormat 8. 界面布局 采用TabHost + Framgnet可以满足日常需求，当然使用开源库FlycoTabLayout更是可以构建出炫酷的Tab页面，配合上Fragment，基本可以满足需求。 使用方法： 12345678910111213141516171819202122232425262728switch (i) { case 0: textView.setText(&quot;资讯&quot;); imageView.setImageResource(R.drawable.news); tabHost.addTab(tabHost.newTabSpec(&quot;1&quot;).setIndicator(view).setContent( R.id.frag_news)); break; case 1: textView.setText(&quot;笑话&quot;); imageView.setImageResource(R.drawable.joke); tabHost.addTab(tabHost.newTabSpec(&quot;2&quot;).setIndicator(view).setContent( R.id.frag_joke)); break; case 2: textView.setText(&quot;趣图&quot;); imageView.setImageResource(R.drawable.funny); tabHost.addTab(tabHost.newTabSpec(&quot;3&quot;).setIndicator(view).setContent( R.id.frag_funny)); break; case 3: textView.setText(&quot;历史&quot;); imageView.setImageResource(R.drawable.history); tabHost.addTab(tabHost.newTabSpec(&quot;4&quot;).setIndicator(view).setContent( R.id.frag_history)); break; default: break;} FlycoTabLayout的使用方法参考官文或者网上如海水般的博文。 9. 内容搜索 自定义Toolbar这个时候就显示出来威力。简单的一个文本框和一个若隐若现的搜索按钮，满足需求。开源库也有一些，但是适合我自己的不太多，所以基本上我都是如上实现。 使用方法： 123456789101112131415161718192021222324252627282930313233343536&lt;android.support.v7.widget.Toolbar android:id=&quot;@+id/toolbar_search&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;40dp&quot; android:fitsSystemWindows=&quot;true&quot; android:background=&quot;@color/colorToolbar&quot;&gt; &lt;LinearLayout android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot;&gt; &lt;EditText android:id=&quot;@+id/et_search&quot; android:layout_width=&quot;0dp&quot; android:layout_height=&quot;match_parent&quot; android:layout_marginBottom=&quot;8dp&quot; android:layout_marginTop=&quot;8dp&quot; android:layout_weight=&quot;6&quot; android:background=&quot;@drawable/search_edittext_bg&quot; android:padding=&quot;2dp&quot; android:textColor=&quot;@color/colorBlack&quot; android:textSize=&quot;12sp&quot;/&gt; &lt;Button android:id=&quot;@+id/bt_search&quot; android:layout_width=&quot;0dp&quot; android:layout_height=&quot;match_parent&quot; android:layout_weight=&quot;2&quot; android:clickable=&quot;false&quot; android:gravity=&quot;center&quot; android:text=&quot;搜索&quot; android:background=&quot;@color/colorToolbar&quot; android:textColor=&quot;@color/colorToolbar&quot; android:textSize=&quot;14sp&quot;/&gt; &lt;/LinearLayout&gt;&lt;/android.support.v7.widget.Toolbar&gt; 10. 版本更新 第三方服务 。我使用的是Fir.im，相对比较好用，利用提供的版本接口检测版本更新。然后本地下载或者跳转到浏览器下载应用，完成安装，都是不错的选择。类似的平台还有很多，可以网上搜索一下。","link":"/2017/06/04/《Android 应用之路》 Android 开发技术选型（博客，新闻，阅读类）/"},{"title":"《Android 开源库》PhotoPicker 从头到脚","text":"1. 简介 PhotoPicker, 是一款开源的图片选择器。效果上和微信相似。 2. 使用方法2.1 添加依赖123456789dependencies { compile &apos;me.iwf.photopicker:PhotoPicker:0.9.5@aar&apos; compile &apos;com.android.support:appcompat-v7:23.4.0&apos; compile &apos;com.android.support:recyclerview-v7:23.4.0&apos; compile &apos;com.android.support:design:23.4.0&apos; compile &apos;com.nineoldandroids:library:2.4.0&apos; compile &apos;com.github.bumptech.glide:glide:3.7.0&apos;} appcompat-v7version &gt;= 23.0.0 或者使用download源码，然后使用module依赖，我平时使用是这种方式。 12345dependencies { ... compile project(&apos;:PhotoPicker&apos;) ...} 2.2 代码集成 如下内容来自Github介绍 Pick Photo 123456PhotoPicker.builder() .setPhotoCount(9) .setShowCamera(true) .setShowGif(true) .setPreviewEnabled(false) .start(this, PhotoPicker.REQUEST_CODE); Preview Photo 1234567ArrayList&lt;String&gt; photoPaths = ...;PhotoPreview.builder() .setPhotos(selectedPhotos) .setCurrentItem(position) .setShowDeleteButton(false) .start(MainActivity.this); onActivityResult 12345678910@Override protected void onActivityResult(int requestCode, int resultCode, Intent data) { super.onActivityResult(requestCode, resultCode, data); if (resultCode == RESULT_OK &amp;&amp; requestCode == PhotoPicker.REQUEST_CODE) { if (data != null) { ArrayList&lt;String&gt; photos = data.getStringArrayListExtra(PhotoPicker.KEY_SELECTED_PHOTOS); } }} AndroidManifest.xml 12345678910111213141516171819&lt;manifest xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; &gt; &lt;uses-permission android:name=&quot;android.permission.READ_EXTERNAL_STORAGE&quot;/&gt; &lt;uses-permission android:name=&quot;android.permission.WRITE_EXTERNAL_STORAGE&quot;/&gt; &lt;uses-permission android:name=&quot;android.permission.CAMERA&quot; /&gt; &lt;application ... &gt; ... &lt;activity android:name=&quot;me.iwf.photopicker.PhotoPickerActivity&quot; android:theme=&quot;@style/Theme.AppCompat.NoActionBar&quot; /&gt; &lt;activity android:name=&quot;me.iwf.photopicker.PhotoPagerActivity&quot; android:theme=&quot;@style/Theme.AppCompat.NoActionBar&quot;/&gt; &lt;/application&gt;&lt;/manifest&gt; Custom Style 1234567891011&lt;style name=&quot;actionBarTheme&quot; parent=&quot;ThemeOverlay.AppCompat.Dark.ActionBar&quot;&gt; &lt;item name=&quot;android:textColorPrimary&quot;&gt;@android:color/primary_text_light&lt;/item&gt; &lt;item name=&quot;actionBarSize&quot;&gt;@dimen/actionBarSize&lt;/item&gt;&lt;/style&gt;&lt;style name=&quot;customTheme&quot; parent=&quot;Theme.AppCompat.Light.NoActionBar&quot;&gt; &lt;item name=&quot;actionBarTheme&quot;&gt;@style/actionBarTheme&lt;/item&gt; &lt;item name=&quot;colorPrimary&quot;&gt;#FFA500&lt;/item&gt; &lt;item name=&quot;actionBarSize&quot;&gt;@dimen/actionBarSize&lt;/item&gt; &lt;item name=&quot;colorPrimaryDark&quot;&gt;#CCa500&lt;/item&gt;&lt;/style&gt; ProGuard 12345678910111213141516171819202122# Glide-keep public class * implements com.bumptech.glide.module.GlideModule-keep public enum com.bumptech.glide.load.resource.bitmap.ImageHeaderParser$** { **[] $VALUES; public *;}# nineoldandroids-keep interface com.nineoldandroids.view.** { *; }-dontwarn com.nineoldandroids.**-keep class com.nineoldandroids.** { *; }# support-v7-appcompat-keep public class android.support.v7.widget.** { *; }-keep public class android.support.v7.internal.widget.** { *; }-keep public class android.support.v7.internal.view.menu.** { *; }-keep public class * extends android.support.v4.view.ActionProvider { public &lt;init&gt;(android.content.Context);}# support-design-dontwarn android.support.design.**-keep class android.support.design.** { *; }-keep interface android.support.design.** { *; }-keep public class android.support.design.R$* { *; } 3. 源码分析3.1 代码结构 类说明(按照功能) 类名 描述 PhotoPicker 内部类PhotoPickerBuilder是关键，设置图片选择参数，启动PhotoPickerActivity均在此 PhotoPickerActivity 图片选择界面，两个Fragment:PhotoPickerFragment，ImagePagerFragment，一个用来图片选择，一个用来预览图片 PhotoPagerActivity 图片预览界面，和PhotoPickerActivity使用同样的布局文件，但是只有一个Fragment,ImagePagerFragment PhotoPreview 内部类PhotoPreviewBuilder是关键，设置预览参数，启动PhotoPagerActivity均在此 PhotoPickerFragment 图片选择Fragment,在PhotoPickerActivity中使用到,Toolbar + RecyclerView + ListPopupWindow ImagePagerFragment 图片预览Framgment,在PhotoPickerActivity中如果支持预览，点击图片后就会切换到此Fragment,单独使用PhotoPreview自然也是用的ImagePagerFragment ImageCaptureManager 拍照管理类，当PhotoPicker中setShowCamera设为true后，点击拍照项，会调用系统相机拍照，相关方法实现均在ImageCaptureManager PhotoGridAdapter 图片选择界面RecyclerView的 Adapter,瀑布流，主要因为它继承SelectableAdapter，平时开发有相同需求可以借鉴一些这个实现 PopupDirectoryListAdapter 底部图片分类文件夹ListPopupWindow的Adapter MediaStoreHelper 图片数据查找Helper类，单独拿出来看，Loader的使用 SelectableAdapter 自定义用于选择的RecyclerView.Adapter,支持toggleSelection Selectable Selectable接口，支持toggleSelection PhotoPagerAdapter ImagePagerFragment中用于预览的ViewPager的Adapter PhotoDirectory 图片目录对象，在PopupDirectoryListAdapter中使用到 Photo 图片对象，存放id和Path，分别对应数据库中图片_ID字段和DATA字段 OnItemCheckListener 图片选择框的点击事件接口 OnPhotoClickListener 图片点击事件接口，应该只有在图片选择器支持预览的情况下使用 AndroidLifecycleUtils 判断是否可以加载图片 FileUtils 文件处理工具类，只有一个判断文件是否存在的方法 PermissionsConstant 关于权限请求的部分常量 PermissionsUtils 权限请求工具类 PhotoDirectoryLoader 继承CursorLoader，从数据库中读取数据 SquareItemLayout 图片选择器Item布局 TouchImageView 预览图片自定义元件 3.2 源码设计思路 从代码结构和使用方法上来看，PhotoPicker是将图片选择作为一个单独的功能模块解耦出来，以Activity的形式进行PhotoPicker或者是PhotoPreview，在合适的位置创建Intent显示启动PhotoPagerAcitivty(预览)或者是PhotoPickerActivity(选择图片)。针对图片选择的场景，通过onActivityResult得到所选图片的Path。 PhotoPicker 方法 参数 描述 setPhotoCount(int photoCount) EXTRA_MAX_COUNT(“MAX_COUNT”) 设置可选的最大图片数量 setShowCamera(boolean showCamera) EXTRA_SHOW_CAMERA(“SHOW_CAMERA”) 是否显示拍照 setShowGif(boolean showGif) EXTRA_SHOW_GIF(“SHOW_GIF”) 是否显示gif图 setGridColumnCount(int columnCount) EXTRA_GRID_COLUMN(“column”) 设置图片选择网格的列数 setSelected(ArrayList&lt; String&gt; imagesUri) EXTRA_ORIGINAL_PHOTOS(“ORIGINAL_PHOTOS”) 已选照片 setPreviewEnabled(boolean previewEnabled) EXTRA_PREVIEW_ENABLED(“PREVIEW_ENABLED”) 图片网格视图中是否支持预览 参数 | 描述 -------------------------------------- | ----------- KEY_SELECTED_PHOTOS(“SELECTED_PHOTOS”) | 所选图片Path 列表 PhotoPreview 方法 参数 描述 setCurrentItem(int currentItem) EXTRA_CURRENT_ITEM(“current_item”) 设置预览界面当前显示图片序号 setPhotos(ArrayList&lt; String&gt; photoPaths) EXTRA_PHOTOS(“photos”) 设置预览图片列表，图片Path的ArrayList setShowDeleteButton(boolean showDeleteButton) EXTRA_SHOW_DELETE(“show_delete”) 是否显示删除按钮 Build设计模式 PhotoPicker和PhotoPreview都是采用的Build设计模式。利用构建者模式，可以清晰的管理参数，层次清晰，增加代码的可读性，Android源码系统中也有此模式的大量使用，如AlertDialog.Builder等等。 PhotoPickerBuilder和PhotoPreviewBuilder正式采用的这种设计模式。 Loader机制 loader机制，包括LoaderManager，Loader，LoaderCallbacks三部分， LoaderManager 来管理我们的laoder实例，获取来初始化，重启一个loader, Loader 来执行我们的异步操作，有开始，完成，后台等接口实现 LoaderCallbacks 来执行我们的loader回调，主要是绑定分发Loader，完成加载，重置数据等 MediaStoreHelper中只有一个方法getPhotoDirs，方法中使用 activity.getSupportLoaderManager() .initLoader(0, args, new PhotoDirLoaderCallbacks(activity, resultCallback)); 的方式初始化Loader,然后在 PhotoDirLoaderCallbacks实现 LoaderManager.LoaderCallbacks&lt; Cursor&gt;接口。onCreateLoader方法中创建PhotoDirectoryLoader并传入参数，onLoadFinished返回后台数据库查询结果。 4. 备注 PhotoPicker，可以满足日常开发需求，代码结构非常清晰，可以直接根据自己的需求在源码上进行定制修改。感谢大神的开源精神。","link":"/2017/04/27/《Android 开源库》PhotoPicker 从头到脚/"},{"title":"《Android 进阶（一）》 自定义View之仪表盘进度条","text":"1. 前言 一点一点学习自定义View，按照《Android开发艺术探索》中的说法，自定义View大致可以分为4类： 继承View重写onDraw方法； 继承ViewGroup派生特殊Layout； 继承特定View； 继承特定ViewGroup 看下第一种，制作一个简单的仪表盘进度条。 2. 实现思路 继承View； 自定义属性值：arcColor，bgColor，arc_textColor，arc_textSize，分别是前景色，背景色，进度文字颜色，进度文字字体大小； 确定弧形绘制位置和文字绘制位置 实现onDraw()方法 3. 效果 4. 知识点4.1 MeasureSpec MeasureSpec代表一个32位int值，高2位代表SpecMode，低30位代表SpecSize。SpecMode指的是测量模式，SpecSize指的是对应测量模式下的大小。 SpecMode有下面如下3中模式： 123456789101112131415161718/** * Measure specification mode: The parent has not imposed any constraint * on the child. It can be whatever size it wants. */public static final int UNSPECIFIED = 0 &lt;&lt; MODE_SHIFT;/** * Measure specification mode: The parent has determined an exact size * for the child. The child is going to be given those bounds regardless * of how big it wants to be. */public static final int EXACTLY = 1 &lt;&lt; MODE_SHIFT;/** * Measure specification mode: The child can be as large as it wants up * to the specified size. */public static final int AT_MOST = 2 &lt;&lt; MODE_SHIFT; SpecMode | 描述 ----------- | ------------------------------------------------------------------ UNSPECIFIED | 父容器不对View有任何限制，系统涉及，平时很少涉及 EXACTLY | 父容器已经检测出View所需要的精准大小，即SpecSize的大小。对应match_parent和固定数值两种情况 AT_MOST | 父容器指定一个View可用的大小。View的大小不能超过这个值，具体是什么值要看View的具体实现。对应wrap_content情况SpecSize大小单位px。 生成MeasureSpec方式如下： 12345678public static int makeMeasureSpec(@IntRange(from = 0, to = (1 &lt;&lt; MeasureSpec.MODE_SHIFT) - 1) int size, @MeasureSpecMode int mode) { if (sUseBrokenMakeMeasureSpec) { return size + mode; } else { return (size &amp; ~MODE_MASK) | (mode &amp; MODE_MASK); } } 获取size和mode的方式 1234567891011121314151617181920212223/** * Extracts the mode from the supplied measure specification. * * @param measureSpec the measure specification to extract the mode from * @return {@link android.view.View.MeasureSpec#UNSPECIFIED}, * {@link android.view.View.MeasureSpec#AT_MOST} or * {@link android.view.View.MeasureSpec#EXACTLY} */@MeasureSpecModepublic static int getMode(int measureSpec) { //noinspection ResourceType return (measureSpec &amp; MODE_MASK);}/** * Extracts the size from the supplied measure specification. * * @param measureSpec the measure specification to extract the size from * @return the size in pixels defined in the supplied measure specification */public static int getSize(int measureSpec) { return (measureSpec &amp; ~MODE_MASK);} 4.2 View的工作流程过程 | 描述 --------- | ---------------------------------------------------------- onMeasure | 测量过程，确定View的宽度和高度，传入的参数是widthMeasureSpec，heightMeasureSpec onLayout | 布局过程，确定View的上下左右四个角的位置 onDraw | 绘制过程，一般用来绘制特殊图形 继承View的自定义View基本只需要关注onDraw()和onMeasure()。由于没有子View所以不需要关注onLayout()。 4.3 图形绘制 具体请查看Canvas类和Paint类，这两个类内容比较多，可以自己研究一下，有很多有用的东西。 4.3.1 Canvas绘制方法 4.3.2 Paint属性值 Paint枚举值 设置属性方法 5. 关键代码5.1 attrs.xml123456&lt;declare-styleable name=&quot;ArcView&quot;&gt; &lt;attr name=&quot;arcColor&quot; format=&quot;color&quot;/&gt; &lt;attr name=&quot;bgColor&quot; format=&quot;color&quot;/&gt; &lt;attr name=&quot;arc_textColor&quot; format=&quot;color&quot;/&gt; &lt;attr name=&quot;arc_textSize&quot; format=&quot;dimension&quot;/&gt;&lt;/declare-styleable&gt; 5.2 ArcView123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138public class ArcView extends View { private final int MAX_SWEEP_ANGLE = 240; private final int START_SWEEP_ANGLE = 150; private final int DEFAULT_MAX_PROGRESS = 100; private final int DEFAULT_ARC_COLOR = Color.RED; private final int DEFAULT_BG_COLOR = Color.DKGRAY; private final int DEFAULT_TEXT_COLOR = Color.BLACK; private final int DEFAULT_TEXT_SIZE = 40; private int mArcColor = DEFAULT_ARC_COLOR; private int mBgColor = DEFAULT_BG_COLOR; private int mTextColor = DEFAULT_TEXT_COLOR; private int mTextSize = DEFAULT_TEXT_SIZE; private int progress = 0; private int mMaxProgress = DEFAULT_MAX_PROGRESS; private Paint mCirclePaint; private Paint mBgPaint; private Paint mTextPaint; private final Rect mTextBound = new Rect(); public ArcView(Context context) { this(context, null); } public ArcView(Context context, @Nullable AttributeSet attrs) { this(context, attrs, 0); } public ArcView(Context context, @Nullable AttributeSet attrs, int defStyleAttr) { super(context, attrs, defStyleAttr); final TypedArray attributes = getContext().obtainStyledAttributes(attrs, R.styleable.ArcView); mArcColor = attributes .getColor( R.styleable.ArcView_arcColor, DEFAULT_ARC_COLOR); mBgColor = attributes .getColor( R.styleable.ArcView_bgColor, DEFAULT_BG_COLOR); mTextColor = attributes .getColor( R.styleable.ArcView_arc_textColor, DEFAULT_TEXT_COLOR); mTextSize = (int) attributes .getDimension( R.styleable.ArcView_arc_textSize, DEFAULT_TEXT_SIZE); attributes.recycle(); init(); } private void init() { mCirclePaint = new Paint(); mCirclePaint.setColor(mArcColor); mCirclePaint.setStrokeWidth(8.0F); mCirclePaint.setDither(true); mCirclePaint.setAntiAlias(true); mCirclePaint.setStyle(Paint.Style.STROKE); mBgPaint = new Paint(); mBgPaint.setColor(mBgColor); mBgPaint.setStrokeWidth(20.0F); mBgPaint.setAntiAlias(true); mBgPaint.setStyle(Paint.Style.STROKE); mBgPaint.setStrokeCap(Paint.Cap.ROUND); mTextPaint = new Paint(); mTextPaint.setStrokeWidth(4); //字体SP单位转换成PX int size = (int) TypedValue.applyDimension(TypedValue.COMPLEX_UNIT_SP, mTextSize, getResources().getDisplayMetrics()); mTextPaint.setTextSize(size); mTextPaint.setAntiAlias(true); mTextPaint.setColor(mTextColor); mTextPaint.setTextAlign(Paint.Align.LEFT); } @Override protected void onDraw(Canvas canvas) { super.onDraw(canvas); int paddingLeft = getPaddingLeft(); int paddingRight = getPaddingRight(); int paddingTop = getPaddingTop(); int paddingBottom = getPaddingBottom(); int circleWidth = getWidth() - paddingLeft - paddingRight; int circleHeight = getHeight() - paddingTop - paddingBottom; int radius = Math.min(circleWidth, circleHeight) / 2; int left = getLeft() + paddingLeft; int right = left + radius * 2; int top = getTop() + getPaddingTop(); int bottom = top + 2 * radius; canvas.drawArc(left, top, right, bottom, START_SWEEP_ANGLE, MAX_SWEEP_ANGLE, false, mBgPaint); int sweepArc = MAX_SWEEP_ANGLE * progress / mMaxProgress; canvas.drawArc(left, top, right, bottom, START_SWEEP_ANGLE, sweepArc, false, mCirclePaint); String text = String.valueOf(progress) + &quot;%&quot;; mTextPaint.getTextBounds(text, 0, text.length(), mTextBound); canvas.drawText(text, (left + right) / 2 - mTextBound.width() / 2, (top + bottom) / 2 + mTextBound.height() / 2, mTextPaint); } /** * 设置进度大小 */ public void setProgress(int progress) { if (progress &lt; 0 || progress &gt; mMaxProgress) { return; } this.progress = progress; invalidate(); } /** * 设置最大进度值 */ public void setMaxProgress(int maxProgress) { this.mMaxProgress = maxProgress; }} 6. 源码 源码已上传Github，后续自定义View的学习Demo也会陆续上传 CustomViewDemo 最后 关注「码道长」，了解最前沿的技术知识，抬高自己的天花板。","link":"/2017/10/13/《Android 进阶（一）》 自定义View之仪表盘进度条/"},{"title":"《Android 进阶（二）》 自定义View之Dota2能力雷达图","text":"1. 前言 最近看Dota2的比赛的时候无意在一个应用中看到来一个能力分析的雷达图，就是展示你的各方面数据。你可能看见过这个图。 2. 实现思路 继承View，复写onDraw。 确定N边形和每个边对应的角度； 确定多边形外接圆的半径以及圆心（也就是中心点） 确定每条半径上的所有点的坐标。 确定每条数据在图形上的坐标； 确定文字在图形上的位置； 采用合适的绘制方式绘制； 3. 实现 3.1 定义自定义属性 主要定义这几个属性，可以根据需要继续扩展。 1234567891011121314&lt;declare-styleable name=&quot;CustomRadarChart&quot;&gt; &lt;!-- 蜘蛛网线条宽度 --&gt; &lt;attr name=&quot;radarLineWidth&quot; format=&quot;dimension&quot;/&gt; &lt;!-- 蜘蛛网颜色 --&gt; &lt;attr name=&quot;radarLineColor&quot; format=&quot;color&quot;/&gt; &lt;!-- 半径分成N段--&gt; &lt;attr name=&quot;radarLineSegments&quot; format=&quot;integer&quot;/&gt; &lt;!-- 文字颜色 --&gt; &lt;attr name=&quot;radarTextColor&quot; format=&quot;color&quot;/&gt; &lt;!-- 文字字体大小--&gt; &lt;attr name=&quot;radarTextSize&quot; format=&quot;integer&quot;/&gt; &lt;!-- 数据展示覆盖区域颜色 --&gt; &lt;attr name=&quot;radarCoverColor&quot; format=&quot;color&quot;/&gt;&lt;/declare-styleable&gt; 3.2 自定义View代码 注释代码中都有写出来，主要是看下实现的方式。没有过多的修饰和精简。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326public class CustomRadarChart extends View { /** * N 边形，默认为6边形 */ private final int DEFAULT_PIECE_NUMBER = 7; /** * 线条宽度，默认为10px */ private final int DEFAULT_LINE_WIDTH = 4; /** * 线条颜色,默认为灰色 */ private final int DEFAULT_LINE_COLOR = 0xffd0d6dc; /** * 半径分成N段,默认为4段，圆心算一段 */ private final int DEFAULT_LINE_SEGMENTS = 4; /** * 外接圆半径，默认为50px */ private final int DEFAULT_RADIUS = 50; /** * 文本颜色和文本字体, 默认为黑色，10px */ private final int DEFAULT_TEXT_COLOR = 0xff647d91; private final int DEFAULT_TEXT_SIZE = 10; /** * 覆盖面绘制颜色 */ private final int DEFAULT_COVER_COLOR = 0x55ced6dc; private int mPieceNumber = DEFAULT_PIECE_NUMBER; private int mRadius = DEFAULT_RADIUS; private int mLineWidth = DEFAULT_LINE_WIDTH; private int mLineColor = DEFAULT_LINE_COLOR; private int mLineSegments = DEFAULT_LINE_SEGMENTS; private int mTextColor = DEFAULT_TEXT_COLOR; private int mTextSize = DEFAULT_TEXT_SIZE; private int mCoverColor = DEFAULT_COVER_COLOR; private double mAverageAngle = 0; private Paint mRadarPaint; private TextPaint mTextPaint; private Paint mCoverPaint; private Path mCoverPath; List&lt;RadarPoints&gt; mRadarPointses = new ArrayList&lt;&gt;(); List&lt;RadarEntry&gt; mRadarEntries = new ArrayList&lt;&gt;(); List&lt;PointF&gt; mCoverPoints = new ArrayList&lt;&gt;(); List&lt;PointF&gt; mTextPoints = new ArrayList&lt;&gt;(); /** * 外接圆中心位置 */ private int mPositionX = 0; private int mPositionY = 0; public CustomRadarChart(Context context) { this(context, null); } public CustomRadarChart(Context context, @Nullable AttributeSet attrs) { this(context, attrs, 0); } public CustomRadarChart(Context context, @Nullable AttributeSet attrs, int defStyleAttr) { super(context, attrs, defStyleAttr); TypedArray attributes = getContext().obtainStyledAttributes(attrs, R.styleable.CustomRadarChart); mLineWidth = (int) attributes.getDimension(R.styleable.CustomRadarChart_radarLineWidth, DEFAULT_LINE_WIDTH); mLineColor = attributes.getColor(R.styleable.CustomRadarChart_radarLineColor, DEFAULT_LINE_COLOR); mLineSegments = attributes.getInteger(R.styleable.CustomRadarChart_radarLineSegments, DEFAULT_LINE_SEGMENTS); mTextColor = attributes.getColor(R.styleable.CustomRadarChart_radarTextColor, DEFAULT_TEXT_COLOR); mTextSize = (int) TypedValue.applyDimension(TypedValue.COMPLEX_UNIT_SP, attributes.getInteger(R.styleable.CustomRadarChart_radarTextSize, DEFAULT_TEXT_SIZE), getResources().getDisplayMetrics()); mCoverColor = (int) attributes.getColor(R.styleable.CustomRadarChart_radarCoverColor, DEFAULT_COVER_COLOR); init(); } private void init() { /** * 蜘蛛网Paint初始化 */ mRadarPaint = new Paint(); mRadarPaint.setColor(mLineColor); mRadarPaint.setStrokeWidth(mLineWidth); mRadarPaint.setAntiAlias(true); mRadarPaint.setStyle(Paint.Style.STROKE); /** * 文字绘制Paint初始化 */ mTextPaint = new TextPaint(); mTextPaint.setColor(mTextColor); mTextPaint.setTextSize(mTextSize); mTextPaint.setAntiAlias(true); mTextPaint.setStyle(Paint.Style.STROKE); /** *覆盖面绘制Paint初始化 */ mCoverPaint = new Paint(); mCoverPaint.setColor(mCoverColor); mCoverPaint.setAntiAlias(true); mCoverPaint.setStyle(Paint.Style.FILL); mCoverPath = new Path(); } @Override protected void onSizeChanged(int w, int h, int oldw, int oldh) { super.onSizeChanged(w, h, oldw, oldh); mPositionX = w / 2; mPositionY = h / 2; mAverageAngle = 360.0 / mPieceNumber; int max = 0; for(RadarEntry entry : mRadarEntries) { Rect textBound = new Rect(); mTextPaint.getTextBounds(entry.title, 0, entry.title.length(), textBound); max = Math.max(textBound.width(), max); } mRadius = Math.min(w / 2 - max, h / 2); if (mRadarEntries==null || mRadarEntries.size()==0) { throw new NullPointerException(&quot;请先设置数据集&quot;); } /** * 计算每一条轴线上的所有点 */ for (int i = 0; i &lt; mPieceNumber; i++) { List&lt;PointF&gt; pointFs = new ArrayList&lt;&gt;(); for (int j = 0; j &lt; mLineSegments; j++) { PointF point = new PointF(); double percent = j * 1.0 / (mLineSegments - 1); point.set(getPloygonX(mAverageAngle * i, percent), getPloygonY(mAverageAngle * i, percent)); pointFs.add(point); } RadarPoints radarPoints = new RadarPoints(i, pointFs); mRadarPointses.add(radarPoints); } /** * 根据数据集计算覆盖多变形的点 */ for (int m = 0; m &lt; mPieceNumber; m++) { PointF pointF = new PointF(); double percent = mRadarEntries.get(m).level / 100.0; pointF.set(getPloygonX(mAverageAngle * m, percent), getPloygonY(mAverageAngle * m, percent)); mCoverPoints.add(pointF); } /** * 设置文字显示位置 */ for (int m = 0; m &lt; mPieceNumber; m++) { PointF pointF = new PointF(); String title = mRadarEntries.get(m).title; Rect textBound = new Rect(); mTextPaint.getTextBounds(title, 0, title.length(), textBound); float boundx = mRadarPointses.get(m).getPointFs().get(mLineSegments -1).x; float boundy = mRadarPointses.get(m).getPointFs().get(mLineSegments -1).y; if( boundx &gt; mRadius &amp;&amp; boundy &lt;= mRadius) { pointF.set(getPloygonX(mAverageAngle * m, 1), getPloygonY(mAverageAngle * m, 1) - textBound.height()*2) ; } else if ( boundx &lt;= mRadius &amp;&amp; boundy &lt;= mRadius){ pointF.set(getPloygonX(mAverageAngle * m, 1) - textBound.width(), getPloygonY(mAverageAngle * m, 1) - textBound.height()*2); } else if( boundx &lt;= mRadius &amp;&amp; boundy &gt; mRadius) { pointF.set(getPloygonX(mAverageAngle * m, 1) - textBound.width(), getPloygonY(mAverageAngle * m, 1) ); } else { pointF.set(getPloygonX(mAverageAngle * m, 1), getPloygonY(mAverageAngle * m, 1)); } mTextPoints.add(pointF); } } /** * 设置数据集，数据集的index决定位置，顺时针方向，起始角度为0度 */ public void setRadatEntries(List&lt;RadarEntry&gt; entries) { this.mRadarEntries = entries; mPieceNumber = entries.size(); postInvalidate(); } @Override protected void onDraw(Canvas canvas) { super.onDraw(canvas); /** * 绘制中心点 */ canvas.drawPoint(mPositionX, mPositionY, mRadarPaint); /** * 绘制蜘蛛网 */ for (int i = 0; i &lt; mLineSegments; i++) { for (int j = 0; j &lt; mPieceNumber - 1; j++) { canvas.drawLine(mRadarPointses.get(j).getPointFs().get(i).x, mRadarPointses.get( j).getPointFs().get(i).y, mRadarPointses.get(j + 1).getPointFs().get(i).x, mRadarPointses.get( j + 1).getPointFs().get(i).y, mRadarPaint); } canvas.drawLine(mRadarPointses.get(mPieceNumber - 2).getPointFs().get(i).x, mRadarPointses.get(mPieceNumber - 2).getPointFs().get(i).y, mRadarPointses.get(mPieceNumber - 1).getPointFs().get(i).x, mRadarPointses.get( mPieceNumber - 1).getPointFs().get(i).y, mRadarPaint); canvas.drawLine(mRadarPointses.get(mPieceNumber - 1).getPointFs().get(i).x, mRadarPointses.get(mPieceNumber - 1).getPointFs().get(i).y, mRadarPointses.get(0).getPointFs().get(i).x, mRadarPointses.get( 0).getPointFs().get(i).y, mRadarPaint); } /** * 绘制轴线 */ for (int k = 0; k &lt; mPieceNumber; k++) { canvas.drawLine(mRadarPointses.get(k).getPointFs().get(0).x, mRadarPointses.get(k).getPointFs().get(0).y, mRadarPointses.get(k).getPointFs().get(mLineSegments - 1).x, mRadarPointses.get( k).getPointFs().get(mLineSegments - 1).y, mRadarPaint); } /** * 绘制数据 */ if (mCoverPoints != null &amp;&amp; mCoverPoints.size() == mPieceNumber) { mCoverPath.reset(); mCoverPath.moveTo(mCoverPoints.get(0).x, mCoverPoints.get(0).y); for (int i = 1; i &lt; mPieceNumber; i++) { mCoverPath.lineTo(mCoverPoints.get(i).x, mCoverPoints.get(i).y); } mCoverPath.close(); canvas.drawPath(mCoverPath, mCoverPaint); } else { throw new NullPointerException(&quot;请先设置数据集&quot;); } /** * 绘制文字,使用StaticLayout进行换行文字的绘制 */ for (int i = 0; i &lt; mPieceNumber; i++) { canvas.save(); String str= mRadarEntries.get(i).title + &quot;\\r\\n&quot; + Math.floor(mRadarEntries.get(i).level*10)/10; StaticLayout layout = new StaticLayout(str, mTextPaint, 300, Layout.Alignment.ALIGN_NORMAL, 1.0F, 0.0F, true); canvas.translate(mTextPoints.get(i).x,mTextPoints.get(i).y); layout.draw(canvas); canvas.restore(); } } public float getPloygonX(double angle, double percent) { return Float.parseFloat( String.valueOf( mPositionX + Math.cos(angle / 360.0 * 2 * Math.PI) * mRadius * percent)); } public float getPloygonY(double angle, double percent) { return Float.parseFloat(String.valueOf( mPositionY + Math.sin(angle / 360.0 * 2 * Math.PI) * mRadius * percent)); } /** * 雷达图数据载体 */ public static class RadarEntry { private String title; private Float level; public RadarEntry(String title, float level) { this.title = title; this.level = level; } } /** * 每一条线上的所有点集合 */ public class RadarPoints { int index; List&lt;PointF&gt; mPointFs; public RadarPoints(int index, List&lt;PointF&gt; pointFs) { this.index = index; mPointFs = pointFs; } public int getIndex() { return index; } public void setIndex(int index) { this.index = index; } public List&lt;PointF&gt; getPointFs() { return mPointFs; } public void setPointFs(List&lt;PointF&gt; pointFs) { mPointFs = pointFs; } }} 可能画图过程中的实现方式优点粗糙，大家可以根据自己的方式，改写即可。 个人是先将每条半径上的端点全部计算出来进行保存，然后一次连接，然后把每个半径首尾端点连接，然后绘制覆盖区域，覆盖区域也是采用先计算点位置，然后连接的方式实现，最后确定文本的显示位置和文字的绘制。由于这里涉及到绘制换行文字，使用到来StaticLayout。使用方法请查阅对应API。 4. 效果 5. 源码 源码依然是上传到Github CustomViewDemo","link":"/2017/10/17/《Android 进阶（二）》 自定义View之Dota2能力雷达图/"},{"title":"《Android开源库》 Google 最新Hover Menu(悬浮菜单)","text":"简介 Hover，这些天大家讨论的比较多的一个开源库，google组织下的一个项目，但是项目介绍中又出现了 Why ? 但是这和我又有什么关系，我是来看源码的，优秀的开源代码，不关心出处。 …………_ 官网Demo ##简单使用 自定义MyNavigationContent，用来显示每个不同的Tab下的内容页 1234567891011121314151617181920212223242526272829303132333435public class MyNavigationContent extends FrameLayout implements NavigatorContent { private ImageView imageViewLogo; private TextView textViewTitle; private int imageResId; private String title; public MyNavigationContent(@NonNull Context context, int imageRedId, String title) { super(context); this.imageResId = imageRedId; this.title = title; init(); } private void init() { LayoutInflater.from(getContext()).inflate(R.layout.view_content_text_icon, this, true); imageViewLogo = (ImageView) findViewById(R.id.iv_logo); textViewTitle = (TextView) findViewById(R.id.tv_title); imageViewLogo.setImageResource(imageResId); textViewTitle.setText(title); } @NonNull @Override public View getView() { return this; } @Override public void onShown(@NonNull Navigator navigator) { } @Override public void onHidden() { }} 2.自定义HoverMenuAdapter，用于将tab和NavigationContent联系起来 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758public class HoverDemoMenuAdapter implements HoverMenuAdapter { private final Context mContext; private final List&lt;String&gt; mTabIds; private final Map&lt;String, NavigatorContent&gt; mData; private final Set&lt;ContentChangeListener&gt; mContentChangeListeners = new HashSet&lt;&gt;(); public HoverDemoMenuAdapter(@NonNull Context context, @NonNull Map&lt;String, NavigatorContent&gt; data) throws IOException { mContext = context; mData = data; mTabIds = new ArrayList&lt;&gt;(); for (String tabId : mData.keySet()) { mTabIds.add(tabId); } } @Override public int getTabCount() { return mTabIds.size(); } @Override public View getTabView(int index) { ImageView imageView = new ImageView(mContext); imageView.setBackgroundResource(R.drawable.bg); switch (index) { case 0: imageView.setImageResource(R.drawable.bike);break; case 1: imageView.setImageResource(R.drawable.run);break; case 2: imageView.setImageResource(R.drawable.android);break; default:break; } imageView.setPadding(30,30,30,30); return imageView; } @Override public long getTabId(int position) { return position; } @Override public NavigatorContent getNavigatorContent(int index) { String tabId = mTabIds.get(index); return mData.get(tabId); } @Override public void addContentChangeListener(@NonNull ContentChangeListener listener) { mContentChangeListeners.add(listener); } @Override public void removeContentChangeListener(@NonNull ContentChangeListener listener) { mContentChangeListeners.remove(listener); }} 3.创建继承HoverMenuService的自定义Service 12345678910111213141516171819202122232425262728293031323334353637383940414243public class HoverDemoService extends HoverMenuService { private HoverDemoMenuAdapter mDemoHoverMenuAdapter; /*显示悬浮按钮*/ public static void showFloatingMenu(Context context) { context.startService(new Intent(context, HoverDemoService.class)); } @Override protected HoverMenuAdapter createHoverMenuAdapter() { try { Map&lt;String, NavigatorContent&gt; data = new HashMap&lt;&gt;(); /*添加tab和对应的NavigationContent*/ data.put(&quot;1&quot;, new MyNavigationContent(this, R.drawable.bike, &quot;1，自行车是克服心脏功能毛病的最佳工具之一。世界上有半数以上的人是死于心脏病的，骑单车不只能藉腿部的运动压缩血液流动，以及把备注从血管末梢抽回心脏，事实上却同时强化了微血管组织，这叫“附带循环”。强化血管可以使你不受年龄的威胁，青春永驻。 \\n&quot; + &quot;2，习惯性的单车运动，更能扩大你的心脏。否则血管愈来愈细，心脏愈来愈退化，到了晚年，你就会体验到它所带来的烦恼，那时你会发现，自行车运动是多么的完美。单车是需要大量氧气的运动，曾经有个老年人以6天时间，完成了460公里的单车旅行。他说：“老年人一周至少要有3次运动，使心脏强化起来，恢复正常功能。你要使心脏激烈跳动，但不可过久。如此它将能适应紧急状况，如赶车或抵抗困境。”\\n&quot; + &quot;3，单车运动同时也能防止高血压，有时比药物更有效。还能防止发胖、血管硬化，并使骨骼强半。自行车使你不必用药物来维持健康，而且毫无害处。&quot;)); data.put(&quot;2&quot;, new MyNavigationContent(this,R.drawable.run, &quot;1.告别臃肿身材。\\n&quot; + &quot;\\n&quot; + &quot;许多人开始跑步就是因为减肥，跑步确实减肥的最好运动方式，跑步每分钟比起其他运动燃烧更多的卡路里。\\n&quot; + &quot;\\n&quot; + &quot;2.防止你的骨骼，肌肉退化。\\n&quot; + &quot;\\n&quot; + &quot;我们的骨骼是和你的身体需求相互协调的。长期坐在显示器前的我们让我们的骨骼越来越脆弱。而长期的，经常的运动会使你的骨骼保持健康。更进一步说就是防止我们身体内部老化的更快。经常的高强度锻炼，例如跑步，被证明可以促进人体荷尔蒙的生长，荷尔蒙就是那些名人为了看起来更年轻而持续注射的药剂。\\n&quot; + &quot;\\n&quot; + &quot;3.抵抗疾病\\n&quot; + &quot;\\n&quot; + &quot;跑步可以降低得中风和乳腺癌的风险。经常的跑步已经成为医生对那些容易引发或在已经处在早期的骨质疏松，糖尿病，高血压病人的治疗建议。\\n&quot; + &quot;\\n&quot; + &quot;4.维持并提高总体的身体水平。\\n&quot; + &quot;\\n&quot; + &quot;跑步是是人们可以采取的最好的锻炼身体的运动。它可以提高胆固醇,降低血液凝块的危险，锻炼你的50%的经常处于闲置状态的肺。跑步还可以通过增加你的淋巴细胞来增强你的免疫力。\\n&quot; + &quot;\\n&quot; )); data.put(&quot;3&quot;, new MyNavigationContent(this,R.drawable.android,&quot;Android是一种基于Linux的自由及开放源代码的操作系统，主要使用于移动设备，如智能手机和平板电脑，由Google公司和开放手机联盟领导及开发。尚未有统一中文名称，中国大陆地区较多人使用“安卓”或“安致”。Android操作系统最初由Andy Rubin开发，主要支持手机。2005年8月由Google收购注资。2007年11月，Google与84家硬件制造商、软件开发商及电信营运商组建开放手机联盟共同研发改良Android系统。随后Google以Apache开源许可证的授权方式，发布了Android的源代码。第一部Android智能手机发布于2008年10月。Android逐渐扩展到平板电脑及其他领域上，如电视、数码相机、游戏机等。2011年第一季度，Android在全球的市场份额首次超过塞班系统，跃居全球第一。 2013年的第四季度，Android平台手机的全球市场份额已经达到78.1%。[1] 2013年09月24日谷歌开发的操作系统Android在迎来了5岁生日，全世界采用这款系统的设备数量已经达到10亿台。&quot;)); /*创建Adapter*/ mDemoHoverMenuAdapter = new HoverDemoMenuAdapter(this, data); return mDemoHoverMenuAdapter; } catch (IOException e) { throw new RuntimeException(e); } }} 4.入口Activity中设置一个点击事件显示悬浮框 1234567891011121314151617public class DeActivity extends AppCompatActivity { Button btShow; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_de); btShow = (Button)findViewById(R.id.bt_show); btShow.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View v) { HoverDemoService.showFloatingMenu(DeActivity.this); } }); }} ##实际效果 ##写在最后 博文内容基于如下版本 1compile &apos;io.mattcarroll.hover:hover:0.9.6&apos; 个人创建类的方式和Github上推荐的使用方式是相反的，依据个人习惯使用即可。","link":"/2017/01/23/《Android开源库》 Google 最新Hover Menu(悬浮菜单)/"},{"title":"《Android开源库》 MPAndroidChart Wiki(译文)～Part 4","text":"16. 动画 注意：本章的动画效果只会在API 11（Android3.0.x）及以上的Android版本上生效 在低于上述的Android版本中，动画将不会被执行，并不会导致程序崩溃。 所有类型的图标都可以用一种看上去比较炫酷的动画效果来进行构建。 三种不同的动画方法来让我们在X轴，Y轴或则两个轴同时显示动画效果。 方法 | 使用 --------------------------------------- | ------------------------------- animateX(int durationMillis) | X水平轴的图表值动画，这意味着在指定的时间内从左到右 建立图表 animateY(int durationMillis) | 垂直轴的图表值动画，这意味着在指定的时间内从下到上 建立图表。 animateXY(int xDuration, int yDuration) | 两个轴的图表值动画，从左到右，从下到上 建立图表。 12345mChart.animateX(3000); // animate horizontal 3000 milliseconds// or:mChart.animateY(3000); // animate vertical 3000 milliseconds// or:mChart.animateXY(3000, 3000); // animate horizontal and vertical 3000 milliseconds 任意一种 animate(…) 动画方法被调用后，无需再调用 invalidate() 方法。 16.1 缓动动画 这个库可以让你对动画应用”缓动函数”。 你可以选择以下预定义的静态 Easing.EasingOption : 123456789101112131415161718192021222324252627282930public enum EasingOption { Linear, EaseInQuad, EaseOutQuad, EaseInOutQuad, EaseInCubic, EaseOutCubic, EaseInOutCubic, EaseInQuart, EaseOutQuart, EaseInOutQuart, EaseInSine, EaseOutSine, EaseInOutSine, EaseInExpo, EaseOutExpo, EaseInOutExpo, EaseInCirc, EaseOutCirc, EaseInOutCirc, EaseInElastic, EaseOutElastic, EaseInOutElastic, EaseInBack, EaseOutBack, EaseInOutBack, EaseInBounce, EaseOutBounce, EaseInOutBounce,} 基本上，有以下两种方式进行 easing 你的动画。 预定义的缓动选项：（下面代码可在所有 Android 版本运行） 1public void animateY(int durationmillis, Easing.EasingOption option); 例如，调用带有预定义缓动选项的动画方法 12// animate both axes with easingmChart.animateY(3000, Easing.EasingOption.EaseOutBack); 当你想代码运行在 Android 3.0 (API 11) 以下时，要使用 Easing.EasingOption 。 自定义缓动函数（在 Android 3.0 自定义缓动函数会使应用 crash）： 1public void animateY(int durationmillis, EasingFunction function); 通过创建你自己的easing-function类并且实现EasingFunction接口，你可以实现你自己的easing功能 12345678910/** * Interface for creating custom made easing functions. */ public interface EasingFunction { /** * Called everytime the animation is updated. * @param input - the time passed since the animation started (value between 0 and 1) */ public float getInterpolation(float input); } 然后，按照如下方式使用(注意，这个不能在小于Android3.0的版本上使用，将会导致程序崩溃) 12// animate both axes with easingmChart.animateY(3000, new MyEasingFunction()); 17. IMarker接口 自版本v3.0.0以来，图表中的标记（弹出窗口）由IMarker接口表示。 17.1 IMarker接口 这个接口可以帮助你实现在图表中条目高亮的时候显示自定义的Marker窗口。这个接口给我们提供了如下需要实现的方法： 123456789101112131415161718192021222324252627282930313233343536373839public interface IMarker { /** * @return The desired (general) offset you wish the IMarker to have on the x- and y-axis. * By returning x: -(width / 2) you will center the IMarker horizontally. * By returning y: -(height / 2) you will center the IMarker vertically. */ MPPointF getOffset(); /** * @return The offset for drawing at the specific `point`. This allows conditional adjusting of the Marker position. * If you have no adjustments to make, return getOffset(). * * @param posX This is the X position at which the marker wants to be drawn. * You can adjust the offset conditionally based on this argument. * @param posY This is the X position at which the marker wants to be drawn. * You can adjust the offset conditionally based on this argument. */ MPPointF getOffsetForDrawingAtPos(float posX, float posY); /** * This method enables a specified custom IMarker to update it&apos;s content every time the IMarker is redrawn. * * @param e The Entry the IMarker belongs to. This can also be any subclass of Entry, like BarEntry or * CandleEntry, simply cast it at runtime. * @param highlight The highlight object contains information about the highlighted value such as it&apos;s dataset-index, the * selected range or stack-index (only stacked bar entries). */ void refreshContent(Entry e, Highlight highlight); /** * Draws the IMarker on the given position on the screen with the given Canvas object. * * @param canvas * @param posX * @param posY */ void draw(Canvas canvas, float posX, float posY);} 17.2 创建一个标记视图 为了创建一个自定义的标记视图，你需要创建一个实现了IMarker接口的类： 1public class YourMarkerView implements IMarker { ... } 实现IMarker接口时返回什么样的值，完全取决于你自己的需求。所以，看看上面关于每个方法的介绍是很有必要的。 除了通过实现IMarker接口来创建自己的标记视图，我们还可以通过继承下面提到的一个类来达到同样的目的。这个方法比较简单，并且我们也不需要实现IMarker接口中的所有方法。只有几个特定的方法需要我们复写和自定义。最重要的是复写refreshContent（…）方法来调整标记视图中的数据。一个简单的示例如下： 1234567891011121314151617181920212223242526272829303132333435public class YourMarkerView extends MarkerView { private TextView tvContent; public MyMarkerView(Context context, int layoutResource) { super(context, layoutResource); // find your layout components tvContent = (TextView) findViewById(R.id.tvContent); } // callbacks everytime the MarkerView is redrawn, can be used to update the // content (user-interface) @Override public void refreshContent(Entry e, Highlight highlight) { tvContent.setText(&quot;&quot; + e.getY()); // this will perform necessary layouting super.refreshContent(e, highlight); } private MPPointF mOffset; @Override public MPPointF getOffset() { if(mOffset == null) { // center the marker horizontally and vertically mOffset = new MPPointF(-(getWidth() / 2), -getHeight()); } return mOffset; }} 17.3 获取／设置Marker 给图表设置一个Marker，使用setMarker(…)方法： 12IMarker marker = new YourMarkerView();chart.setMarker(marker); 要访问图表上的一个Marker，使用getMarker()方法： 1IMarker marker = chart.getMarker(); 17.4 预定义Markers 除了你自定义的MarkerView，开源库中也给我们提供了几个预定义的markers以供方便快捷的使用。其中包括： MarkerView :基本marker。允许提供布局文件作为图表上呈现的标记。继承这个类并且复写refreshContent(…)方法来调整标记视图中的内容。 MarkerImage:一种绘制图片的标记视图。允许提供一个图片资源作为图表上的标记视图。继承这个类并且复写refreshContent(…)方法来调整标记视图中的内容。 17.5 旧版MarkerView 版本v3.0.0 之前，MarkerView类负责在图表高亮部分绘制标记视图。详情请查阅老版的the old MarkerView wiki page. 18. ChartData类 本章旨在让你更深入的了解MPAndroidChart中的数据模型。 ChartData类是像LineData，BarData等等这些数据类的父类。setData()方法可以将数据设置到图表中。 1public class LineData extends ChartData { ...} 下面介绍一些ChartData类中的方法，可以直接在它的子类中使用。 18.1 数据样式方法 | 使用 ----------------------------------- | ----------------------------------------------------------------- setValueTextColor(int color) | 设置 DataSets 数据对象包含的数据的值文本的颜色 setValueTextColors(List colors) | 设置一个颜色列表用于显示值 setValueTextSize(float size) | 设置 DataSets 数据对象包含的数据的值文本的大小（单位是dp） setValueTypeface(Typeface tf) | 设置 DataSets 数据对象包含的数据的值文本的字体 setValueFormatter(ValueFormatter f) | 为DataSets 数据对象包含的数据设置自定义的 ValueFormatter。更多关于ValueFormatter，请查阅此处 setDrawValues(boolean enabled) | 启用/禁用 绘制所有 DataSets 数据对象包含的数据的值文本 18.2 Getter方法方法 | 使用 ---------------------------- | ------------------------------------------------ getDataSetByIndex(int index) | 返回目标 DataSet 列表中给定索引的数据对象。 contains(Entry entry) | 检查此数据对象是否包含指定的Entry 。 注：这个相当影响性能，性能严峻情况下，不要过度使用。 contains(T dataSet) | 如果数据中包含指定dataSet,返回true否则返回false 18.3 清除方法 | 使用 ------------- | -------------------------------------------------- clearValues() | 清除所有 DataSet 对象和所有 Entries 的数据 。 不会删除所提供的 x-values 18.4 选中高亮方法 | 使用 ---------------------------------------------------- | ------------------------------------------ setHighlightEnabled(boolean enabled) | 设置为true，允许通过点击高亮突出 ChartData 对象和其 DataSets setDrawVerticalHighlightIndicator(boolean enabled) | 启用／即用纵向选中高亮指示线。如果禁用，指示线将不会被绘制 setDrawHorizontalHighlightIndicator(boolean enabled) | 用／即用横向选中高亮指示线。如果禁用，指示线将不会被绘制 18.5 动态数据方法 | 使用 ------------------- | -------------------------- notifyDataChanged() | 通知数据对象，底层数据发生变化，候执行所有必需的计算想了解如何在数据对象上增加或者移除数据，请查阅dynamic &amp; realtime data章节","link":"/2017/06/17/《Android开源库》 MPAndroidChart Wiki(译文)～Part 4/"},{"title":"《Android开源库》 MPAndroidChart Wiki(译文)～Part 5","text":"19. ChartData子类 这篇wiki主要关注ChartData子类的具体介绍。至于此部分没有提及到的ChartData的子类，代表他们没有特性功能需要介绍。 BarData方法 | 使用 ---------------------------- | -------------------------------------------------- setGroupSpace(float percent) | 按照一个栏的总宽度的百分比设置不同数据集的条形组之间的空间.100%代表一个条形的宽度。默认为80% isGrouped() | 如果此数据对象分组（由多个DataSet组成），则返回true，否则返回false ScatterData方法 | 使用 ---------------------- | ----------------------------------- getGreatestShapeSize() | 返回此数据对象包含的所有ScatterDataSets的最大形状大小。 PieData方法 | 使用 -------------------------- | ------------------------------------------- getDataSet() | 返回包含的PieDataSet对象。PieData不能包含多个PieDataSet对象 setDataSet(PieDataSet set) | 设置PieDataSet BubbleData方法 | 使用 ------------------------------------ | ---------------------------------------------------- setHighlightCircleWidth(float width) | 设置当数据对象包含的所有BubbleDataSet对象处于突出显示状态时的环绕该气泡的圆的宽度。单位dp CombinedData 该数据对象被设计为包含所有其他数据对象的实例。使用setData（…）方法提供此对象的数据。这仅用于CombinedChart。 123456789101112131415161718public class CombinedData extends ChartData { // ... public CombinedData(List&lt;String&gt; xVals) { ... } public CombinedData(String[] xVals) { ... } public void setData(LineData data) { ... } public void setData(BarData data) { ... } public void setData(ScatterData data) { ... } public void setData(CandleData data) { ... } // ...} 20. DataSet类（通用样式） DataSet是如LineDataSet,BarDataSet等所有数据集类的基类。 1public class LineDataSet extends DataSet { ... DataSet代表一组或者一类在图表中归结在一起的数据条目集合。设计它的目的是为了将图表中的不同组数据进行逻辑分离。（比如线形图中的特定一条线，柱形图中的特定一组柱形） 以下提到的方法在DataSet类中实现，因此可用于所有子类。 20.1 数据样式方法 | 使用 ----------------------------------- | ---------------------------------------------------------------- setValueTextColor(int color) | 设置 DataSet 数据对象包含的数据的值文本的颜色 setValueTextColors(List colors) | 设置一个颜色列表用于显示值 setValueTextSize(float size) | 设置 DataSet 数据对象包含的数据的值文本的大小（单位是dp） setValueTypeface(Typeface tf) | 设置 DataSet 数据对象包含的数据的值文本的字体 setValueFormatter(ValueFormatter f) | 为DataSet 数据对象包含的数据设置自定义的 ValueFormatter。更多关于ValueFormatter，请查阅此处 setDrawValues(boolean enabled) | 启用/禁用 绘制所有 DataSet 数据对象包含的数据的值文本 以上方法同样适用于ChartData对象，只是操作结果针对的是其包含的所有的DataSet。 20.2 高亮方法 | 使用 ---------------------------------------------------- | ------------------------------------------ setHighlightEnabled(boolean enabled) | 设置为true，允许通过点击高亮突出 ChartData 对象和其 DataSets setDrawVerticalHighlightIndicator(boolean enabled) | 启用／禁用纵向选中高亮指示线。如果禁用，指示线将不会被绘制 setDrawHorizontalHighlightIndicator(boolean enabled) | 启用／禁用横向选中高亮指示线。如果禁用，指示线将不会被绘制 20.3 Getter/Convenience方法 | 使用 --------------------- | ------------------------------------------------ contains(Entry entry) | 检查此数据对象是否包含指定的Entry 。 注：这个相当影响性能，性能严峻情况下，不要过度使用。 21. DataSet子类（特定样式） 本章wiki专注于DataSet类的子类。此处未提及的DataSet的所有其他子类代表它们没有特定的增强功能。 21.1 Line-, Bar-, Scatter-, Bubble- &amp; CandleDataSet方法 | 使用 ---------------------------- | ----------------------------------------------------------------------------------- setHighLightColor(int color) | 设置高亮颜色。不要忘记用getResources().getColor(…) 或者 Color.rgb(…)来解析颜色（或者使用Color.BLACK这种简单的方式） 21.2 Line-, Bar-, Scatter-, Candle- &amp; RadarDataSet方法 | 使用 ------------------------------------------- | ----------------------------------------------------------------------------------------------------- setDrawHighlightIndicators(boolean enabled) | 启用/禁用垂直和水平高亮指示线。调用setDrawVerticalHighlightIndicator（…）和setDrawHorizo​​ntalHighlightIndicator（…）进行单独配置 setHighlightLineWidth(float width) | 设置高亮线（十字准线）的宽度。单位dp 21.3 Line- &amp; RadarDataSet方法 | 使用 ----------------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------- setFillColor(int color) | 设置用于填充线条表面的颜色 setFillAlpha(int alpha) | 设置用于填充线条表面（0-255）的Alpha值（透明度），默认值：85,255 =完全不透明，0 =完全透明 setFillDrawable(Drawable d) | 设置一个可以覆盖填充区域的Drawable。这也允许使用渐变Drawable setDrawFilled(boolean filled) | 如果DataSet需要绘制填充（表面，区域），而不单单是一条线，那么将此项设置为true，禁用此功能将提升性能。请注意，此方法使用canvas.clipPath（…）方法绘制填充区域。对于API级别&amp;lt;18（Android 4.3）的设备，应关闭图表的硬件加速。具体查阅此处,默认为false setLineWidth(float width) | 设置线条宽度（最小=0.2f,最大10f）;默认1f。注意：细线性能更好，粗线性能更差 以下提到的方法仅适用于具体提到的DataSet子类。 21.4 LineDataSet方法 | 使用 ------------------------------------------------------------------ | --------------------------------------------------------------------------------------------- setCircleRadius(float size) | 设置的圆形值指示符的大小（半径），默认大小= 4F setDrawCircles(boolean enabled) | 设置为true启用LineDataSet的圆形指示器。默认为true setDrawCubic(boolean enabled) | 如果设置为true，则线条图线将以立方式而不是线性绘制。这对性能有负面影响！默认值：false setCubicIntensity(float intensity) | 设置立方体线的强度（如果启用）。 Max = 1f =非常立方，Min = 0.05f =低立方效应，默认值：0.2f setCircleColor(int color) | 设置圆形指示器的颜色 setCircleColors(List colors) | 设置此LineDataSet外圈应具有的颜色。还有需要其他的方法来设置外圈的颜色 setCircleColorHole(int color) | 设置内圈的颜色 setDrawCircleHole(boolean enabled) | 设置为true.在绘制内圈，否则不绘制内圈 enableDashedLine(float lineLength, float spaceLength, float phase) | 启动虚线绘制，具体像&quot;- - - - - -&quot;这样. &quot;lineLength&quot;虚线段长度, &quot;spaceLength&quot;虚线段之间的空隙, &quot;phase&quot;是偏移量，以度数为单位（通常为0） 21.5 BarDataSet方法 | 使用 --------------------------------- | ------------------------------------------------------------------------------------- setBarSpacePercent(float percent) | 以总条宽的百分比设置条之间的间距 setBarShadowColor(int color) | 设置用于绘制条形阴影的颜色。条形图的阴影部分是一个用来表示最大值的界面。使用getResources().getColor(…) 或者Color.rgb(…)来设置这个值 setHighLightAlpha(int alpha) | 设置用于绘制高亮指示条的alpha值（透明度）。最小值=0（完全透明），最大值=255（完全不透明） setStackLabels(String[] labels) | 设置不同值的条形堆栈的标签，如果有标签的话 21.6 ScatterDataSet方法 | 使用 ----------------------------------- | ------------------------------- setScatterShapeSize(float size) | 设置绘制的散点图将具有的密度像素的大小。这仅适用于非自定义形状 setScatterShape(ScatterShape shape) | 设置在值所在的位置绘制的形状 21.7 CandleDataSet方法 | 使用 ------------------------------------------ | ------------------------------------------- setBodySpace(float space) | 设置每个蜡烛体左侧和右侧留出的空间，默认为0.1f（10％），最大0.45f，最小0f setShadowWidth(float width) | 设置蜡烛线的宽度，单位dp。默认3f setShadowColor(int color) | 设置蜡烛线的颜色 setDecreasingColor(int color) | 设置当打开&amp;gt;关闭时应该用于此DataSet的唯一的颜色 setIncreasingColor(int color) | 设置当打开&amp;lt;=关闭时应该用于此DataSet的唯一的颜色 setDecreasingPaintStyle(Paint.Style style) | 设置当打开&amp;gt;关闭时的Paint风格（填充或者线条） setIncreasingPaintStyle(Paint.Style style) | 设置当打开&amp;lt;=关闭时的Paint风格（填充或者线条） 21.8 BubbleDataSet方法 | 使用 ------------------------------------ | ------------------------ setHighlightCircleWidth(float width) | 设置在突出显示状态下气泡周围的圆的宽度，单位dp 21.9 PieDataSet方法 | 使用 ------------------------------ | ---------------------------------------- setSliceSpace(float degrees) | 设置饼图切片之间的空隙。默认：0-&amp;gt;没有空隙，最大20，最小0（没有空隙） setSelectionShift(float shift) | 设置此DataSet的突出显示的饼图切片距离图表中心“偏移”的距离，默认为12f","link":"/2017/06/22/《Android开源库》 MPAndroidChart Wiki(译文)～Part 5/"},{"title":"《Android开源库》 Realm For Android~ Adapter &Supporting other library（译文）","text":"Adapter(适配器) Realm提供了一些抽象的工具类来方便地将 OrderedRealmCollection （RealmResults 和 RealmList 都实现了这个借口）展示到UI控件上。 RealmBaseAdapter 可以与 ListView 配合使用。参见示例. RealmRecyclerViewAdapter 可以与 RecyclerView 配合使用。参见示例. 你需要在 app 的 build.gradle 中添加额外的依赖以使用这些适配器。 123dependencies { compile &apos;io.realm:android-adapters:1.4.0&apos;} ####Intent因为你不可以直接通过 intent 传递 RealmObject，我们建议你只传递 RealmObject 的标识符。举个常用例子，假如你的对象拥有一个主键，请通过 intent 的 bundle 来传递这个主键的值。 1234// Assuming we had a person class with a @PrimaryKey on the &apos;id&apos; field ...Intent intent = new Intent(getActivity(), ReceivingService.class);intent.putExtra(&quot;person_id&quot;, person.getId());getActivity().startService(intent); 在接受方（Activty、Service、IntentService、BroadcastReceiver 及其它）从 bundle 中解析出这个主键然后打开 Realm 查询得到这个 RealmObject。 123456// in onCreate(), onHandleIntent(), etc.String personId = intent.getStringExtra(&quot;person_id&quot;);Realm realm = Realm.getDefaultInstance();Person person = realm.where(Person.class).equalTo(&quot;id&quot;, personId).findFirst();// do something with the person ...realm.close(); 可以参考 threading example 中的 Object Passing 部分。该示例展示了在安卓开发中常用的如何传递 id 并且得到对应的 RealmObject。 Android Framework 多线程 API 相关 当你使用下列 API 时请小心： AsyncTask IntentService AsyncTask 的 doInBackground() 方法会运行在一个后台线程。IntentService 的 onHandleIntent(Intent intent) 方法会运行在一个后台工作线程。 如果你需要在这些方法中使用 Realm，请在对 Realm 的调用结束后关闭 Realm 实例。见如下例子。 AsyncTask 在 doInBackground 方法中打开并关闭 Realm，如下所示： 1234567891011121314151617181920212223private class DownloadOrders extends AsyncTask&lt;Void, Void, Long&gt; { protected Long doInBackground(Void... voids) { // Now in a background thread. // Open the Realm Realm realm = Realm.getDefaultInstance(); try { // Work with Realm realm.createAllFromJson(Order.class, api.getNewOrders()); Order firstOrder = realm.where(Order.class).findFirst(); long orderId = firstOrder.getId(); // Id of order return orderId; } finally { realm.close(); } } protected void onPostExecute(Long orderId) { // Back on the Android mainThread // do something with orderId such as query Realm // for the order and perform some operation with it. }} IntentService ChangeListener 在 IntentService 中不会工作。尽管 IntentService 本身是一个 Looper 线程，但每次 onHandleIntent 的调用是独立的事件。你可以注册监听器的调用不会返回失败，但他们永远不会被触发。 在 onHandleIntent() 方法中打开并关闭 Realm，如下所示： 123456789101112131415161718public class OrdersIntentService extends IntentService { public OrdersIntentService(String name) { super(&quot;OrdersIntentService&quot;); } @Override protected void onHandleIntent(Intent intent) { // Now in a background thread. // Open the Realm Realm realm = Realm.getDefaultInstance(); // Work with Realm realm.createAllFromJson(Order.class, api.getNewOrders()); Order firstOrder = realm.where(Order.class).findFirst(); long orderId = firstOrder.getId(); // Id of order realm.close(); }} 对其它库的支持 这个章节描述了怎样与其它 Android 流行库搭配使用 Realm。 GSON GSON 是 Google 开发的 JSON 处理库。GSON 与 Realm 可以无缝配合使用。 12345678910// Using the User classpublic class User extends RealmObject { private String name; private String email; // getters and setters left out ...}Gson gson = new GsonBuilder().create();String json = &quot;{ name : &apos;John&apos;, email : &apos;john@corporation.com&apos; }&quot;;User user = gson.fromJson(json, User.class); GridViewExample 展示了如何配合 GSON 使用 Realm。 序列化（Serialization） 你有时需要序列化与反序列化一个 Realm 对象以便与其它库（比如 Retrofit）相配合。因为 GSON使用成员变量值而非 getter 和 setter ，所以你无法通过 GSON 的一般方法来序列化 Realm 对象。 你需要为 Realm 模型对象自定义一个 JsonSerializer 并且将其注册为一个 TypeAdapter。 请参考这个 Gist。 数组（Primitive lists） 某些 JSON API 会以数组的形式返回原始数据类型（例如 String 和 integer），Realm 暂时不支持对这种数组的处理。但你可以通过自定义 TypeAdapter来处理这种情况。 这个 Gist 展示了如何将 JSON 中的整型数组存入 Realm。类似地，你可以用这个方法来处理其它原始数据类型数组。 Troubleshooting Realm 对象属性可能会包含循环引用。在这种情况下，GSON 会抛出 StackOverflowError。例如如下 Realm 对象拥有一个 Drawable 属性： 12345public class Person extends RealmObject { @Ignore Drawable avatar; // other fields, etc} Person 类含有一个 Android Drawable 并且被 @Ignore 修饰。当 GSON 序列化时，Drawable 被读取并且造成了堆栈溢出。(GitHub Issue)。添加如下代码以避免类似问题： 123public boolean shouldSkipField(FieldAttributes f) { return f.getDeclaringClass().equals(RealmObject.class) || f.getDeclaringClass().equals(Drawable.class);} 请注意对 Drawable.class 的判定语句，它告诉 GSON 跳过这个属性的序列化以避免堆栈溢出错误。 Jackson-databind Jackson-databind 用来绑定 JSON 数据和其对应的 Java 类。 Jackson 需要使用反射进行工作。这与 Realm 的 RxJava 支持有冲突，因为作为可选功能，RxJava 有可能不再工程依赖库中。这会导致类似如下的异常抛出： 123java.lang.NoClassDefFoundError: rx.Observableat libcore.reflect.InternalNames.getClass(InternalNames.java:55) 为了修正这个问题你可以添加 RxJava 依赖到工程中或者创建一个假类文件如下所示： package rx; public class Observable { // Dummy class required for Jackson-Databind support if // RxJava is not a project dependency. } 这个问题也同时报告给了 Jackson 项目。 Kotlin Realm 完全兼容 Kotlin 语言，但有些地方需要注意： 你的模型类需要是开放的（open）。 你可能需要在某些情况下添加注解 @RealmCLass 以保证编译通过。这是由于当前 Kotlin 注解处理器的一个限制。 很多 Realm API 引用了 Java 类。你必须在编译依赖中添加 org.jetbrains.kotlin:kotlin-reflect:${kotlin_version}。 参见示例。 ParcelerParceler 可以帮助对象自动生成支持 Parcelable 接口的样板代码。因为 Realm 的代理类，你需要以下设置以便应用 Parceler 到 Realm 对象。 12345678910// All classes that extend RealmObject will have a matching RealmProxy class created// by the annotation processor. Parceler must be made aware of this class. Note that// the class is not available until the project has been compiled at least once.@Parcel(implementations = { PersonRealmProxy.class }, value = Parcel.Serialization.BEAN, analyze = { Person.class })public class Person extends RealmObject { // ...} 如果你使用 Gradle 来获取 Parceler，请确保存在以下配置代码： 123compile &quot;org.parceler:parceler-api:1.0.3&quot;apt &quot;org.parceler:parceler:1.0.3&quot; 请注意目前在使用 Parceler 的时候有如下的限制： 如果你的模型包含 RealmList，那么你需要注册一个特殊 adapter 一旦对象被打包（parcelled），它将变为一个有当前数据快照，不再被 Realm 管理的一个 unmanaged 对象。之后该对象的数据变化不会被 Realm 写入。 RetrofitRetrofit 是一个由 Square 开发，保证类型安全（typesafe）的 REST API 处理工具。 Realm 可以与 Retrofit 1.x 和 2.x 无缝配合工作。但请注意 Retrofit 不会自动将对象存入 Realm。你需要通过调用 Realm.copyToRealm() 或 Realm.copyToRealmOrUpdate() 来将它们存入 Realm。 1234567GitHubService service = restAdapter.create(GitHubService.class);List&lt;Repo&gt; repos = service.listRepos(&quot;octocat&quot;);// Copy elements from Retrofit to Realm to persist them.realm.beginTransaction();List&lt;Repo&gt; realmRepos = realm.copyToRealmOrUpdate(repos);realm.commitTransaction(); Robolectric 通过 Robolectric 库可以让你在不使用真实设备或者模拟器的情况下直接在 Java 虚拟机上进行 JUnit 测试。但目前 Roboletrics 不支持带有原生库的测试。而 Realm 包含使用 C++ 的原生库，所以你目前不可以通过 Roboletrics 测试使用 Realm 的项目。 你可以关注这个 Robolectric 的新功能请求。 RxJava RxJava 是 Netflix 发布的一个 [Reactive 的扩展 库以支持 观察者模式。 Realm 包含了对 RxJava 的原生支持。如下类可以被暴露为一个 Observable：Realm, RealmResults, RealmObject, DynamicRealm and DynamicRealmObject。 12345678910// Combining Realm, Retrofit and RxJava (Using Retrolambda syntax for brevity)// Load all persons and merge them with their latest stats from GitHub (if they have any)Realm realm = Realm.getDefaultInstance();GitHubService api = retrofit.create(GitHubService.class);realm.where(Person.class).isNotNull(&quot;username&quot;).findAllAsync().asObservable() .filter(persons.isLoaded) .flatMap(persons -&gt; Observable.from(persons)) .flatMap(person -&gt; api.user(person.getGithubUserName()) .observeOn(AndroidSchedulers.mainThread()) .subscribe(user -&gt; showUser(user)); 请注意异步查询不会阻塞当前线程，如上代码会立即返回一个 RealmResults 实例。如果你想确定该 RealmResults 已经加载完成请使用 filter operator 和 RealmResults.isLoaded() 方法。通过判断 RealmResults 是否已经加载可以得知查询是否已经完成。 参考 RxJava sample project。 配置 RxJava 是可选依赖，这意味着 Realm 不会自动包含它。这样做的好处是你可以选择需要的 RxJava 版本以及防止过多的无用方法被打包。如果你要使用相关功能，请手动添加 RxJava 到 build.gradle 文件。 123dependencies { compile &apos;io.reactivex:rxjava:1.1.0&apos;} 你也可以通过继承 RxObservableFactory 来决定 Observable 的生成方式，然后通过 RealmConfiguration 进行配置。 123RealmConfiguration config = new RealmConfiguration.Builder() .rxFactory(new MyRxFactory()) .build() 如果没有 RxObservableFactory 被定义，RealmObservableFactory 会被默认使用，它支持 RxJava &lt;= 1.1.*。 原文链接 https://realm.io/cn/docs/java/latest/","link":"/2017/03/25/《Android开源库》 Realm For Android~ Adapter &Supporting other library（译文）/"},{"title":"《Android开源库》 Realm For Android~ Realm（译文）","text":"Realm Realm(s) 是我们对数据库的称谓：它包含多个不同的对象，并对应磁盘中的一个文件。在使用之前，需要对 Realm 库进行初始化操作： 1Realm.init(context); 你需要提供一个安卓的 Context 对象来对 Realm 进行初始化。初始化操作只要进行一次。继承 Application 并在重载的 onCreate() 方法中进行初始化是个不错的主意。 1234567public class MyApplication extends Application { @Override public void onCreate() { super.onCreate(); Realm.init(this); }} 请别忘了修改 AndroidManifest.xml: 1234&lt;application android:name=&quot;.MyApplication&quot; .../&gt; 配置Realm RealmConfiguration 用来配置要被创建的 Realm 的各种特性。最简配置如下所示： 1RealmConfiguration config = new RealmConfiguration.Builder().build(); 如上配置的 Realm 会被存储在 Context.getFilesDir() 并且命名为 default.realm。 一个典型的配置如下所示： 1234567891011// The RealmConfiguration is created using the builder pattern.// The Realm file will be located in Context.getFilesDir() with name &quot;myrealm.realm&quot;RealmConfiguration config = new RealmConfiguration.Builder() .name(&quot;myrealm.realm&quot;) .encryptionKey(getKey()) .schemaVersion(42) .modules(new MySchemaModule()) .migration(new MyMigration()) .build();// Use the configRealm realm = Realm.getInstance(config); 你还可以有多个RealmConfiguration。如此，你便可以控制Realm的版本、结构（schema）和路径。 1234567891011121314RealmConfiguration myConfig = new RealmConfiguration.Builder() .name(&quot;myrealm.realm&quot;) .schemaVersion(2) .modules(new MyCustomSchema()) .build();RealmConfiguration otherConfig = new RealmConfiguration.Builder() .name(&quot;otherrealm.realm&quot;) .schemaVersion(5) .modules(new MyOtherSchema()) .build();Realm myRealm = Realm.getInstance(myConfig);Realm otherRealm = Realm.getInstance(otherConfig); 你可以使用 Realm.getPath() 来获取 Realm 文件的绝对路径。 很重要的一点是 Realm 实例是线程单例化的，也就是说多次在同一线程调用静态构建器会返回同一 Realm 实例。 默认 RealmConfiguration RealmConfiguration可以保存为默认配置。通过在自定义的Application设置默认的Realm配置，可以使你在代码中的其他地方更加方便地创建针对该默认配置的Realm。 1234567891011121314151617181920212223public class MyApplication extends Application { @Override public void onCreate() { super.onCreate(); // The Realm file will be located in Context.getFilesDir() with name &quot;default.realm&quot; Realm.init(this); RealmConfiguration config = new RealmConfiguration.Builder().build(); Realm.setDefaultConfiguration(config); }}public class MyActivity extends Activity { @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); Realm realm = Realm.getDefaultInstance(); try { // ... Do something ... } finally { realm.close(); } }} In-Memory Realm 定义一个非持久化的、存在于内存中的 Realm 实例： 1234RealmConfiguration myConfig = new RealmConfiguration.Builder() .name(&quot;myrealm.realm&quot;) .inMemory() .build(); 这样就可以创建一个存在于“内存中的” Realm。“内存中的”Realm 在内存紧张的情况下仍有可能使用到磁盘存储，但是这些磁盘空间都会在Realm实例完全关闭的时候被释放。 请注意使用同样的名称同时创建“内存中的”Realm 和常规的（持久化）Realm 是不允许的。 当某个“内存中的”Realm 的所有实例引用都被释放，该 Realm 下的数据也同时会被清除。建议在你的应用生命周期中保持对“内存中的” Realm 实例的引用以避免非期望的数据丢失。 Dynamic Realm 对于普通的 Realm 来说，数据模型被定义成了 RealmObject 的子类。这样做保证了类型安全，但有时候某些数据模型在编译期是无法获得的。例如在处理数据迁移（migration）或CSV文件的时候。 DynamicRealm 是普通 Realm 的一个变种。它可以在没有 RealmObject 子类的情况下操作 Realm 数据。其对数据的访问是基于字符串而非 RealmObject 的定义。 创建 Dynamic Realm 使用与创建普通 Realm 相同的RealmConfiguration，但是它的创建过程会忽略对 schema、migration以及 schema 版本的检查。 123456789101112131415161718RealmConfiguration realmConfig = new RealmConfiguration.Builder().build();DynamicRealm realm = DynamicRealm.getInstance(realmConfig);// In a DynamicRealm all objects are DynamicRealmObjectsDynamicRealmObject person = realm.createObject(&quot;Person&quot;);// All fields are accessed using stringsString name = person.getString(&quot;name&quot;);int age = person.getInt(&quot;age&quot;);// An underlying schema still exists, so accessing a field that does not exist// will throw an exceptionperson.getString(&quot;I don&apos;t exist&quot;);// Queries still work normallyRealmResults&lt;DynamicRealmObject&gt; persons = realm.where(&quot;Person&quot;) .equalTo(&quot;name&quot;, &quot;John&quot;) .findAll(); DynamicRealm 以类型安全和性能为代价，换来了更多的灵活性。请在你确实需要这些灵活性的情况下使用。 关闭Realm实例 Realm 实现了 Closeable 接口以便与释放 native 内存和文件描述符，请务必在使用完毕后关闭 Realm 实例。 Realm 实例是基于引用计数的, 也就是说假设你在同一个线程中调用了 getInstance() 两次，你需要同样调用 close() 两次以关闭该实例。举例来说，如果你需要实现 Runnable，简单地在函数开始的时候调用 getInstance()，在函数结束的时候调用 close() 即可！ 对于UI线程，你可以选择在 onDestroy() 方法内调用 realm.close()。 如果你想使用除 UI 线程外的 Looper 线程，可以参考以下代码： 1234567891011121314151617public class MyThread extends Thread { private Realm realm; public void run() { Looper.prepare(); try { realm = Realm.getDefaultInstance(); //... Setup the handlers using the Realm instance ... Lopper.loop(); } finally { if (realm != null) { realm.close(); } } }} 对于 AsyncTask，这里有个不错的例子可以参考： 12345678910protected Void doInBackground(Void... params) { Realm realm = Realm.getDefaultInstance(); try { // ... Use the Realm instance ... } finally { realm.close(); } return null;} 如果你想使用 Thread 和 Runnable 进行一些短期任务，参考如下代码： 1234567891011121314151617/ Run a non-Looper thread with a Realm instance.Thread thread = new Thread(new Runnable() { @Override public void run() { Realm realm = null; try { realm = Realm.getDefaultInstance(); // ... Use the Realm instance ... } finally { if (realm != null) { realm.close(); } } }});thread.start(); 如果你很幸运地工作在 minSdkVersion &gt;= 19 且 Java &gt;= 7 之下，可以使用try-with-resources： 123try (Realm realm = Realm.getDefaultInstance()) { // No need to close the Realm instance manually} 自动刷新 如果 Realm 实例存在于一个带有 Looper 的线程，那么这个 Realm 实例即具有自动更新的功能。这意味这如果发生了 Realm 数据库的变化，那么该 Realm 实例会在下一个事件循环（event loop）中自动更新。这个便捷的功能使你不必花费太多的精力就能保证的UI与数据的实时同步。 如果 Realm 的实例所在线程没有绑定 Looper，那么该实例不会被更新直到你手动调用 waitForChange() 方法。请注意，不更新 Realm 以保持对旧数据的引用会造成而外的磁盘和内存开销。这也是为什么要在线程结束时调用 close() 关闭 Realm 实例的一个重要原因。 如果你想确定当前 Realm 实例是否有自动更新功能，可以通过调用 isAutoRefresh() 方法查询。 查找 Realm 数据库文件 如果你想知道你应用的 Realm 文件的具体路径，请参见这个 StackOverflow上的答案。 原文链接 https://realm.io/docs/java/latest/#realms","link":"/2017/03/07/《Android开源库》 Realm For Android~ Realm（译文）/"},{"title":"《Android开源库》 Realm For Android~ Scheme & JSON & Notification（译文）","text":"Scheme Realm 使用所有项目中的 Realm 模型类来创建 schema。但这个行为是可以改变的，例如，你可以通过使用 RealmModule 让 Realm 只包含所有模型类的一个子集。 123456789101112131415// Create the module@RealmModule(classes = { Person.class, Dog.class })public class MyModule {}// Set the module in the RealmConfiguration to allow only classes defined by the module.RealmConfiguration config = new RealmConfiguration.Builder() .modules(new MyModule()) .build();// It is possible to combine multiple modules to one schema.RealmConfiguration config = new RealmConfiguration.Builder() .modules(new MyModule(), new MyOtherModule()) .build(); 共享schemas 库（library）开发者请注意： 在库中使用到的 Realm 必须通过 RealmModule 来暴露和使用其 schema。 这样可以防止库项目自动生成默认 RealmModule 从而避免和 app 生成的默认 RealmModule 冲突。库项目也是通过 RealmModule 来向 app 项目暴露自己的 Realm 模型类。 123456789101112131415161718// Library must create a module and set library = true. This will prevent the default// module from being created.// allClasses = true can be used instead of listing all classes in the library.@RealmModule(library = true, allClasses = true)public class MyLibraryModule {}// Library projects are therefore required to explicitly set their own module.RealmConfiguration libraryConfig = new RealmConfiguration.Builder() .name(&quot;library.realm&quot;) .modules(new MyLibraryModule()) .build();// Apps can add the library RealmModule to their own schema.RealmConfiguration config = new RealmConfiguration.Builder() .name(&quot;app.realm&quot;) .modules(Realm.getDefaultModule(), new MyLibraryModule()) .build(); 目前你不可以在一个 Realm 文件里声明多个 RealmModule。如果你有多个 RealmModule，你需要将它们声明在多个 Realm 文件中以确保每个文件只有一个 RealmModule 声明。 这里有一个如何使用在库和 app 项目间使用 RealmModule 的完整例子。 JSON 你可以直接将 JSON 对象添加到 Realm 中，这些 JSON 对象可以是一个 String、一个 JSONObject 或者是一个 InputStream。Realm 会忽略 JSON 中存在但未定义在 Realm 模型类里的字段。单独对象可以通过 Realm.createObjectFromJson() 添加。对象列表可以通过 Realm.createAllFromJson() 添加。 123456789101112131415161718192021222324252627// A RealmObject that represents a citypublic class City extends RealmObject { private String city; private int id; // getters and setters left out ...}// Insert from a stringrealm.executeTransaction(new Realm.Transaction() { @Override public void execute(Realm realm) { realm.createObjectFromJson(City.class, &quot;{ city: \\&quot;Copenhagen\\&quot;, id: 1 }&quot;); }});// Insert multiple items using an InputStreamrealm.executeTransaction(new Realm.Transaction() { @Override public void execute(Realm realm) { try { InputStream is = new FileInputStream(new File(&quot;path_to_file&quot;)); realm.createAllFromJson(City.class, is); } catch (IOException e) { throw new RuntimeException(); } }}); Realm 解析 JSON 时遵循如下规则： 使用包含空值（null）的 JSON 创建对象： 1) 对于非必须（可为空值的属性），设置其值为 null； 2) 对于必须（不可为空值的属性），抛出异常； 使用包含空值（null）的 JSON 更新对象： 1)对于非必须（可为空值的属性），设置其值为 null； 2) 对于必须（不可为空值的属性），抛出异常； 使用不包含对应属性的 JSON： 1)该属性保持不变 通知（Notifications） Listener 只工作于 Looper 线程。对于非 Looper 线程请使用 Realm.waitForChange()。 Realm Notification 当后台线程向 Realm 添加数据，你的 UI 线程或者其它线程可以添加一个监听器来获取数据改变的通知。监听器在 Realm 数据改变的时候会被触发。 12345678910111213141516171819202122232425public class MyActivity extends Activity { private Realm realm; private RealmChangeListener realmListener; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); realm = Realm.getDefaultInstance(); realmListener = new RealmChangeListener() { @Override public void onChange(Realm realm) { // ... do something with the updates (UI, etc.) ... }}; realm.addChangeListener(realmListener); } @Override protected void onDestroy() { super.onDestroy(); // Remove the listener. realm.removeChangeListener(realmListener); // Close the Realm instance. realm.close(); }} 除了在 Realm 实例上添加监听器以外，你还可以在 RealmObject 和 RealmResults 实例上添加监听器。你可以通过这样的方式来监视对象和查询结果的改变。另外，当监听回调函数被调用时，相应的数据已经被更新，你不需要去做刷新操作。 123456789101112131415161718192021222324252627282930313233343536373839404142public class MyActivity extends Activity { private Realm realm; private RealmChangeListener puppiesListener; private RealmChangeListener dogListener; private RealmResults&lt;Dog&gt; puppies; private Dog dog; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); realm = Realm.getDefaultInstance(); puppiesListener = new RealmChangeListener() { @Override public void onChange(RealmResults&lt;Dog&gt; puppies) { // ... do something with the updated puppies instance }}; // Find all the puppies puppies = realm.where(Dog.class).lessThanOrEqualTo(&quot;age&quot;, 2).findAll(); puppies.addChangeListener(puppiesListener); dogListener = new RealmChangeListener() { @Override public void onChange(Dog dog) { // ... do something with the updated Dog instance }}; dog = realm.where(Dog.class).equalTo(&quot;name&quot;, &quot;Fido&quot;).findFirst(); dog.addChangeListener(dogListener); } @Override protected void onDestroy() { super.onDestroy(); // Remove the listeners puppies.removeChangeListener(puppiesListener); dog.removeChangeListener(dogListener); // Close the Realm instance. realm.close(); }} 你可以轻松移除所有监听器。 1realm.removeAllChangeListeners(); 最后，这些监听器同样会在监听对象的引用对象改变时被触发，请见示例 123456789101112131415Person person = realm.where(Person.class).findFirst();person.getDogs(); // =&gt; 2 - Assume there are 2 dogs in the listperson.addChangeListener(new RealmChangeListener() { @Override public void onChange(Person person) { // React to the change in the Person instance. // This will also get called when any referenced dogs are updated. } });Dog dog = person.getDogs().get(0);realm.beginTransaction();dog.setAge(5);realm.commitTransaction();// Person change listener is called on the next iteration of the run loop because// a referenced dog object changed. Collection Notifications 集合通知与Realm通知不同，因为它们包含描述在细粒度级别发生的更改的信息。 这包括自上次通知以来已插入，删除或修改的对象的索引。 集合通知是异步传递的，首先是初始结果，然后是在修改集合中的任何一个或者多个对象的写入事务之后，这个结果都会被重新初始化。 这些更改可以通过传递给更改侦听器的OrderedCollectionChangeSet参数访问。 此对象保存有关由删除，插入和更改影响的索引的信息。 删除和插入，当对象开始和停止是集合的一部分时记录索引。 这会考虑到何时将对象添加到领域或从领域中删除它们。 对于RealmResults，当你筛选特定值并且对象已更改，以使其现在匹配查询或不再匹配时，这也适用。 当对象的字段发生更改时，系统会通知你有关更改的信息，该字段以前是集合的一部分，但仍属于集合的一部分。 当一对一和多对多关系改变时，这种情况也会发生。 123456789public class Dog extends RealmObject { public String name; public int age;}public class Person exteds RealmObject { public String name; public RealmList&lt;Dog&gt; dogs;} 让我们假设你遵守上面的模型代码给出的狗主人列表。 你将收到关于匹配的Person对象的修改的通知，例如： 修改Person的名字 从一个Person拥有的狗的列表中增加或者删除一个 修改属于这个人的一条狗的年龄 这使得可以离散地控制对UI中的内容进行的动画和视觉更新，而不是在每次发生通知时任意重新加载所有内容。 1234567891011121314151617181920212223242526private final OrderedRealmCollectionChangeListener&lt;RealmResults&lt;Person&gt;&gt; changeListener = new OrderedRealmCollectionChangeListener() { @Override public void onChange(RealmResults&lt;Person&gt; collection, OrderedCollectionChangeSet changeSet) { // `null` means the async query returns the first time. if (changeSet == null) { notifyDataSetChanged(); return; } // For deletions, the adapter has to be notified in reverse order. OrderedCollectionChangeSet.Range[] deletions = changeSet.getDeletionRanges(); for (int i = deletions.length - 1; i &gt;= 0; i--) { OrderedCollectionChangeSet.Range range = deletions[i]; notifyItemRangeRemoved(range.startIndex, range.length); } OrderedCollectionChangeSet.Range[] insertions = changeSet.getInsertionRanges(); for (OrderedCollectionChangeSet.Range range : insertions) { notifyItemRangeInserted(range.startIndex, range.length); } OrderedCollectionChangeSet.Range[] modifications = changeSet.getChangeRanges(); for (OrderedCollectionChangeSet.Range range : modifications) { notifyItemRangeChanged(range.startIndex, range.length); } }}; RealmRecyclerViewAdapter 也可以达到同样的效果. 原文链接 https://realm.io/docs/java/latest/#schemas","link":"/2017/03/15/《Android开源库》 Realm For Android~ Scheme & JSON & Notification（译文）/"},{"title":"《Android开源库》 Realm For Android~ RelationShips and Writes（译文）","text":"关系 任何两个RealmObject都可以链接在一起。 1234567891011public class Email extends RealmObject { private String address; private boolean active; // ... setters and getters left out}public class Contact extends RealmObject { private String name; private Email email; // ... setters and getters left out} 关系在Realm中开销不大。这意味着保持连接并不会影响速度，并且关系的内部实现在使用内存上也是相当高效的。 多对一 在类中简单的定义一个继承自RealmObject的子类作为成员即可： 1234public class Contact extends RealmObject { private Email email; // Other fields…} 每个联系人（Contact的实例）都有0或1个电子邮件（Email实例）。在Realm中，没有什么可以阻止你在多个联系人中使用相同的电子邮件对象，上述模型可以是多对一关系，但通常用于建模一对一关系。 设置RealmObject字段null将清除引用，但对象不会从Realm中删除 多对多 你可以通过RealmList字段声明从单个对象与任意数量的对象建立关系。例如，假设有多个电子邮件地址的联系人 123456789public class Contact extends RealmObject { public String name; public RealmList&lt;Email&gt; emails;}public class Email extends RealmObject { public String address; public boolean active;} RealmLists基本上是RealmObjects的容器，并且RealmList和一个普通的Java List用法基本相同。Realm在不同的RealmLists中可以使用相同的对象两次（或更多），没有限制，因此你可以使用它来建模一对多和多对多关系。 你可以创建对象，并使用RealmList.add()将Email对象添加到Contact对象： 1234567891011121314151617realm.executeTransaction(new Realm.Transaction() { @Override public void execute(Realm realm) { Contact contact = realm.createObject(Contact.class); contact.name = &quot;John Doe&quot;; Email email1 = realm.createObject(Email.class); email1.address = &quot;john@example.com&quot;; email1.active = true; contact.emails.add(email1); Email email2 = realm.createObject(Email.class); email2.address = &quot;jd@example.com&quot;; email2.active = false; contact.emails.add(email2); }}); 可以声明递归关系，当建模某些类型的数据时，这些关系可能很有用 12345public class Person extends RealmObject { public String name; public RealmList&lt;Person&gt; friends; // Other fields…} 将RealmList字段的值设置null将清除列表。也就是说，列表将为空（长度为零），但没有对象会被删除。通过getter方法获取RealmList将永远不会返回null。返回的对象总是一个列表，但长度可能为零。 连接查询 查询连接和关系时可以的。考虑如下模型： 12345678910111213public class Person extends RealmObject { private String id; private String name; private RealmList&lt;Dog&gt; dogs; // getters and setters}public class Dog extends RealmObject { private String id; private String name; private String color; // getters and setters} 每个Person可以和狗建立一对多的关系，正如下表所示： 使用连接查询来找一些人 1234// persons =&gt; [U1,U2]RealmResults&lt;Person&gt; persons = realm.where(Person.class) .equalTo(&quot;dogs.color&quot;, &quot;Brown&quot;) .findAll(); 首先，请注意，条件中的字段名称”equalTo”包含通过关系的路径（以句点分隔.）。 上述查询应读取，查找到拥有名为”布朗”的狗的所有人。重要的是要理解，结果将包含不满足条件的Dog对象，因为它们是Person对象的一部分。 12persons.get(0).getDogs(); // =&gt; [A,B]persons.get(1).getDogs(); // =&gt; [B,C,D] 这可以通过以下两个查询进一步检查。 123456789// r1 =&gt; [U1,U2]RealmResults&lt;Person&gt; r1 = realm.where(Person.class) .equalTo(&quot;dogs.name&quot;, &quot;Fluffy&quot;) .findAll();// r2 =&gt; [U1,U2]RealmResults&lt;Person&gt; r2 = r1.where() .equalTo(&quot;dogs.color&quot;, &quot;Brown&quot;) .findAll(); 注意第一个查询如何返回这两个Person对象，因为条件与两个人都匹配。每个Person查询结果都包含一个Dog对象列表- 它们的所有Dog对象（即使是那些不满足原始查询条件的对象）。记住，我们正在寻找有特定种类的Dog（姓名和颜色）的人，而不是实际的狗本身。因此，第二个查询将针对第一个Person查询result（r1）和每个Persons狗进行评估。第二个查询也匹配两个人，但这次是因为狗的颜色。 让我们深入一点，以帮助巩固这个概念。请查看以下示例： 12345678910111213141516/ r1 =&gt; [U1,U2]RealmResults&lt;Person&gt; r1 = realm.where(Person.class) .equalTo(&quot;dogs.name&quot;, &quot;Fluffy&quot;) .equalTo(&quot;dogs.color&quot;, &quot;Brown&quot;) .findAll();// r2 =&gt; [U2]RealmResults&lt;Person&gt; r2 = realm.where(Person.class) .equalTo(&quot;dogs.name&quot;, &quot;Fluffy&quot;) .findAll() .where() .equalTo(&quot;dogs.color&quot;, &quot;Brown&quot;) .findAll(); .where() .equalTo(&quot;dogs.color&quot;, &quot;Yellow&quot;) .findAll(); 第一个查询应该读取，查找到所有有名为”Fluffy”狗的 Person，也找到那些有名为”Brown”狗的Person，然后给我两个的​​交集。第二个查询先读取并查找到所有名为“Fluffy”的狗的Person。然后，给定结果集，找到所有有颜色为“棕色”的狗的Person，并且给定结果集，找到具有颜色为“黄色”的狗的所有人。 让我们来看看背后的查询，r1以便充分了解发生了什么。两个条件是equalTo(“dogs.name”, “Fluffy”)和equalTo(“dogs.color”, “Brown”)。第一个条件满足U1和U2- 这是C1集合。第二个条件也满足U1和U2- 这是C2集合。查询中的逻辑和，和C1和C2的交集是一样的。C1和C2的交集为U1 and U2。因此，r1是U1 and U2。 后面的查询r2就不同了。让我们开始分解这次查询以探究竟。查询的第一部分如下所示：RealmResults r2a = realm.where(Person.class).equalTo(“dogs.name”, “Fluffy”).findAll();。它匹配U1和U2。然后，r2b = r2a.where().equalTo(“dogs.color”, “Brown”).findAll();还是匹配U1和U2（两个人都有棕色的狗）。最后的查询，r2 = r2b.where().equalTo(“dogs.color”, “Yellow”).findAll();只匹配U2，因为只有一个人在棕色狗结果集中有一个黄色的狗，也就是U2 写 读操作是隐式的，这意味着可以随时访问和查询对象。所有写操作（添加，修改和删除对象）必须包含在写事务中。写事务可以提交或取消。在提交期间，所有更改都将写入磁盘，并且提交只有在所有更改都可以保留时才会成功。通过取消写入事务，所有更改都将被丢弃。使用写事务，你的数据将始终处于一致状态。 写事务也用于确保线程安全 12345678// Obtain a Realm instanceRealm realm = Realm.getDefaultInstance();realm.beginTransaction();//... add or update objects here ...realm.commitTransaction(); 在写事务中使用到你的RealmObjects时，你可能最后想放弃修改。与其提交之后再回退，你可以简单地取消写事务。 123456realm.beginTransaction();User user = realm.createObject(User.class);// ...realm.cancelTransaction(); 请注意，写事务可能会相互阻塞。如果你在UI线程和后台线程上同时创建写入事务，这可能会导致ANR错误。为了避免这种情况，在UI线程上创建写事务时使用异步事务。 Realm是崩溃安全的，所以在一次事务中发生了Exception，Realm本身不会崩溃。只是当前事务中的数据会丢失。如果异常被捕获但应用程序仍在继续，这个时候取消正在执行的事务就显得尤为重要。如果使用executeTransaction()，这些将会自动的执行。 感谢Realm的MVCC架构，在写事务打开的时候读取不会被阻塞！这意味着，除非你需要从多个线程同时进行事务，你可以使用一个更大的事务，这些事务如果使用小事务来做的话将会耗费更多的工作量。当你将写事务提交到Realm时，该Realm的所有其他实例将被通知并自动更新。 Realm中的读写访问是ACID 创建对象 因为RealmObjects都得绑定到一个领域，他们应该通过Realm直接实例化 12345realm.beginTransaction();User user = realm.createObject(User.class); // Create a new objectuser.setName(&quot;John&quot;);user.setEmail(&quot;john@corporation.com&quot;);realm.commitTransaction(); 或者，你可以首先创建一个对象的实例，然后使用realm.copyToRealm（）添加它。Realm支持尽可能多的自定义构造函数，只要其中一个是公共的无参数构造函数。 1234567User user = new User(&quot;John&quot;);user.setEmail(&quot;john@corporation.com&quot;);// Copy the object to Realm. Any further changes must happen on realmUserrealm.beginTransaction();User realmUser = realm.copyToRealm(user);realm.commitTransaction(); 当使用时，realm.copyToRealm()重要的是要记住只有返回的对象由Realm管理，所以对原始对象的任何进一步的更改都不会被持久化 事务块 不用手动保持跟踪realm.beginTransaction()，realm.commitTransaction()以及realm.cancelTransaction()可以使用realm.executeTransaction（）方法，它会自动处理开始/提交，发生错误的时候将自动取消 12345678realm.executeTransaction(new Realm.Transaction() { @Override public void execute(Realm realm) { User user = realm.createObject(User.class); user.setName(&quot;John&quot;); user.setEmail(&quot;john@corporation.com&quot;); }}); 异步事务 因为事务被其他事务阻塞，所以在后台线程上执行所有写操作以避免阻塞UI线程是一个很好的主意。通过使用异步事务，Realm将在后台线程上运行该事务并在事务完成时报告。 123456789101112131415161718realm.executeTransactionAsync(new Realm.Transaction() { @Override public void execute(Realm bgRealm) { User user = bgRealm.createObject(User.class); user.setName(&quot;John&quot;); user.setEmail(&quot;john@corporation.com&quot;); } }, new Realm.Transaction.OnSuccess() { @Override public void onSuccess() { // Transaction was a success. } }, new Realm.Transaction.OnError() { @Override public void onError(Throwable error) { // Transaction failed and was automatically canceled. } }); OnSuccess和OnError回调都是可选的，但是如果提供，它们将在事务成功完成或失败时分别被调用。回调由Looper控制，因此它们只允许在Looper线程上回调。 12345678ealmAsyncTask transaction = realm.executeTransactionAsync(new Realm.Transaction() { @Override public void execute(Realm bgRealm) { User user = bgRealm.createObject(User.class); user.setName(&quot;John&quot;); user.setEmail(&quot;john@corporation.com&quot;); } }, null); 异步事务由RealmAsyncTask对象表示。如果在事务完成之前退出Activity / Fragment，此对象可用于取消任何挂起的事务。如果回调更新UI，忘记取消事务可能会导致应用程序崩溃。 12345ublic void onStop () { if (transaction != null &amp;&amp; !transaction.isCancelled()) { transaction.cancel(); }} 更新字符串和字节数 Realm是以完整的字段作为操作对象的，不可能更新字符串或字节数组的单个元素。假如你需要更新字符串的第5个元素，你将需要做类似的事情： 12345678realm.executeTransaction(new Realm.Transaction() { @Override public void execute(Realm realm) { bytes[] bytes = realmObject.binary; bytes[4] = &apos;a&apos;; realmObject.binary = bytes; }}); 是由于Realm的MVCC架构，它避免了对现有数据的改变，以确保读取数据的其他线程或进程下表现一致。 快照 所有Realm集合都是实时的。这意味着它们总是反映最新的状态。在大多数情况下，这是可取的，但如果你循环一个集合，目的是修改元素呢？例如： 123456RealmResults&lt;Person&gt; guests = realm.where(Person.class).equalTo(&quot;invited&quot;, false).findAll();realm.beginTransaction();for (int i = 0; guests.size(); i++) { guests.get(i).setInvited(true);}realm.commitTransaction(); 通常你会期望这个简单的循环邀请所有客人。因为RealmResults是立即更新，虽然，只有一半的客人最终被邀请！受邀的邀请对象将从该集合中立即删除，这会移动所有元素。当i参数增加时，它将错过一个元素。 为了防止这种情况，你可以拍摄集合数据的快照。快照保证元素的顺序不会改变，即使元素被删除或修改。 Iterator从Realm集合创建的文件将自动使用快照。RealmResults和RealmList可以使用createSnapshot()手动创建快照。 12345678910111213141516RealmResults&lt;Person&gt; guests = realm.where(Person.class).equalTo(&quot;invited&quot;, false).findAll();// Use an iterator to invite all guestsrealm.beginTransaction();for (Person guest : guests) { guest.setInvited(true);}realm.commitTransaction();// Use a snapshot to invite all guestsrealm.beginTransaction();OrderedRealmCollectionSnapshot&lt;Person&gt; guestsSnapshot = guests.createSnapshot();for (int i = 0; guestsSnapshot.size(); i++) { guestsSnapshot.get(i).setInvited(true);}realm.commitTransaction(); 原文链接 https://realm.io/docs/java/latest/#relationships","link":"/2017/03/05/《Android开源库》 Realm For Android~ RelationShips and Writes（译文）/"},{"title":"《Android开源库》Realm For Android~ Getting Help and Models（译文）","text":"获得帮助你编程时需要帮助？：在 StackOverflow 上提问。我们在实时监控并且回答 SO 上的相关问题！要报告一个 bug？：在我们的 GitHub 仓库里新建一个问题，并且尽可能地按问题模板将 bug 描述清楚。需要一个新功能？：在我们的 GitHub 仓库里新建一个问题，并且尽可能地按问题模板将该功能描述清楚。想知道接下来将会发生什么？：看看我们的 changelog。这里有我们即将发布的改动以及修改历史。 模型Realm 数据模型定义需要继承自 RealmObject 类。 1234567891011121314151617public class User extends RealmObject { private String name; private int age; @Ignore private int sessionId; // Standard getters &amp; setters generated by your IDE… public String getName() { return name; } public void setName(String name) { this.name = name; } public int getAge() { return age; } public void setAge(int age) { this.age = age; } public int getSessionId() { return sessionId; } public void setSessionId(int sessionId) { this.sessionId = sessionId; }} Realm 数据模型不仅仅支持 private 成员变量，你还可以使用 public、protected 以及自定义的成员方法。 12345678910111213public class User extends RealmObject { public String name; public boolean hasLongName() { return name.length() &gt; 7; } @Override public boolean equals(Object o) { // Custom equals comparison }} 字段类型Realm 支持以下字段类型：boolean、byte、short、int、long、float、double、String、Date和byte []。整数类型 short、int 和 long 都被映射到 Realm 内的相同类型（实际上为 long ）。再者，还可以使用 RealmObject 的子类和 RealmList&lt;? extends RealmObject&gt; 来表示模型关系。 Realm 对象中还可以声明包装类型（boxed type）属性，包括：Boolean、Byte、Short、Integer、Long、Float和Double。通过使用包装类型，可以使这些属性存取空值（null)。 @Required修饰类型和空值（null）某些时候，空值（null）对于属性并不合适。这时可以使用注解 @Required 告诉 Realm 强制禁止空值（null）被存储。只有 Boolean、 Byte、 Short、 Integer、 Long、 Float、 Double、 String、 byte[] 以及 Date 可以被 @Required 修饰。在其它类型属性上使用 @Required 修饰会导致编译失败。基本数据类型（primitive types）不需要使用注解 @Required，因为他们本身就不可为空。RealmObject 属性永远可以为空。 忽略的属性注解 @Ignore 意味着一个字段不应该被保存到 Realm。某些时候输入的信息包含比模型更多的字段，而你不希望处理这些未使用的数据字段，你可以用 @Ignore 来标识这些你希望被 Realm 忽略的字段 Auto-Updating ObjectsRealmObject 是实时的、自动更新的底层数据的映射视图。你不需要去重新获得对象已取得其最新版本。对于数据的改动会即时反应到相关的对象或者查询结果。 1234567891011121314151617181920final Dog myDog;realm.executeTransaction(new Realm.Transaction() { @Override public void execute(Realm realm) { myDog = realm.createObject(Dog.class); myDog.setName(\"Fido\"); myDog.setAge(1); }});realm.executeTransaction(new Realm.Transaction() { @Override public void execute(Realm realm) { Dog myPuppy = realm.where(Dog.class).equalTo(\"age\", 1).findFirst(); myPuppy.setAge(2); }});myDog.getAge(); // =&gt; 2 RealmObject 和 RealmResults 的设计不仅仅是为了更快和更有效率，它们同时也让代码更加简洁以及反应性更强。举例来说，假设你的 Activity 或者 Fragment 依赖于某个 RealmObject 或者 RealmResults，你无需担心何时去刷新或者重新获取它们以更新 UI——它们会自动更新。 你可以通过订阅 Realm notifications 来得知 Realm 的数据在何时被更新从而刷新你的 UI。 索引（Index）属性注解 @Index 会为字段增加搜索索引。这会导致插入速度变慢，同时数据文件体积有所增加，但能加速查询。因此建议仅在需要加速查询时才添加索引。目前仅支持索引的属性类型包括：String、byte、short、int、long、boolean和Date。 主键 (primary keys)@PrimaryKey 可以用来定义字段为主键，该字段类型必须为字符串（String）或整数（short、int 或 long）以及它们的包装类型（Short、Int 或 Long）。不可以存在多个主键。使用支持索引的属性类型作为主键同时意味着为该字段建立索引。 当创建 Realm 对象时，所有字段会被设置为默认值。为了避免与具有相同主键的另一个对象冲突，建议创建一个 unmanaged 对象，为字段的赋值，然后用 copyToRealm() 方法将该对象复制到 Realm。 主键的存在意味着可以使用 copyToRealmOrUpdate() 方法，它会用此主键尝试寻找一个已存在的对象，如果对象存在，就更新该对象；反之，它会创建一个新的对象。当 copyToRealmOrUpdate() 的调用对象没有主键时，会抛出异常。 使用主键会对性能产生影响。创建和更新对象将会慢一点，而查询则会变快。很难量化这些性能的差异，因为性能的改变跟你数据库的大小息息相关。 Realm.createObject()会返回一个所有字段被设置为默认值的新对象。如果该模型类存在主键，那么有可能返回对象的主键的默认值与其它已存在的对象冲突。建议创建一个非托管（unmanaged）Realm 对象，并给其主键赋值，然后调用 copyToRealm() 来避免冲突。 123456789101112131415final MyObject obj = new MyObject();obj.setId(42);obj.setName(\"Fish\");realm.executeTransaction(new Realm.Transaction() { @Override public void execute(Realm realm) { // This will create a new object in Realm or throw an exception if the // object already exists (same primary key) // realm.copyToRealm(obj); // This will update an existing object with the same primary key // or create a new object if an object with no primary key = 42 realm.copyToRealmOrUpdate(obj); }}); 字符串（String）和包装类型（Short、Int 或 Long）的主键可以被赋予空值（null）；除非它们同时被 @Required 修饰。 定制对象（Customizing Objects）你几乎可以把 RealmObject 当作 POJO 使用。只需扩展 RealmObject，将相应属性声明为 public。不需要 setter 和 getter， 而是直接访问属性。 1234public class Dog extends RealmObject { public String name; public int age;} 你可以像使用其他类一样直接使用 Dog 类。createObject() 和 copyToRealm() 可以帮助你创建一个托管给 Realm 的 Dog 对象。 12345678realm.executeTransaction(new Realm.Transaction() { @Overrride public void execute(Realm realm) { Dog dog = realm.createObject(Dog.class); dog.name = \"Fido\"; dog.age = 5; }}; 如果需要的话，你可以在 setter 和 getter 中添加你自己的逻辑。例如你可能需要在保存之前验证值的合法性。另外，你还可以为你的 RealmObject 添加自定义方法。 限制目前不支持 final、transient 和 volatile 修饰的成员变量，这主要是为了 Realm 对象在非托管（unmanaged RealmObject）时候的行为差异化。 Realm 数据模型不可以继承自除了 RealmObject 以外的其它对象。你可以选择不声明默认无参数构造器，但是如果你声明了，那么该构造器必须为空构造器。这是目前 Realm 的一个限制。但你可以自由添加任意其它的构造器。 RealmModel 接口除直接继承于 RealmObject 来声明 Realm 数据模型之外，还可以通过实现 RealmModel 接口并添加 @RealmClass 修饰符来声明。 12345@RealmClasspublic class User implements RealmModel {} RealmObject 的所有方法都有其相对应的静态方法。 12345678// With RealmObjectuser.isValid();user.addChangeListener(listener);// With RealmModelRealmObject.isValid(user);RealmObject.addChangeListener(user, listener); 原文链接https://realm.io/docs/java/latest/#getting-helphttps://realm.io/docs/java/latest/#models","link":"/2017/03/04/《Android开源库》Realm For Android~ Getting Help and Models（译文）/"},{"title":"《Kotlin》 Android Studio3.0 新特性 ～ New Features in Android Studio Preview (译文)","text":"原文地址：https://developer.android.google.cn/studio/preview/features/index.html 最新Android Studio版本是Android Studio 3.0，本文提供了所有新功能和更改的摘要。 所有这些功能都可以在最新的金丝雀版本中发布，但beta测试版本可能尚未提供。 核心IDE更改 我们将基础IDE从IntelliJ 2016.2升级到2017.1.2，在2016.3和2017.1中增加了许多新功能，包括参数提示，语义突出显示，搜索中的即时结果等等。 许多新的Lint 检查。 即时运行调试问题234401已经解决。 如果程序在断点上暂停，应用程序将会重新启动。 但是如果应用程序没有在断点上暂停，那么当只进行方法实现更改时，程序不会重新启动并且热插拔会正常工作。 Kotlin语言支持Android Studio3.0支持Kotlin语言。你可以通过将Java代码转换成Kotlin(点击”Code” &gt; “Convert Java File to Kotlin File”)的方式或者直接使用新建项目向导创建启动Kotlin的项目来在你的工程中使用Kotlin。了解更多关于Kotlin in Android JAVA8特性支持Android Studio 3.0引入了对Java 8库和某些Java 8语言功能的内置支持。 我们不再需要Jack，你应该禁用Jack来使用内置改进后Java 8支持的默认工具链。 要了解更多信息，请阅读使用Java 8语言功能。 全新的Android ProfileAndroid Studio 3.0中的新的Android Profiler提供了一个实时统一的应用程序活动视图。 Android Profiler窗口将替换Android监视器窗口。 要打开Android Profiler，请按照下列步骤操作： 单击”View&gt;Tool Windows&gt; Android Profiler“（你也可以在工具栏中单击”Android Profiler“）。 从Android Profiler工具栏中选择要配置的设备和应用程序进程。 如果你已通过USB连接设备但未看到它，请确保已启用USB调试。 单击”NETWORK“，”CPU“或”MEMORY“时间线以打开每个分析器的更详细视图。 有关每个新的剖析器的更多信息，请参阅以下页面： 网络分析器 CPU分析器 内存分析器 作为此更新的一部分，logcat已移至单独的窗口。 Instant Apps支持Android Studio3.0提供两种新的Module类型：Instant App Module和Feature Module给开发者用来在我们的项目中创建Instant AppsAndroid Studio 3.0还包括一个新的重构模块化操作和App Links Assistant，以帮助您实施即时应用。 有关Instant Apps的详细信息，请参阅Android Instant Apps。 APK调试器Android Studio 3.0中的新版APK调试器可让你配置和调试APK，而无需将其从Android Studio项目中构建，只要它们是可调试的。 有关使用APK调试器的更多信息，请阅读Profile and Debug Pre-built APKs 新的设备文件管理器新的设备文件资源管理器工具窗口允许您与连接的设备的文件系统无缝交互。 你可以点击查看Android Studio中的各种文件，并将文件复制到您的计算机。此功能取代了以前通过DDMS完成的设备文件系统交互。 支持Android O Developer PreviewAndroid Studio 3.0增加了如下对 Android O的支持： 一个新的自适应图标向导，允许你创建新的自适应启动器图标资源，并预览它们将如何显示在不同的设备上。 要启动自适应图标向导，请右键单击项目中的/ res文件夹，然后单击“New &gt; Image Asset &gt; Launcher Icons (Adaptive and Legacy)“。 有关Android O中的自适应启动器图标的更多信息，请参阅自适应图标。 新的XML字体预览，字体选择工具以及对可下载字体的支持。 有关Android O中的XML字体和可下载字体的详细信息，请参阅使用字体。 为Android Things提供的新模版Android Studio 3.0在新项目和新模块向导中包含一组新的模板，因此你可以开始使用Android Things开发物联网设备。 有关更多信息，请参阅Android Things。 布局编辑器改进Android Studio 3.0中的布局编辑器包含许多新的功能增强，其中包括： 更新的组件树，具有改进的拖放视图插入 新错误面板 查看障碍和组的新支持 增强链创造 布局检查器的改进Android Studio 3.0中的布局检查器增加新的改进功能，可以让你更轻松地调试应用程序布局的问题，包括将属性分类为常见类别，并在“查看树”和“属性”面板中将新的搜索功能分组。 要打开布局检查器，请单击“Tools&gt; Android&gt;Layout Inspector”。 Google’s Maven库Android支持库Maven依赖关系现在可以在新的Maven存储库中的Android SDK Manager外部使用。 结合命令行sdkmanager工具和Gradle，这种新的分发方法简化了使用持续集成系统的Maven依赖关系管理。 要使用新的Maven存储库，请将URL添加到build.gradle文件的repository库中，如下所示： 12345repositories { maven { url \"https://maven.google.com\" }} 想了解更多，请移步Google Maven and offline repositories APK Analyzer 改进Android Studio3.0针对APK Analyzer包含如下改进： 显示以前可用的除了包，类和方法之外的字段 顶部显示和隐藏字段和方法的新过滤选项 在树视图中，以斜体显示的节点是未在DEX文件中定义的引用 对于启用Proguard构建的APK，您可以加载向DEX查看器添加功能的Proguard映射文件，其中包括： 粗体节点指示在缩小代码时不应删除节点 启用一个按钮，使得在收缩（shrinking）过程中被删除的节点可见 启用一个按钮，恢复树视图中由Proguard混淆后的节点的原始名称 新版Android Gradle 插件Android plugin 3.0.0-alpha1 and higher旨在解决拥有大量模块项目的Android工程的构建性能的问题。当你在项目中使用新的插件的时候，你将感受到如下改进： 推迟依赖以达到更快的配置 变量感知（Variant-aware）依赖仅适用于你正在构建的项目和变量 对代码或资源进行简单的更改后，增量构建时间将会比之前的版本快为了实现这些改进，我们在插件行为，DSL和API上有一些突破性的变化。这会影响构建文件和Gradle插件。有关如何迁移自己的项目以使用此插件的说明，请看迁移到新的插件 新的Android 模拟器特性新的Android模拟器包含大量的新特性，具体如下： 新的API Level 24系统映像和Android O Beta系统映像，包括Google Play商店，以促进你的应用程序的端到端测试，并帮助你保持Google Play服务与AVDs的同步。 支持Windows和Linux机器上的OpenGL ES 3.0系统图像API级别24及更高版本，并在较老的模拟器系统映像上对OpenGL ES 2.0图形性能进行显着改进。 注意：我们目前正在尽力自动启用来自英特尔，NVIDIA和AMD的所有现代GPU的OpenGL ES 3.0,如果运行OpenGL ES 3.x应用程序时遇到问题，系统可能尚未自动启用.你可以通过将以下行添加到〜/ .android / advancedFeatures.ini文件中来手动启用OpenGL ES 3.0GLESDynamicVersion = true 一种新的更简单的方法来从Android模拟器生成应用的错误报告。 一个新的链接，可以在Android问题跟踪器（单击“Emulator Tool Bar &gt; Extended Controls &gt; Help &gt; Emulator Help &gt; File a Bug”）上为Android团队快速提交与模拟器相关的错误。 用于配置Android模拟器使用的代理设置的新UI。要配置Android模拟器的代理设置，请单击 “Extended Controls &gt; Settings &gt; Proxy”. 在模拟器上支持Android Wear设备的rotary input的新支持有关Android模拟器更新的更多信息，请参阅Android模拟器发行说明。","link":"/2017/05/21/《Kotlin》 Android Studio3.0 新特性 ～ New Features in Android Studio Preview (译文)/"},{"title":"《微信小程序》 开源项目","text":"简介移动开发者想学习微信小程序需要学习一点HTML ,CSS和JS才能够比较快速的上手，参考自己学习Android学习过程，阅读源码是一个很好的方式，所以才收集了一些WeApp的开源项目。awesome-github-wechat-weapp 是由OpenDigg整理并维护的微信小程序开源项目库集合。我们会定期同步OpenDigg上的项目到这里，也欢迎各位提交项目给我们。 内容 UI组件 开发框架 实用库 开发工具 服务端 其他 Demo ###UI组件 weui-wxss ★804 - 微信原生视觉体验一致的基础样式库 Wa-UI ★116 - 针对信小程序整合的一套UI库 wx-charts ★87 - 微信小程序图表工具 wemark ★78 - 微信小序Markdown渲染库 WeZRender ★25 -微信小程序Canvas增强组件 wxapp-charts ★20 - 微信小程序图表charts组件 wetoast ★18 - 仿微信小程序提供的showToast功能 WeiXinProject ★17 - 列表的上拉刷新和上拉加载 citySelect ★13 - 微信小程序城市选择器 ###开发框架 Labrador ★348 -微信小程序模块化开发框架 wepy ★317 - 小程序组件开发框架 wxapp-devFrame ★27 - 小程序基本的开发框架 ###实用库 wxParse ★376 - 微小程序富文本解析自定义组件 wechat-weapp-redux ★85 - 微信小程序Redux绑定 wilddog-weapp ★43 - 野狗微信小程序客户SDK wafer-client-sdk ★35 - 微信小程序客户端腾讯云增强 SDK WxNotificationCenter ★28 - 微信小程序通知广播模式类 ###开发工具 weapp-ide-crack ★4446 - 微信小程序IDE及破解攻略 wept ★779 - 实时微信程序开发工具 weapp-quick ★289 - “微信Web开发者”拷贝工具 Wxapp.vim ★101- 微信小程序开发 Vim 插件 Matchmaker ★79- 专为微信小程序开发的插件 wechat_web_devtools ★58 - 微信开发者工具Linux版 ###服务端 NAMI ★28 - 专为小序而生的服务端开发容器 weapp-php-server-sdk ★22 - 腾讯云微信小程序云端解决案 Wafer 服务端 SDK - Java ★22 - 企业级微信小程序全栈方案 m-mall-admin ★21 - 创建REST API的样板应用 weapp-node-server-demo ★17 - Wafer 服务端 Demo ##其他 wxapp-redux-starter ★49 - 提供方便快捷的微信小程序开发环境 ###Demo weapp-demo ★689 -仿豆瓣电影微信小程序 wechat-weapp-gank ★532 - Gank微信小程序 SmallAppForQQ ★447 - 微信小程序高仿QQ应用 wechat-weapp-mall ★412 - 微信小程序移动端商城 weapp-wechat-zhihu ★280 - 微信中的知乎 wecqupt ★234 - 在微信内被便捷地获取和传播 wechat-v2ex ★164 - 简单的v2ex微信小程序 weChatApp-Run ★146 - 跑步微信小程序Demo wechat-weapp-taobao ★140 - 微信小程序demo 仿手机宝 weapp-weipiao ★133 - 微信小程序-微票 wechat-app-zhihudaily ★132 - 微信小程序-知乎日报 fenda-mock ★123 - 使用微信小程序实现分答这款APP的基础功能 weapp-boilerplate ★105 - 一个为微信小程序开发准备的基础骨架 腾讯云微信小程序 ★103 - 一站式解决方案客户端示例 wechat-app-music ★85 - 微信小程序： 音乐播放器 wechat-weapp-mapdemo ★72 - 微信小程序开发demo-地图定位 weapp-demo-session ★58 - 微信小程序示例一笔到底 m-mall ★57 - 实现一移动端小商城 weapp-douban-film ★56 - 微信小程序 - 豆瓣电影 wechat-weapp-redux-todos ★55 - 微信小程序集成Redux实的Todo list wxapp-socket-io ★55 - 微信小程序的SocketIO客户端 wechat-weapp-movie ★54 - 微信小程序 - 电影推荐 Artand ★53 - 微信小程序 wepy-wechat-demo ★51 - wepy仿微信聊天界面 wechat_mall_applet ★50 - 巴爷微信商城的简单版本 wechat-chat ★44 - 微信小程序版聊天室 [BearDiary ★41](https://github.com/harveyqing/BearDiary - 微信小程序之小熊の日记 wechat-weapp-demo ★41 - 一个简单的微信小程序购车DEMO [wxapp-sCalc ★40](https://github.com/dunizb/wxapp-sCalc - 微信小程序版简易计算器，适合入门练手 weapp-one ★39 -仿 「ONE · 一个」 的微信小程序 wxflex ★37 - 微信小序的Flex布局demo wxapp-hiapp ★33 - HiApp 微信小程序版 weapp-github ★33 - 微信小程序的简单尝试 weapp-newsapp ★33 - 微信小程序-公众号热门文章信息流 weapp-girls ★31 - 通过Node.js实现的妹子照片爬虫微信小程序 仿芒果TV ★31 - 微信小程序demo 番茄时钟 ★31 - 番茄时微信小程序版 weapp-V2ex ★30- V2ex 微信小程序版 wechat-app-flexlayout ★28 - 从FlexLayout布局开始学习微信小程序 wechatapp-news-reader ★25 - 新闻阅读器 wechat-app-xiaoyima ★24 - 仿大姨妈的微信小程序 yiyaowang-wx ★21 - 医药网原生APP的微信小程序DEMO weapp ★19 - 小程序hello world 尝鲜 weapp-demo-breadtrip ★19 - 基于面包旅行 API 制作的微信小程序示例 WeChatMeiZhi ★17 - 微信小程序版妹纸图 weapp-node-server-demo ★17 - Wafer 服务端 Demo wxreading ★17 -微信小程序跟读 WXBaiSi ★16 -微信小程序仿百思不得姐 weapp-500px ★16 - 微信小程序 hotapp-notepad ★15 - 微信小程序HotApp云笔记 wxapp-2048 ★15 -微信小程序2048 netmusic-app ★14 - 仿网易云音乐APP的微信小程序 WxMasonry ★13 -微信小程序瀑布流布局模式 GankCamp-WechatAPP ★13 - 微信小程序版干货集中营 PigRaising ★13- 专注管理时间的微信小程序 WexinApp_1024 ★12 - 简单的实现了1024的游戏规则 weapp-douban-movie ★12 - 微信小程序版豆瓣电影 weapp-lolgame ★11 - 英雄联盟(LOL)战绩查询 jspapa-wx ★10 -jspapa微信小程序版本 wxSortPickerView ★8 - 微信小程序首字母排序选择表 liwushuoapp ★8 - 微信小程序开发的App wx-mina-meteor ★8 - 一个 meteor 的 React todo list 例子 wechat-app-githubfeed ★7 - 微信小程序试玩 caipu_weixin ★7 - 微信小程序健康菜谱 weapp-LeanCloud ★7 - LeanCloud 的微信小程序用户登陆Demo wx-mime ★5 - 微信程序版的扫雷 备注原文链接：https://github.com/opendigg/awesome-github-wechat-weapp","link":"/2017/01/11/《微信小程序》 开源项目/"},{"title":"《Android开源库》 Retrofit & WebService","text":"版权声明：本文为博主原创文章，未经博主允许不得转载。 https://blog.csdn.net/poorkick/article/details/79183920 1. 前言 最近工作中需要使用到WebService接口，个人比较喜欢Restful的接口风格，对WebService不是很了解。 Web Service也叫XML Web Service WebService是一种可以接收从Internet或者Intranet上的其它系统中传递过来的请求，轻量级的独立的通讯技术。是:通过SOAP在Web上提供的软件服务，使用WSDL文件进行说明，并通过UDDI进行注册。 而对于我们移动开发人员而言，它就是一种数据交互的通道。我们需要了解他的请求结构体和响应结构体。 2. WebService调试工具SoapUI SoapUI是一个开源测试工具，通过soap/http来检查、调用、实现Web Service的功能/负载/符合性测试。该工具既可作为一个单独的测试软件使用，也可利用插件集成到Eclipse，maven2.X，Netbeans 和intellij中使用。SoapUI Pro是SoapUI的商业非开源版本，实现的功能较开源的SoapUI更多。 (找不到资源的可以在文章下方留言) 3. 接口分析（以getMobileCodeInfo为例） 以 http://ws.webxml.com.cn/WebServices/MobileCodeWS.asmx?wsdl 为测试例子 从上面两个图可以看到我们得请求体和响应体的结构和内容，以XML格式作为数据交互的结构类型。 4. 程序设计4.1 添加依赖123456789implementation &apos;com.squareup.okhttp3:okhttp:3.8.0&apos;implementation &apos;com.parkingwang:okhttp3-loginterceptor:0.5&apos;implementation &apos;com.squareup.retrofit2:retrofit:2.3.0&apos;implementation &apos;com.squareup.retrofit2:adapter-rxjava2:2.3.0&apos;implementation(&apos;com.squareup.retrofit2:converter-simplexml:2.3.0&apos;) { exclude module: &apos;stax&apos; exclude module: &apos;stax-api&apos; exclude module: &apos;xpp3&apos;} 4.2 请求体设计 从请求体XML结构而言 1234567891011&lt;soap:Envelope xmlns:soap=&quot;http://www.w3.org/2003/05/soap-envelope&quot; xmlns:web=&quot;http://WebXml.com.cn/&quot;&gt; &lt;soap:Header/&gt; &lt;soap:Body&gt; &lt;web:getMobileCodeInfo&gt; &lt;!--Optional:--&gt; &lt;!--Optional:--&gt; &lt;web:mobileCode&gt;18507152743&lt;/web:mobileCode&gt; &lt;/web:getMobileCodeInfo&gt; &lt;/soap:Body&gt;&lt;/soap:Envelope&gt; 最外层soap:Envelope 其次soap:Body 最后web:getMobileCodeInfo，而web:getMobileCodeInfo中有一个mobileCode我们可以用变量表示，所以创建如下三个类： MobileCodeRequestEnvelope.java 12345678910111213141516171819@Root(name = &quot;soap:Envelope&quot;)@NamespaceList({ @Namespace(prefix = &quot;xsi&quot;, reference = &quot;http://www.w3.org/2001/XMLSchema-instance&quot;), @Namespace(prefix = &quot;xsd&quot;, reference = &quot;http://www.w3.org/2001/XMLSchema&quot;), @Namespace(prefix = &quot;soap&quot;, reference = &quot;http://www.w3.org/2003/05/soap-envelope&quot;)})public class MobileCodeRequestEnvelope { @Element(name = &quot;soap:Body&quot;, required = false) private MobileCodeRequestBody body; public MobileCodeRequestBody getBody() { return body; } public void setBody(MobileCodeRequestBody body) { this.body = body; }} MobileCodeRequestBody.java 1234567891011121314@Root(name = &quot;soap:Body&quot;, strict = false)public class MobileCodeRequestBody { @Element(name = &quot;getMobileCodeInfo&quot;, required = false) private MobileCodeRequestData mMobileCodeRequestData; public MobileCodeRequestData getMobileCodeRequestData() { return mMobileCodeRequestData; } public void setMobileCodeRequestData( MobileCodeRequestData mobileCodeRequestData) { mMobileCodeRequestData = mobileCodeRequestData; }} MobileCodeRequestData.java 1234567891011121314@Root(name = &quot;getMobileCodeInfo&quot;, strict = false)@Namespace(reference = &quot;http://WebXml.com.cn/&quot;)public class MobileCodeRequestData { @Element(name = &quot;mobileCode&quot;, required = false) private String mobileCode; public String getMobileCode() { return mobileCode; } public void setMobileCode(String mobileCode) { this.mobileCode = mobileCode; }} 4.3 响应体设计 从响应体XML而言 1234567&lt;soap:Envelope xmlns:soap=&quot;http://www.w3.org/2003/05/soap-envelope&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:xsd=&quot;http://www.w3.org/2001/XMLSchema&quot;&gt; &lt;soap:Body&gt; &lt;getMobileCodeInfoResponse xmlns=&quot;http://WebXml.com.cn/&quot;&gt; &lt;getMobileCodeInfoResult&gt;18507152743：湖北 武汉 湖北联通GSM卡&lt;/getMobileCodeInfoResult&gt; &lt;/getMobileCodeInfoResponse&gt; &lt;/soap:Body&gt;&lt;/soap:Envelope&gt; 最外层soap:Envelope 其次soap:Body 然后getMobileCodeInfoResponse，最后getMobileCodeInfoResult，我们可以用变量表示，所以创建如下三个类： MobileCodeResponseEnvelope.java 12345678910111213141516171819@Root(name = &quot;soap:Envelope&quot;)@NamespaceList({ @Namespace( prefix = &quot;xsi&quot;, reference = &quot;http://www.w3.org/2001/XMLSchema-instance&quot;), @Namespace( prefix = &quot;xsd&quot;, reference = &quot;http://www.w3.org/2001/XMLSchema&quot;), @Namespace( prefix = &quot;soap&quot;, reference = &quot;http://www.w3.org/2003/05/soap-envelope&quot;)})public class MobileCodeResponseEnvelope { @Element(name = &quot;Body&quot;, required = false) private MobileCodeResponseBody mMobildCodeResponseBody; public MobileCodeResponseBody getMobildCodeResponseBody() { return mMobildCodeResponseBody; } public void setMobildCodeResponseBody( MobileCodeResponseBody mobildCodeResponseBody) { mMobildCodeResponseBody = mobildCodeResponseBody; }} MobileCodeResponseBody.java 1234567891011121314@Root(name = &quot;Body&quot;)public class MobileCodeResponseBody { public MobileCodeResponseInfo getMobileCodeResponseInfo() { return mMobileCodeResponseInfo; } public void setMobileCodeResponseInfo( MobileCodeResponseInfo mobileCodeResponseInfo) { mMobileCodeResponseInfo = mobileCodeResponseInfo; } @Element(name = &quot;getMobileCodeInfoResponse&quot;, required = false) private MobileCodeResponseInfo mMobileCodeResponseInfo;} MobileCodeResponseInfo.java 1234567891011121314@Root(name = &quot;getMobileCodeInfoResponse&quot;,strict = false)public class MobileCodeResponseInfo { public String getMobileCodeResult() { return MobileCodeResult; } public void setMobileCodeResult(String mobileCodeResult) { MobileCodeResult = mobileCodeResult; } @Element(name = &quot;getMobileCodeInfoResult&quot;, required = false) private String MobileCodeResult;} 4.4 接口设计123456789public interface mobileCodeApi { @Headers({ &quot;Content-Type: text/xml&quot;, &quot;Accept-Charset: utf-8&quot; }) @POST(&quot;MobileCodeWS.asmx&quot;) Call&lt;MobileCodeResponseEnvelope&gt; getMobileCodeInfo( @Body MobileCodeRequestEnvelope requestEnvelope);} 4.5 Retrofit创建1234567891011121314151617181920212223242526272829303132333435public class Retrofitance { private static Strategy strategy = new AnnotationStrategy(); private static Serializer serializer = new Persister(strategy); private static OkHttpClient.Builder okHttpClient = new OkHttpClient.Builder(); private static Retrofit.Builder retrofitBuilder = new Retrofit.Builder() .addConverterFactory(SimpleXmlConverterFactory.create(serializer)) .baseUrl(Constant.BASE_URL); public static &lt;T&gt; T createMobileCodeService(Class&lt;T&gt; serviceClass) { okHttpClient.interceptors().add(new Interceptor() { @Override public okhttp3.Response intercept(Interceptor.Chain chain) throws IOException { Request original = chain.request(); Request.Builder requestBuilder = original.newBuilder() .header(&quot;Content-Type&quot;, &quot;text/xml;charset=UTF-8&quot;) .method(original.method(), original.body()); Request request = requestBuilder.build(); return chain.proceed(request); } }); OkHttpClient client = okHttpClient.connectTimeout(1, TimeUnit.MINUTES) .addInterceptor(new LogInterceptor()) .writeTimeout(1, TimeUnit.MINUTES) .readTimeout(1, TimeUnit.MINUTES) .build(); Retrofit retrofit = retrofitBuilder.client(client).build(); return retrofit.create(serviceClass); }} 4.6 请求数据12345678910111213141516171819202122232425262728293031mobileCodeApi apiService = Retrofitance.createMobileCodeService(mobileCodeApi.class);MobileCodeRequestEnvelope requestEnvelope = new MobileCodeRequestEnvelope();MobileCodeRequestBody requestBody = new MobileCodeRequestBody();MobileCodeRequestData requestData = new MobileCodeRequestData();requestData.setMobileCode(&quot;18507152743&quot;);requestBody.setMobileCodeRequestData(requestData);requestEnvelope.setBody(requestBody);Call&lt;MobileCodeResponseEnvelope&gt; call = apiService.getMobileCodeInfo(requestEnvelope);call.enqueue(new Callback&lt;MobileCodeResponseEnvelope&gt;() { @Override public void onResponse(Call&lt;MobileCodeResponseEnvelope&gt; call, Response&lt;MobileCodeResponseEnvelope&gt; response) { MobileCodeResponseEnvelope mobileCodeResponseEnvelope = response.body(); if (mobileCodeResponseEnvelope != null) { Toast.makeText(MainActivity.this, &quot;请求成功&quot;, Toast.LENGTH_SHORT).show(); String result = mobileCodeResponseEnvelope.getMobildCodeResponseBody() .getMobileCodeResponseInfo().getMobileCodeResult(); mTvMobileResult.setText(result); System.err.println(&quot;yidong -- result = &quot; + result); } } @Override public void onFailure(Call&lt;MobileCodeResponseEnvelope&gt; call, Throwable t) { System.err.println(&quot;yidong -- onFailure&quot;); Toast.makeText(MainActivity.this, &quot;请求失败&quot;, Toast.LENGTH_SHORT).show(); }}); 4.7 效果 5. 源码地址 RetrofitWebService","link":"/2018/01/27/《Android开源库》 Retrofit & WebService/"},{"title":"《Android Framework 之路》Android5.1 Camera Framework（一）","text":"Android5.0 Camera Framework 简介CameraService启动CameraService是在MediaServer启动过程中进行的main_mediaserver.cpp (frameworks\\av\\media\\mediaserver) 123456......AudioFlinger::instantiate(); //audioflinger服务，音频相关MediaPlayerService::instantiate(); //mediaplayerservice,媒体播放相关CameraService::instantiate();//CameraServiceAudioPolicyService::instantiate(); //音频相关...... 在 main函数中会执行到CameraService::instantiate()， CameraService 本身并没有实现这个方法CameraService.cpp (frameworks\\av\\services\\camera\\libcameraservice)CameraService.h (frameworks\\av\\services\\camera\\libcameraservice)BinderService.h (frameworks\\native\\include\\binder) 12345678class CameraService : public BinderService&lt;CameraService&gt;, public BnCameraService, public IBinder::DeathRecipient, public camera_module_callbacks_t{ ......} 在其父类中寻找instantiate()函数，BinderService是一个模板类 1234567891011121314template&lt;typename SERVICE&gt;class BinderService{public: static status_t publish(bool allowIsolated = false) { //BinderService::publish sp&lt;IServiceManager&gt; sm(defaultServiceManager()); //拿到ServiceManager的Bp return sm-&gt;addService( String16(SERVICE::getServiceName()), new SERVICE(), allowIsolated); //这里的SERVICE就是CameraService } ..... static void instantiate() { publish(); } //BinderService::instantiate .....}; 这里会new CameraService()， 12345678910CameraService::CameraService() :mSoundRef(0), mModule(0){ ALOGI(\"CameraService started (pid=%d)\", getpid()); gCameraService = this; //保存一个本地指针 for (size_t i = 0; i &lt; MAX_CAMERAS; ++i) { mStatusList[i] = ICameraServiceListener::STATUS_PRESENT; } this-&gt;camera_device_status_change = android::camera_device_status_change;} 到这里，CameraService就启动了。 Camera连接过程Camera.java (frameworks\\base\\core\\java\\android\\hardware)Camera.cpp (frameworks\\av\\camera)android_hardware_Camera.cpp (frameworks\\base\\core\\jni)从java-&gt;jni-&gt;CPP的典型过程首先从Camera.java入手，这里通过open()方法，创建Camera 123456789101112131415public static Camera open(int cameraId) { return new Camera(cameraId);}public static Camera open() { int numberOfCameras = getNumberOfCameras(); CameraInfo cameraInfo = new CameraInfo(); for (int i = 0; i &lt; numberOfCameras; i++) { getCameraInfo(i, cameraInfo); if (cameraInfo.facing == CameraInfo.CAMERA_FACING_BACK) { return new Camera(i); } } return null;} 两个open()方法，默认打开后置摄像头，new Camera()对象， 1234567891011121314Camera(int cameraId) { int err = cameraInitNormal(cameraId);//做事的主要地方 if (checkInitErrors(err)) { switch(err) { //通过返回的错误信息，抛不同的异常信息 case EACCESS: throw new RuntimeException(\"Fail to connect to camera service\"); case ENODEV: throw new RuntimeException(\"Camera initialization failed\"); default: // Should never hit this. throw new RuntimeException(\"Unknown camera error\"); } }} 接下来看下代码，最后会落脚到哪一块呢？ 123456789101112131415161718192021222324252627private int cameraInitNormal(int cameraId) { //这里的CAMERA_HAL_API_VERSION_NORMAL_CONNECT后面会提到用来区别不同的connect return cameraInitVersion(cameraId, CAMERA_HAL_API_VERSION_NORMAL_CONNECT);}......private int cameraInitVersion(int cameraId, int halVersion) { mShutterCallback = null; mRawImageCallback = null; mJpegCallback = null; mPreviewCallback = null; mPostviewCallback = null; mUsingPreviewAllocation = false; mZoomListener = null; //初始化几个callback和一些变量 Looper looper; //mEventHandler后面会讲到是对底层上报内容的处理handler if ((looper = Looper.myLooper()) != null) { mEventHandler = new EventHandler(this, looper); } else if ((looper = Looper.getMainLooper()) != null) { mEventHandler = new EventHandler(this, looper); } else { mEventHandler = null; } String packageName = ActivityThread.currentPackageName(); return native_setup(new WeakReference&lt;Camera&gt;(this), cameraId, halVersion, packageName);} 可以看到native_setup是一个native方法，具体实现在android_hardware_Camera.cpp (frameworks\\base\\core\\jni) 12345678910111213141516171819202122232425262728static jint android_hardware_Camera_native_setup(JNIEnv *env, jobject thiz, jobject weak_this, jint cameraId, jint halVersion, jstring clientPackageName){ ...... sp&lt;Camera&gt; camera; //之前在创建Camera对象的时候设置的一个常量，此时走到connect方法 if (halVersion == CAMERA_HAL_API_VERSION_NORMAL_CONNECT) { // Default path: hal version is don't care, do normal camera connect. camera = Camera::connect(cameraId, clientName, Camera::USE_CALLING_UID); } else { jint status = Camera::connectLegacy(cameraId, halVersion, clientName, Camera::USE_CALLING_UID, camera); if (status != NO_ERROR) { return status; } } ...... // We use a weak reference so the Camera object can be garbage collected. // The reference is only used as a proxy for callbacks. sp&lt;JNICameraContext&gt; context = new JNICameraContext(env, weak_this, clazz, camera); context-&gt;incStrong((void*)android_hardware_Camera_native_setup); camera-&gt;setListener(context);//listener用于处理底层数据上报 // save context in opaque field env-&gt;SetLongField(thiz, fields.context, (jlong)context.get()); return NO_ERROR;} 从JNI往下就是CPP，继续探寻Camera连接过程Camera.cpp (frameworks\\av\\camera)CameraBase.cpp (frameworks\\av\\camera) 12345sp&lt;Camera&gt; Camera::connect(int cameraId, const String16&amp; clientPackageName, int clientUid){ //CameraBaseT为模板类 return CameraBaseT::connect(cameraId, clientPackageName, clientUid);} CameraBase中connect函数模板替换成 123456789101112131415161718192021222324252627sp&lt;Camera&gt; CameraBase&lt;Camera, CameraTraits&lt;Camera&gt;&gt;::connect(int cameraId, const String16&amp; clientPackageName, int clientUid){ ALOGV(\"%s: connect\", __FUNCTION__); sp&lt;Camera&gt; c = new Camera(cameraId); sp&lt;ICameraClient&gt; cl = c; status_t status = NO_ERROR; const sp&lt;ICameraService&gt;&amp; cs = getCameraService();//获取CameraService的Bp if (cs != 0) { //这里TCamConncectService是一个函数指针，指向的是ICameraService中的connect方法 TCamConnectService fnConnectService = TCamTraits::fnConnectService; status = (cs.get()-&gt;*fnConnectService)(cl, cameraId, clientPackageName, clientUid, /*out*/ c-&gt;mCamera); status = (cs.get()-&gt;*fnConnectService)(cl, cameraId, clientPackageName, clientUid, /*out*/ c-&gt;mCamera); } if (status == OK &amp;&amp; c-&gt;mCamera != 0) { c-&gt;mCamera-&gt;asBinder()-&gt;linkToDeath(c); c-&gt;mStatus = NO_ERROR; } else { ALOGW(\"An error occurred while connecting to camera: %d\", cameraId); c.clear(); } return c;} 这里可能有点绕，稍微讲解一下，模板上 template &lt;typename TCam, typename TCamTraits&gt; 这里TCam化成Camera应该比较清晰，而TCamTraits的替换，首先从CameraBase.h文件中看 1234template &lt;typename TCam&gt;struct CameraTraits {};template &lt;typename TCam, typename TCamTraits = CameraTraits&lt;TCam&gt; &gt; 然后我们再到Camera.h中看template &lt;&gt; struct CameraTraits { typedef CameraListener TCamListener; typedef ICamera TCamUser; typedef ICameraClient TCamCallbacks; typedef status_t (ICameraService::*TCamConnectService)(const sp&amp;, int, const String16&amp;, int, /out/ sp&amp;); static TCamConnectService fnConnectService; }; 中间有些过程，应该好理解了，这里绕了一下，最后落脚到ICameraService.cpp中的connect方法，这一部分涉及到Binder机制比较多，暂时先不讲解具体内容，注意调用的地方即可。 ICameraService.cpp (frameworks\\av\\camera) 123456789101112131415161718192021// connect to camera service (android.hardware.Camera)virtual status_t connect(const sp&lt;ICameraClient&gt;&amp; cameraClient, int cameraId, const String16 &amp;clientPackageName, int clientUid, /*out*/ sp&lt;ICamera&gt;&amp; device){ Parcel data, reply; data.writeInterfaceToken(ICameraService::getInterfaceDescriptor()); data.writeStrongBinder(cameraClient-&gt;asBinder()); data.writeInt32(cameraId); data.writeString16(clientPackageName); data.writeInt32(clientUid); remote()-&gt;transact(BnCameraService::CONNECT, data, &amp;reply);//通过binder远端调用传入的code为BnCameraservice::CONNECT if (readExceptionCode(reply)) return -EPROTO; status_t status = reply.readInt32(); if (reply.readInt32() != 0) { device = interface_cast&lt;ICamera&gt;(reply.readStrongBinder());//转换为BpCamera } return status;} 接下来或执行到BnCameraService的onTransact()方法，主要就是switch_case，上面传入的是CONNECT 1234567891011121314151617181920212223242526272829status_t BnCameraService::onTransact( uint32_t code, const Parcel&amp; data, Parcel* reply, uint32_t flags){ switch(code) { ...... case CONNECT: { CHECK_INTERFACE(ICameraService, data, reply); sp&lt;ICameraClient&gt; cameraClient = interface_cast&lt;ICameraClient&gt;(data.readStrongBinder()); int32_t cameraId = data.readInt32(); const String16 clientName = data.readString16(); int32_t clientUid = data.readInt32(); sp&lt;ICamera&gt; camera; status_t status = connect(cameraClient, cameraId, clientName, clientUid, /*out*/camera); //这里BnCameraService并没有实现connect函数，实际实现在CameraService中 reply-&gt;writeNoException(); reply-&gt;writeInt32(status); if (camera != NULL) { reply-&gt;writeInt32(1); reply-&gt;writeStrongBinder(camera-&gt;asBinder()); } else { reply-&gt;writeInt32(0); } return NO_ERROR; } break; ...... } } 我们来看一下CameraService中的connect方法到底做了哪些事情 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051status_t CameraService::connect( const sp&lt;ICameraClient&gt;&amp; cameraClient, int cameraId, const String16&amp; clientPackageName, int clientUid, /*out*/ sp&lt;ICamera&gt;&amp; device) { String8 clientName8(clientPackageName); int callingPid = getCallingPid(); LOG1(\"CameraService::connect E (pid %d \\\"%s\\\", id %d)\", callingPid, clientName8.string(), cameraId); //对当前连接请求合法性的判断 status_t status = validateConnect(cameraId, /*inout*/clientUid); if (status != OK) { return status; } //Client类继承BnCamera BasicClient sp&lt;Client&gt; client; { Mutex::Autolock lock(mServiceLock); sp&lt;BasicClient&gt; clientTmp; //判断当前设备是否被占有或者是重复请求 if (!canConnectUnsafe(cameraId, clientPackageName, cameraClient-&gt;asBinder(), /*out*/clientTmp)) { return -EBUSY;//从返回结果可以看出这个函数的用途 } else if (client.get() != NULL) { device = static_cast&lt;Client*&gt;(clientTmp.get()); return OK; } //考虑当前没有其他程序占用摄像头，走到下一步 status = connectHelperLocked(/*out*/client, cameraClient, cameraId, clientPackageName, clientUid, callingPid); if (status != OK) { return status; } } // important: release the mutex here so the client can call back // into the service from its destructor (can be at the end of the call) //赋值给device作为传出参数 device = client; return OK;} 继续跟踪到connectHelperLocked()函数中 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071status_t CameraService::connectHelperLocked( /*out*/ sp&lt;Client&gt;&amp; client, /*in*/ const sp&lt;ICameraClient&gt;&amp; cameraClient, int cameraId, const String16&amp; clientPackageName, int clientUid, int callingPid, int halVersion, bool legacyMode) { int facing = -1; int deviceVersion = getDeviceVersion(cameraId, &amp;facing); if (halVersion &lt; 0 || halVersion == deviceVersion) { // Default path: HAL version is unspecified by caller, create CameraClient // based on device version reported by the HAL. switch(deviceVersion) { case CAMERA_DEVICE_API_VERSION_1_0: //创建CameraClient对象 client = new CameraClient(this, cameraClient, clientPackageName, cameraId, facing, callingPid, clientUid, getpid(), legacyMode); break; case CAMERA_DEVICE_API_VERSION_2_0: case CAMERA_DEVICE_API_VERSION_2_1: case CAMERA_DEVICE_API_VERSION_3_0: case CAMERA_DEVICE_API_VERSION_3_1: case CAMERA_DEVICE_API_VERSION_3_2: client = new Camera2Client(this, cameraClient, clientPackageName, cameraId, facing, callingPid, clientUid, getpid(), legacyMode); break; case -1: ALOGE(\"Invalid camera id %d\", cameraId); return BAD_VALUE; default: ALOGE(\"Unknown camera device HAL version: %d\", deviceVersion); return INVALID_OPERATION; } } else { // A particular HAL version is requested by caller. Create CameraClient // based on the requested HAL version. if (deviceVersion &gt; CAMERA_DEVICE_API_VERSION_1_0 &amp;&amp; halVersion == CAMERA_DEVICE_API_VERSION_1_0) { // Only support higher HAL version device opened as HAL1.0 device. client = new CameraClient(this, cameraClient, clientPackageName, cameraId, facing, callingPid, clientUid, getpid(), legacyMode); } else { // Other combinations (e.g. HAL3.x open as HAL2.x) are not supported yet. ALOGE(\"Invalid camera HAL version %x: HAL %x device can only be\" \" opened as HAL %x device\", halVersion, deviceVersion, CAMERA_DEVICE_API_VERSION_1_0); return INVALID_OPERATION; } } //主要是对CameraClient的初始化过程 status_t status = connectFinishUnsafe(client, client-&gt;getRemote()); if (status != OK) { // this is probably not recoverable.. maybe the client can try again return status; } //保存CameraClient对象到本地数组中，以备CameraService使用 mClient[cameraId] = client; LOG1(\"CameraService::connect X (id %d, this pid is %d)\", cameraId, getpid()); return OK;} 这里的client创建成功后会赋值给device，而device就是之前连接过程中的传入参数，到这里Camera的连接过程就基本完成了。 本文主要顺着代码理了一下过程，具体细节地方可能有所忽略。主要的流程图如下，欢迎交流指正。 本文中代码使用的是Android5.1原始代码","link":"/2015/08/15/《Android Framework 之路》Android5.1 Camera Framework（一）/"},{"title":"RxJava2-线程管理和流程浅析","text":"介绍 承接上文，结合使用场景，讨论一下如何告别AsyncTask，就是因为RxJava的强大线程管理功能。 举例说明认识RxJava之前，我们处理异步任务的方式主要有两种： AsyncTask Thread + Runnable。 涉及的代码量相比较RxJava而言大太多，针对Handler处理不好，可能存在内存泄漏的风险。不赘述，看看如何使用RxJava处理异步任务。 异步处理代码示例12345678910111213141516171819202122232425262728293031323334353637Observable&lt;Integer&gt; observable = Observable.create(new ObservableOnSubscribe&lt;Integer&gt;() { @Override public void subscribe(ObservableEmitter&lt;Integer&gt; e) throws Exception { Logger(\"Emit 111\"); e.onNext(111); Logger(\"Emit 222\"); e.onNext(222); Logger(\"Emit onComplete\"); e.onComplete(); }});Observer&lt;Integer&gt; observer = new Observer&lt;Integer&gt;() { @Override public void onSubscribe(Disposable d) { Logger(\"onSubscribe\"); } @Override public void onNext(Integer integer) { Logger(\"onNext integer = \" + integer); } @Override public void onError(Throwable e) { Logger(\"onError e = \" + e.getMessage()); } @Override public void onComplete() { Logger(\"onComplete\"); }};observable.subscribeOn(Schedulers.newThread()) .observeOn(AndroidSchedulers.mainThread()) .subscribe(observer); 运行结果可以清楚的看到，Observer下的操作是在主线程下完成的，而Observable下发射器的发射动作却是在一个新的线程中完成的。通过这种操作，我们可以在subscribe方法中执行耗时操作，然后结果通过onNext()方法返回给主线程，实现异步处理的目的。常用的场景：访问数据库，网络请求数据，后台计算操作等等。 Schedulers 和 AndroidSchedulersAndroidSchedulers是RxAndroid中的线程调度器，主要用途如上所示，AndroidSchedulers.mainThread，代表Android中的主线程（UI线程）。 方法 解释 Schedulers.computation() 用于计算任务 Schedulers.from(Executor executor) 使用指定的Executor作为调度器 Schedulers.io() 用于IO密集型任务，如异步阻塞IO操作，这个调度器的线程池会根据需要增长 Scheduler.newThread() 为每个任务创建一个新线程 Scheduler.shutdown() 停止调度器 Scheduler.single() 单独线程 Scheduler.start() 启动调度器 Scheduler.trampoline() 在当前线程中，但是会等到当前线程任务执行完毕之后再去执行 AndroidScheduler.mainThread() 主线程 源码Observable.create()1234public static &lt;T&gt; Observable&lt;T&gt; create(ObservableOnSubscribe&lt;T&gt; source) { ObjectHelper.requireNonNull(source, \"source is null\"); return RxJavaPlugins.onAssembly(new ObservableCreate&lt;T&gt;(source));} 先执行非空检查，然后通过ObservableCreate来创建Observable。而ObservableCreate继承Observable。看下代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101//ObservableCreate继承Observablepublic final class ObservableCreate&lt;T&gt; extends Observable&lt;T&gt; { //ObservableOnSubscribe接口只有一个subscribe方法 final ObservableOnSubscribe&lt;T&gt; source; public ObservableCreate(ObservableOnSubscribe&lt;T&gt; source) { //赋值，结合上面Observable的create方法，这个source应该是我们new出来的ObservableOnSubscribe this.source = source; } //这个方法在Observable执行subscribe(Observer)的时候使用到 @Override protected void subscribeActual(Observer&lt;? super T&gt; observer) { //创建CreateEmitter，传入observer,内部使用 CreateEmitter&lt;T&gt; parent = new CreateEmitter&lt;T&gt;(observer); //执行observer的onSubscribe方法，parent是CreateEmitter，实现了Disposable，和我们创建Observer时实现的onSubscribe方法一致，没毛病 observer.onSubscribe(parent); try { //执行subscribe方法，source为ObservableOnSubscribe对象，parent为CreateEmitter，而CreateEmitter实现ObservableEmitter接口，没毛病 source.subscribe(parent); } catch (Throwable ex) { Exceptions.throwIfFatal(ex); //CreateEmitter执行onError方法 parent.onError(ex); } } //CreateEmitter类继承AtomicReference&lt;Disposable&gt;实现ObservableEmitter和Disposable 接口 static final class CreateEmitter&lt;T&gt; extends AtomicReference&lt;Disposable&gt; implements ObservableEmitter&lt;T&gt;, Disposable { private static final long serialVersionUID = -3434801548987643227L; //创建过程中传入的Observer final Observer&lt;? super T&gt; observer; CreateEmitter(Observer&lt;? super T&gt; observer) { this.observer = observer; } //OnNext方法 @Override public void onNext(T t) { //非空检查，onNext在2.0之后不允许传入null值作为参数 if (t == null) { onError(new NullPointerException(\"onNext called with null. Null values are generally not allowed in 2.x operators and sources.\")); return; } //这个对应上我们的上一篇博客，一次性水管，如果isDisposed为true,则发射器发出的事件，将不会被观察者执行 if (!isDisposed()) { observer.onNext(t); } } //onError方法，当tryOnErro返回false的时候，执行RxJavaPlugins.onError(t)，何时tryOnError会返回false呢？看下面 @Override public void onError(Throwable t) { //当isDisposed()为true后，会执行RxJavaPlugins.onError(t)操作，也就是说如果在isDisposed()为true的情况下，发射器还发出onError()事件，会导致程序崩溃。具体看下面的运行示例。 if (!tryOnError(t)) { RxJavaPlugins.onError(t); } } @Override public boolean tryOnError(Throwable t) { //也是不允许传入null if (t == null) { t = new NullPointerException(\"onError called with null. Null values are generally not allowed in 2.x operators and sources.\"); } //如果isDisposed为false,执行观察者的onError方法，然后执行dispose()操作，也就是观察者不处理后面发射器发送的事件了。估计onComplete()方法中也会有类似的操作流程 if (!isDisposed()) { try { observer.onError(t); } finally { dispose(); } return true; } //只有当isDisposed为true的时候回返回false，也就是上一个方法回执行RxJavaPlugins.onError(t);操作 return false; } @Override public void onComplete() { //和上面onError(）操作类似，不同的是没有非空检查，因为onComplete没有参数。 if (!isDisposed()) { try { observer.onComplete(); } finally { dispose(); } } } …… } …… //这部分介绍的是SerializedEmitter，暂无涉及} 举例说明，isDisposed()为true时，发射器继续发送onError事件会导致程序崩溃。 123456789101112131415161718192021222324252627282930313233343536373839404142Observable&lt;Integer&gt; observable = Observable.create(new ObservableOnSubscribe&lt;Integer&gt;() { @Override public void subscribe(ObservableEmitter&lt;Integer&gt; e) throws Exception { Logger(\"Emit 111\"); e.onNext(111); Logger(\"Emit 222\"); e.onNext(222); Logger(\"Emit 333\"); e.onNext(333); Logger(\"Emit onError\"); e.onError(new Throwable(\"Test Disposable onError\")); } }); Observer&lt;Integer&gt; observer = new Observer&lt;Integer&gt;() { Disposable mDisposable; @Override public void onSubscribe(Disposable d) { Logger(\"onSubscribe\"); mDisposable = d; } @Override public void onNext(Integer integer) { Logger(\"onNext integer = \" + integer); if(mDisposable!=null &amp;&amp; !mDisposable.isDisposed() &amp;&amp; integer == 222) { mDisposable.dispose(); } } @Override public void onError(Throwable e) { Logger(\"onError e = \" + e.getMessage()); } @Override public void onComplete() { Logger(\"onComplete\"); } }; observable.subscribe(observer); 运行结果： Observer创建Observer，无甚特殊，注意onSubscribe，onNext，onError传入的参数不能为空以及Disposable 的使用。 123456789public interface Observer&lt;T&gt; { void onSubscribe(@NonNull Disposable d); void onNext(@NonNull T t); void onError(@NonNull Throwable e); void onComplete();} observable.subscribe(observer)分析一下subscribe方法 1234567891011121314151617181920212223public final void subscribe(Observer&lt;? super T&gt; observer) { //observer非空检查 ObjectHelper.requireNonNull(observer, \"observer is null\"); try { //关联observable和observer observer = RxJavaPlugins.onSubscribe(this, observer); ObjectHelper.requireNonNull(observer, \"Plugin returned null Observer\"); //这个方法在Observable中是个抽象方法，但是结合上面Observerable的create过程，可以知道这里实际上调用的是ObservableCreate的subscribeActual方法，也就是上面我们分析的过程，没毛病 subscribeActual(observer); } catch (NullPointerException e) { // NOPMD throw e; } catch (Throwable e) { Exceptions.throwIfFatal(e); // can't call onError because no way to know if a Disposable has been set or not // can't call onSubscribe because the call might have set a Subscription already RxJavaPlugins.onError(e); NullPointerException npe = new NullPointerException(\"Actually not, but can't throw other exceptions due to RS\"); npe.initCause(e); throw npe; }} 一路看下来，我们就可以很快的和我们做的测试对应上，先调用onSubscribe方法，然后执行subscribe方法中的发射器操作，根据发射器的操作Observer作出对应的处理。 subscribeOnsubscribeOn用来指定Observable在哪个线程执行自己的subscribe方法。 12345public final Observable&lt;T&gt; subscribeOn(Scheduler scheduler) { //scheduler非空检查 ObjectHelper.requireNonNull(scheduler, \"scheduler is null\"); return RxJavaPlugins.onAssembly(new ObservableSubscribeOn&lt;T&gt;(this, scheduler));} 创建了一个ObservableSubscribeOn，这个类千万别和上面创建Observable过程中使用的ObservableOnSubscribe接口弄混淆，结合当前操作为subscribeOn来记住这个类名。 1234public ObservableSubscribeOn(ObservableSource&lt;T&gt; source, Scheduler scheduler) { super(source); this.scheduler = scheduler;} Observerable继承自ObservableSource，所以创建ObservableSubscribeOn的时候Observable和scheduler传递过来。ObservableSubscribeOn继承AbstractObservableWithUpstream，而后者又继承Observable。所以实际上经过subscribeOn操作之后，后续操作的对象从Observerable变成了ObservableSubscribeOn，所以，当后面执行subscribe时执行的subscribeActual方法为ObservableSubscribeOn重的对应方法 123456789101112 @Override public void subscribeActual(final Observer&lt;? super T&gt; s) { //封装Observer，实际Observer由其内部actual维护 final SubscribeOnObserver&lt;T&gt; parent = new SubscribeOnObserver&lt;T&gt;(s); //Observer执行onSubscribe方法，SubscribeOnObserver实现Disposable接口，所以上面的例子中onSubscribe传递的是Disposable类型 s.onSubscribe(parent);//这里有3个操作：//1. 创建SubscribeTask，传入封装后的Observer//2. 调度器执行scheduleDirect操作//3. 封装后的Observer执行setDisposable操作 parent.setDisposable(scheduler.scheduleDirect(new SubscribeTask(parent))); } 关注scheduler.scheduleDirect(new SubscribeTask(parent))，先看下 123456789101112final class SubscribeTask implements Runnable { private final SubscribeOnObserver&lt;T&gt; parent; SubscribeTask(SubscribeOnObserver&lt;T&gt; parent) { this.parent = parent; } @Override public void run() { source.subscribe(parent); }} 实现Runnable，终于看到一个有点熟悉的东西。传入的parent为封装后的Observer。而source则是创建ObservableSubscribeOn过程中传入的Observable。在看scheduleDirect方法之前，我们得先弄清楚这个scheduler是个什么东西？在Schedulers类中，不同的Scheduler已经初始化完成。 1234567891011static { SINGLE = RxJavaPlugins.initSingleScheduler(new SingleTask()); COMPUTATION = RxJavaPlugins.initComputationScheduler(new ComputationTask()); IO = RxJavaPlugins.initIoScheduler(new IOTask()); TRAMPOLINE = TrampolineScheduler.instance(); NEW_THREAD = RxJavaPlugins.initNewThreadScheduler(new NewThreadTask());} 就看下NEW_THREAD 这个，首先new NewThreadTask() 123456static final class NewThreadTask implements Callable&lt;Scheduler&gt; { @Override public Scheduler call() throws Exception { return NewThreadHolder.DEFAULT; }} 123static final class NewThreadHolder { static final Scheduler DEFAULT = new NewThreadScheduler();} 12345678910111213141516171819202122232425262728293031public final class NewThreadScheduler extends Scheduler { final ThreadFactory threadFactory; private static final String THREAD_NAME_PREFIX = \"RxNewThreadScheduler\"; private static final RxThreadFactory THREAD_FACTORY; /** The name of the system property for setting the thread priority for this Scheduler. */ private static final String KEY_NEWTHREAD_PRIORITY = \"rx2.newthread-priority\"; static { int priority = Math.max(Thread.MIN_PRIORITY, Math.min(Thread.MAX_PRIORITY, Integer.getInteger(KEY_NEWTHREAD_PRIORITY, Thread.NORM_PRIORITY))); THREAD_FACTORY = new RxThreadFactory(THREAD_NAME_PREFIX, priority); } public NewThreadScheduler() { this(THREAD_FACTORY); } public NewThreadScheduler(ThreadFactory threadFactory) { this.threadFactory = threadFactory; } @NonNull @Override public Worker createWorker() { return new NewThreadWorker(threadFactory); }} 看到了ThreadFactory，RxThreadFactory，而RxThreadFactory实现了ThreadFactory接口，所以最后还是线程的使用，只是RxJava对这些基础的东西做了深度的封装和流程上的优化，让我们更方便的使用。回溯到上面的scheduleDirect方法， 123public Disposable scheduleDirect(@NonNull Runnable run) { return scheduleDirect(run, 0L, TimeUnit.NANOSECONDS);} 12345678910111213public Disposable scheduleDirect(@NonNull Runnable run, long delay, @NonNull TimeUnit unit) { //创建工作线程，以NewThreadScheduler为例，是创建NewThreadWorker final Worker w = createWorker(); // final Runnable decoratedRun = RxJavaPlugins.onSchedule(run); //封装出一个带Dispose的Task，方便控制 DisposeTask task = new DisposeTask(decoratedRun, w); //以NewThreadScheduler为例，这里执行的是NewThreadWorker中的schedule方法 w.schedule(task, delay, unit); return task;} 123456public Disposable schedule(@NonNull final Runnable action, long delayTime, @NonNull TimeUnit unit) { if (disposed) { return EmptyDisposable.INSTANCE; } return scheduleActual(action, delayTime, unit, null);} 忽略disposed的影响，最后执行到scheduleActual 1234567891011121314151617181920212223242526272829public ScheduledRunnable scheduleActual(final Runnable run, long delayTime, @NonNull TimeUnit unit, @Nullable DisposableContainer parent) { Runnable decoratedRun = RxJavaPlugins.onSchedule(run); ScheduledRunnable sr = new ScheduledRunnable(decoratedRun, parent); if (parent != null) { if (!parent.add(sr)) { return sr; } } Future&lt;?&gt; f; try { //直接提交或者进入队列 if (delayTime &lt;= 0) { f = executor.submit((Callable&lt;Object&gt;)sr); } else { f = executor.schedule((Callable&lt;Object&gt;)sr, delayTime, unit); } sr.setFuture(f); } catch (RejectedExecutionException ex) { if (parent != null) { parent.remove(sr); } RxJavaPlugins.onError(ex); } return sr; } 可以看到熟悉的ScheduledExecutorService和Future。所以，综上所述，其内部也是新创建一个线程，结合Runnable。 observeOn原理我觉得和subscribeOn没有太大的差别。不做赘述。","link":"/2018/01/06/RxJava2小白手册（2）- 线程管理和流程浅析/"},{"title":"《Android Framework 之路》Android5.1 Camera Framework（二）","text":"上一次讲解了一下CameraService的启动过程，今天梳理一下Camera预览的过程 tartPreview过程 首先，我们还是从应用层的使用入手 Camera.java (packages\\apps\\legacycamera\\src\\com\\android\\camera) 123456Thread mCameraPreviewThread = new Thread(new Runnable() { public void run() { initializeCapabilities(); //初始化参数 startPreview(); //启动预览 }}); 针对相机应用，采用了单独的线程来处理预览，猜测是为了加快预览显示的速度 123456789101112131415161718192021222324252627private void startPreview() { ...... // If we're previewing already, stop the preview first (this will blank // the screen). if (mCameraState != PREVIEW_STOPPED) stopPreview(); setPreviewDisplay(mSurfaceHolder); //设置SurfaceHolder setDisplayOrientation(); //设置显示方向 ...... setCameraParameters(UPDATE_PARAM_ALL); //设置参数 // Inform the mainthread to go on the UI initialization. if (mCameraPreviewThread != null) { synchronized (mCameraPreviewThread) { mCameraPreviewThread.notify(); } } try { Log.v(TAG, \"startPreview\"); mCameraDevice.startPreview(); //启动预览，若失败，关闭Camera } catch (Throwable ex) { closeCamera(); throw new RuntimeException(\"startPreview failed\", ex); } ...... } 这里就是APP中启动预览的过程，过程必然会是 java -&gt; JNI -&gt; cpp， 然后通过Binder机制执行到CameraClient中的 CameraClient.cpp (av\\services\\camera\\libcameraservice\\api1) 1234status_t CameraClient::startPreview() { LOG1(\"startPreview (pid %d)\", getCallingPid()); return startCameraMode(CAMERA_PREVIEW_MODE);} 这里传入的是CAMERA_PREVIEW_MODE，枚举类型是在CameraClient.h中定义的 // camera operation mode enum camera_mode { CAMERA_PREVIEW_MODE = 0, // frame automatically released CAMERA_RECORDING_MODE = 1, // frame has to be explicitly released by releaseRecordingFrame() }; 第一种是针对普通的预览，第二种是针对录像 123456789101112131415161718192021222324// start preview or recordingstatus_t CameraClient::startCameraMode(camera_mode mode) { LOG1(\"startCameraMode(%d)\", mode); Mutex::Autolock lock(mLock); status_t result = checkPidAndHardware(); if (result != NO_ERROR) return result; switch(mode) { case CAMERA_PREVIEW_MODE: if (mSurface == 0 &amp;&amp; mPreviewWindow == 0) { LOG1(\"mSurface is not set yet.\"); // still able to start preview in this case. } return startPreviewMode(); //开始预览模式 case CAMERA_RECORDING_MODE: if (mSurface == 0 &amp;&amp; mPreviewWindow == 0) { ALOGE(\"mSurface or mPreviewWindow must be set before startRecordingMode.\"); return INVALID_OPERATION; } return startRecordingMode(); //开始录像模式 default: return UNKNOWN_ERROR; }} 这里我们走的是预览模式 12345678910111213141516171819202122status_t CameraClient::startPreviewMode() { LOG1(\"startPreviewMode\"); //LOG1,一直忘记说了，这是有log开关用过setprop可以使用 status_t result = NO_ERROR; // if preview has been enabled, nothing needs to be done if (mHardware-&gt;previewEnabled()) { //如果已经启动预览，不必重复 return NO_ERROR; } if (mPreviewWindow != 0) { //适配显示窗口的大小 native_window_set_scaling_mode(mPreviewWindow.get(), NATIVE_WINDOW_SCALING_MODE_SCALE_TO_WINDOW); //调整帧数据的方向 native_window_set_buffers_transform(mPreviewWindow.get(), mOrientation); } mHardware-&gt;setPreviewWindow(mPreviewWindow); //设置mPreviewWindow为显示窗口 result = mHardware-&gt;startPreview(); //HAL层启动预览 return result; //返回结果} 这里面涉及到native_window_set_scaling_mode，native_window_set_buffers_transform，直接跟代码，看注释就可以理解，这部分涉及到显示的一些内容，这里暂时不做讲解，native_window_set_scaling_mode设置模式为NATIVE_WINDOW_SCALING_MODE_SCALE_TO_WINDOW，native_window_set_buffers_transform是用来调整方向。 这里有一个问题，mPreviewWindow是从何而来的呢？ 还记得我们在应用层的startPreview()方法中会有这么一个过程 12setPreviewDisplay(mSurfaceHolder);setDisplayOrientation(); 这里的setPreviewDisplay(mSurfaceHolder)，中间的过程大家可以自己跟一下，最后会执行到 1234567891011121314status_t CameraClient::setPreviewTarget( const sp&lt;IGraphicBufferProducer&gt;&amp; bufferProducer) { ...... sp&lt;IBinder&gt; binder; sp&lt;ANativeWindow&gt; window; if (bufferProducer != 0) { binder = bufferProducer-&gt;asBinder(); // Using controlledByApp flag to ensure that the buffer queue remains in // async mode for the old camera API, where many applications depend // on that behavior. window = new Surface(bufferProducer, /*controlledByApp*/ true); //这个家伙 } return setPreviewWindow(binder, window);} 1234567891011121314151617181920212223242526272829303132333435status_t CameraClient::setPreviewWindow(const sp&lt;IBinder&gt;&amp; binder, const sp&lt;ANativeWindow&gt;&amp; window) { Mutex::Autolock lock(mLock); ...... if (window != 0) { result = native_window_api_connect(window.get(), NATIVE_WINDOW_API_CAMERA); if (result != NO_ERROR) { ALOGE(\"native_window_api_connect failed: %s (%d)\", strerror(-result), result); return result; } } // If preview has been already started, register preview buffers now. if (mHardware-&gt;previewEnabled()) { if (window != 0) { native_window_set_scaling_mode(window.get(), NATIVE_WINDOW_SCALING_MODE_SCALE_TO_WINDOW); native_window_set_buffers_transform(window.get(), mOrientation); result = mHardware-&gt;setPreviewWindow(window); } } if (result == NO_ERROR) { // Everything has succeeded. Disconnect the old window and remember the // new window. disconnectWindow(mPreviewWindow); mSurface = binder; mPreviewWindow = window; //这里便是赋值的操作了，后面我们操作的mPreviewWindow } else { // Something went wrong after we connected to the new window, so // disconnect here. disconnectWindow(window); } return result;} 是不是看的很眼熟，和startPreviewMode()的过程有点相似。这就是mPreviewWindow的赋值过程。 回到setPreviewMode()函数中，其中主要的过程是这两个 mHardware-&gt;setPreviewWindow(mPreviewWindow); result = mHardware-&gt;startPreview(); 这里都是HAL层的处理，将窗口传下去，然后启动预览，最后数据就可以投射到这个预览窗口上了。 我们继续往下看一下， CameraHardwareInterface.h (av\\services\\camera\\libcameraservice\\device1) 123456789101112131415/** Set the ANativeWindow to which preview frames are sent */status_t setPreviewWindow(const sp&lt;ANativeWindow&gt;&amp; buf){ ALOGV(\"%s(%s) buf %p\", __FUNCTION__, mName.string(), buf.get()); if (mDevice-&gt;ops-&gt;set_preview_window) { mPreviewWindow = buf; mHalPreviewWindow.user = this; ALOGV(\"%s &amp;mHalPreviewWindow %p mHalPreviewWindow.user %p\", __FUNCTION__, &amp;mHalPreviewWindow, mHalPreviewWindow.user); return mDevice-&gt;ops-&gt;set_preview_window(mDevice, buf.get() ? &amp;mHalPreviewWindow.nw : 0); } return INVALID_OPERATION;} 12345678910/** * Start preview mode. */ status_t startPreview() { ALOGV(\"%s(%s)\", __FUNCTION__, mName.string()); if (mDevice-&gt;ops-&gt;start_preview) return mDevice-&gt;ops-&gt;start_preview(mDevice); return INVALID_OPERATION; } 这是一个空壳，我们去看具体的实现，这里我们看下android5.1源码中Qcom的实现，由于针对HAL层的不同厂商有不同的处理方式，在这里我们就随便找个目录下的进行分析，旨在看流程，理解一些基础的内容， QCamera2Hal.cpp （\\device\\asus\\flo\\camera\\qcamera2\\hal） 1234567891011121314151617181920212223#include \"QCamera2Factory.h\"static hw_module_t camera_common = { tag: HARDWARE_MODULE_TAG, module_api_version: CAMERA_MODULE_API_VERSION_1_0, hal_api_version: HARDWARE_HAL_API_VERSION, id: CAMERA_HARDWARE_MODULE_ID, name: \"QCamera Module\", author: \"Qualcomm Innovation Center Inc\", methods: &amp;qcamera::QCamera2Factory::mModuleMethods, dso: NULL, reserved: {0},};camera_module_t HAL_MODULE_INFO_SYM = { common: camera_common, get_number_of_cameras: qcamera::QCamera2Factory::get_number_of_cameras, get_camera_info: qcamera::QCamera2Factory::get_camera_info, set_callbacks: NULL, get_vendor_tag_ops: NULL, open_legacy: NULL, reserved: {0}}; 这里提一下HAL_MODULE_INFO_SYM这个东西，本身就是一个定义在hardware.h下的一个宏，看注释，意思很明显 12define HAL_MODULE_INFO_SYM HMI //.so中将一个符号HMI,获取此符号的地址，就获取到了对应的hw_module_t地址 HAL_MODULE_INFO_SYM，这个是HAL 编译生成的so的入口，CameraService会获取这个来操作so camera_common是针对HAL规范定义的一些内容。 Camera的open指向的是&amp;qcamera::QCamera2Factory::mModuleMethods中的open方法，如下 123struct hw_module_methods_t QCamera2Factory::mModuleMethods = { open: QCamera2Factory::camera_device_open,}; 这个方法中打开设备节点，我们可以看到HAL层中open的过程是很有讲究的，也不能这么说，应为HAL的处理方式基本上都是如此。 123456789101112131415int QCamera2Factory::camera_device_open( const struct hw_module_t *module, const char *id, struct hw_device_t **hw_device){ if (module != &amp;HAL_MODULE_INFO_SYM.common) { ALOGE(\"Invalid module. Trying to open %p, expect %p\", module, &amp;HAL_MODULE_INFO_SYM.common); return INVALID_OPERATION; } if (!id) { ALOGE(\"Invalid camera id\"); return BAD_VALUE; } return gQCamera2Factory.cameraDeviceOpen(atoi(id), hw_device);} 123456789101112131415161718int QCamera2Factory::cameraDeviceOpen(int camera_id, struct hw_device_t **hw_device){ int rc = NO_ERROR; if (camera_id &lt; 0 || camera_id &gt;= mNumOfCameras) return BAD_VALUE; //到这里才是真正的HAL层的创建，可见HAL层的创建和open操作是相关的 QCamera2HardwareInterface *hw = new QCamera2HardwareInterface(camera_id); if (!hw) { ALOGE(\"Allocation of hardware interface failed\"); return NO_MEMORY; } rc = hw-&gt;openCamera(hw_device); if (rc != NO_ERROR) { delete hw; } return rc;} 之前在CameraService过程中提到的CameraHardwareInterface空壳就是为这个QCamera2HardwareInterface准备的，具体实现全部都在这个类中。 关于QCamera2HardwareInterface的内容我们在后面会讲到，这里暂且先放一下，接着上面的 mHardware-&gt;setPreviewWindow(mPreviewWindow); result = mHardware-&gt;startPreview(); 经过CameraHardwareInterface后 mDevice-&gt;ops-&gt;set_preview_window(mDevice, buf.get() ? &amp;mHalPreviewWindow.nw : 0); mDevice-&gt;ops-&gt;start_preview(mDevice); 然后经过QCamera2HardwareInterface中的mCameraOps函数指针对应表 set_preview_window: QCamera2HardwareInterface::set_preview_window start_preview: QCamera2HardwareInterface::start_preview 所以会调用到 123456789101112131415161718192021int QCamera2HardwareInterface::set_preview_window(struct camera_device *device, struct preview_stream_ops *window){ int rc = NO_ERROR; QCamera2HardwareInterface *hw = reinterpret_cast&lt;QCamera2HardwareInterface *&gt;(device-&gt;priv); if (!hw) { ALOGE(\"%s: NULL camera device\", __func__); return BAD_VALUE; } hw-&gt;lockAPI(); rc = hw-&gt;processAPI(QCAMERA_SM_EVT_SET_PREVIEW_WINDOW, (void *)window); if (rc == NO_ERROR) { hw-&gt;waitAPIResult(QCAMERA_SM_EVT_SET_PREVIEW_WINDOW); rc = hw-&gt;m_apiResult.status; } hw-&gt;unlockAPI(); return rc;} 这里会经过一轮状态机，暂时先不讲，然后执行到 int QCamera2HardwareInterface::setPreviewWindow( struct preview_stream_ops window) { mPreviewWindow = window; return NO_ERROR; } 同理，startPreview也会执行到 int QCamera2HardwareInterface::startPreview() { int32_t rc = NO_ERROR; ALOGD(“%s: E”, *func); // start preview stream if (mParameters.isZSLMode() &amp;&amp; mParameters.getRecordingHintValue() !=true) { rc = startChannel(QCAMERA_CH_TYPE_ZSL); } else { rc = startChannel(QCAMERA_CH_TYPE_PREVIEW); } ALOGD(“%s: X”, **func); return rc; } 这里开启通道，可以理解成数据通道，ZSL是之前没有的，所谓ZSL就是触发拍照后不停止预览。 这里看到会根据当前是都支持ZSL模式而进入不同的通道，我们这里就看QCAMERA_CH_TYPE_PREVIEW，startChannel 123456789int32_t QCamera2HardwareInterface::startChannel(qcamera_ch_type_enum_t ch_type){ int32_t rc = UNKNOWN_ERROR; if (m_channels[ch_type] != NULL) { rc = m_channels[ch_type]-&gt;start(); } return rc;} m_channels是不同的通道的实例的数组，这里如果没有PREVIEW的channel就直接return，岂不是无法启动预览，这个流程感觉有点不对劲。但是这整个过程跟下来也没有看到m_channels相关的初始化过程。 这个问题出在我刚才从CameraHardwareInterface跟到QCamera2HardwareInterface的时候跳过的一个内容—–状态机，在状态机中会执行一个preparePreview()的操作 12345678910111213141516171819202122232425262728293031323334353637int32_t QCamera2HardwareInterface::preparePreview(){ int32_t rc = NO_ERROR; if (mParameters.isZSLMode() &amp;&amp; mParameters.getRecordingHintValue() !=true) { rc = addChannel(QCAMERA_CH_TYPE_ZSL); //这里我们就添加了一个channel,当然这里是ZSL的 if (rc != NO_ERROR) { return rc; } } else { bool recordingHint = mParameters.getRecordingHintValue(); //recording if(recordingHint) { rc = addChannel(QCAMERA_CH_TYPE_SNAPSHOT); //录像中是可以拍照的，需要snapshot channel if (rc != NO_ERROR) { return rc; } rc = addChannel(QCAMERA_CH_TYPE_VIDEO); //video channel if (rc != NO_ERROR) { delChannel(QCAMERA_CH_TYPE_SNAPSHOT); return rc; } } rc = addChannel(QCAMERA_CH_TYPE_PREVIEW); //添加preview channel if (rc != NO_ERROR) { if (recordingHint) { delChannel(QCAMERA_CH_TYPE_SNAPSHOT); delChannel(QCAMERA_CH_TYPE_VIDEO); } return rc; } } return rc;} 在addchannel()的过程中会根据不同的channel类型创建不同的实例，这里我们直接看从addChannel()转到的addPreviewChannel()函数 12345678910111213141516171819202122232425262728293031323334353637383940int32_t QCamera2HardwareInterface::addPreviewChannel(){ int32_t rc = NO_ERROR; QCameraChannel *pChannel = NULL; //初始化一个QCameraChanel，后面要使用 if (m_channels[QCAMERA_CH_TYPE_PREVIEW] != NULL) { // if we had preview channel before, delete it first delete m_channels[QCAMERA_CH_TYPE_PREVIEW]; //如果之前preview channel存在，干掉 m_channels[QCAMERA_CH_TYPE_PREVIEW] = NULL; } pChannel = new QCameraChannel(mCameraHandle-&gt;camera_handle, mCameraHandle-&gt;ops); //new 一个新的channel ..... // meta data stream always coexists with preview if applicable rc = addStreamToChannel(pChannel, CAM_STREAM_TYPE_METADATA, metadata_stream_cb_routine, this); //添加metadata stream cb if (rc != NO_ERROR) { ALOGE(\"%s: add metadata stream failed, ret = %d\", __func__, rc); delete pChannel; return rc; } if (isNoDisplayMode()) { //判断是否为不需要显示的模式 rc = addStreamToChannel(pChannel, CAM_STREAM_TYPE_PREVIEW, nodisplay_preview_stream_cb_routine, this); } else { //这里添加preview stream cb到channel中 rc = addStreamToChannel(pChannel, CAM_STREAM_TYPE_PREVIEW, preview_stream_cb_routine, this); } if (rc != NO_ERROR) { ALOGE(\"%s: add preview stream failed, ret = %d\", __func__, rc); delete pChannel; return rc; } m_channels[QCAMERA_CH_TYPE_PREVIEW] = pChannel; //维护m_channels数据 return rc;} 这里注册的preview_stream_cb_routine回调，这之后的过程我们暂时先不去看，了解这部分之后，回到之前chanel 的start()，最后会执行到QCameraChannel::start()方法，这里往下的内容我们暂时不往下看，知道这个过程中会执行数据采集，然后返回给HAL层就行了，HAL针对底层返回的数据，我们在哪里获取，做什么对应的处理呢？找到之前注册的Callback. QCamera2HWICallbacks.cpp (\\device\\asus\\flo\\camera\\qcamera2\\hal) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657void QCamera2HardwareInterface::preview_stream_cb_routine(mm_camera_super_buf_t *super_frame, QCameraStream * stream, void *userdata){ ALOGD(\"[KPI Perf] %s : BEGIN\", __func__); int err = NO_ERROR; QCamera2HardwareInterface *pme = (QCamera2HardwareInterface *)userdata; QCameraGrallocMemory *memory = (QCameraGrallocMemory *)super_frame-&gt;bufs[0]-&gt;mem_info; ...... mm_camera_buf_def_t *frame = super_frame-&gt;bufs[0]; ...... if (!pme-&gt;needProcessPreviewFrame()) { ALOGE(\"%s: preview is not running, no need to process\", __func__); stream-&gt;bufDone(frame-&gt;buf_idx); free(super_frame); return; } if (pme-&gt;needDebugFps()) { pme-&gt;debugShowPreviewFPS(); } int idx = frame-&gt;buf_idx; pme-&gt;dumpFrameToFile(frame-&gt;buffer, frame-&gt;frame_len, frame-&gt;frame_idx, QCAMERA_DUMP_FRM_PREVIEW); //这里的注释很明显，displayer buffer而这个buffer就是我们需要投射到屏幕上的数据 // Display the buffer. int dequeuedIdx = memory-&gt;displayBuffer(idx); //这部分涉及到显示的过程，这里不做赘述 if (dequeuedIdx &lt; 0 || dequeuedIdx &gt;= memory-&gt;getCnt()) { ALOGD(\"%s: Invalid dequeued buffer index %d from display\", __func__, dequeuedIdx); } else { // Return dequeued buffer back to driver err = stream-&gt;bufDone(dequeuedIdx); if ( err &lt; 0) { ALOGE(\"stream bufDone failed %d\", err); } } //针对上层设置的datacallback过程做些处理 // Handle preview data callback if (pme-&gt;mDataCb != NULL &amp;&amp; pme-&gt;msgTypeEnabledWithLock(CAMERA_MSG_PREVIEW_FRAME) &gt; 0) { ...... qcamera_callback_argm_t cbArg; memset(&amp;cbArg, 0, sizeof(qcamera_callback_argm_t)); cbArg.cb_type = QCAMERA_DATA_CALLBACK; cbArg.msg_type = CAMERA_MSG_PREVIEW_FRAME; cbArg.data = data; if ( previewMem ) { cbArg.user_data = previewMem; cbArg.release_cb = releaseCameraMemory; } cbArg.cookie = pme; pme-&gt;m_cbNotifier.notifyCallback(cbArg); //封装完之后往上甩 } free(super_frame); ALOGD(\"[KPI Perf] %s : END\", __func__); return;} 这就是在addPreviewChannel的过程中添加的preview stream callback，当然还有metadata的，暂时先看preview的这个。这里面作的操作就是显示预览数据到窗口中，然后对设置下面的preview callback做对应的callback处理. 讲到这里，Camera的预览过程基本上就结束了，关于底层如果采集数据以及HAL中一些其他的内容，在这里没有讲解，主要是要理解这个过程，之后再每一个过程中在往下学习。 本文中代码使用的是Android5.1原始代码，欢迎大家留言交流。","link":"/2015/08/23/《Android Framework 之路》Android5.1 Camera Framework（二）/"},{"title":"《Android Framework 之路》Android5.1 Camera Framework（三）","text":"上一次讲解了一下startPreview过程，主要是为了画出一条大致的从上到下的线条，今天我们看一下Camera在Framework的sendCommand和dataCallback，这部分属于衔接过程，可以看到上下是如何交流沟通的。 首先，sendCommand Camera.java中并没有sendCommand方法，在Camera.cpp中存在sendCommand函数，所以这个sendCommand是从android_hardware_interface.cpp中开始使用的 android_hardware_Camera.cpp (base\\core\\jni) startSmoothZoom android_hardware_Camera_startSmoothZoom ——&gt;CAMERA_CMD_START_SMOOTH_ZOOM stopSmoothZoom android_hardware_Camera_stopSmoothZoom ——&gt;CAMERA_CMD_STOP_SMOOTH_ZOOM setDisplayOrientation android_hardware_Camera_setDisplayOrientation ——&gt;CAMERA_CMD_SET_DISPLAY_ORIENTATION _enableShutterSound android_hardware_Camera_enableShutterSound ——&gt;CAMERA_CMD_ENABLE_SHUTTER_SOUND _startFaceDetection android_hardware_Camera_startFaceDetection ——&gt;CAMERA_CMD_START_FACE_DETECTION _stopFaceDetection android_hardware_Camera_stopFaceDetection ——&gt;CAMERA_CMD_STOP_FACE_DETECTION enableFocusMoveCallback android_hardware_Camera_enableFocusMoveCallback ——&gt;CAMERA_CMD_ENABLE_FOCUS_MOVE_MSG 诸如此类的命令类型定义在Camera.h (system\\core\\include\\system) enum { CAMERA_CMD_START_SMOOTH_ZOOM = 1, CAMERA_CMD_STOP_SMOOTH_ZOOM = 2, CAMERA_CMD_SET_DISPLAY_ORIENTATION = 3, CAMERA_CMD_ENABLE_SHUTTER_SOUND = 4, CAMERA_CMD_PLAY_RECORDING_SOUND = 5, CAMERA_CMD_START_FACE_DETECTION = 6, CAMERA_CMD_STOP_FACE_DETECTION = 7, CAMERA_CMD_ENABLE_FOCUS_MOVE_MSG = 8, CAMERA_CMD_PING = 9, CAMERA_CMD_SET_VIDEO_BUFFER_COUNT = 10, }; 以上者几种操作都是采用sendCommand()的函数来实现的，对应的命令类型也列举出来了，HAL层会根据这个消息类型做出判断，然后做出对应的操作。 来看下sendCommand的实现： Camera.cpp (frameworks\\av\\camera) 12345678// send command to camera driverstatus_t Camera::sendCommand(int32_t cmd, int32_t arg1, int32_t arg2){ ALOGV(\"sendCommand\"); sp &lt;ICamera&gt; c = mCamera; if (c == 0) return NO_INIT; return c-&gt;sendCommand(cmd, arg1, arg2); //三个参数，第一个是消息类型，后面两个参数有时候使用有时不使用，这里应该是具有扩展性的，如果需要添加更多的参数，上下接口同时修改就可以了。} 然后通过Binder机制， 1234567891011virtual status_t sendCommand(int32_t cmd, int32_t arg1, int32_t arg2){ ALOGV(\"sendCommand\"); Parcel data, reply; data.writeInterfaceToken(ICamera::getInterfaceDescriptor()); data.writeInt32(cmd); data.writeInt32(arg1); data.writeInt32(arg2); remote()-&gt;transact(SEND_COMMAND, data, &amp;reply); return reply.readInt32();} 1234567891011121314status_t BnCamera::onTransact( uint32_t code, const Parcel&amp; data, Parcel* reply, uint32_t flags){ ...... case SEND_COMMAND: { ALOGV(\"SEND_COMMAND\"); CHECK_INTERFACE(ICamera, data, reply); int command = data.readInt32(); int arg1 = data.readInt32(); int arg2 = data.readInt32(); reply-&gt;writeInt32(sendCommand(command, arg1, arg2)); return NO_ERROR; } break;} 然后调用到 123456789101112131415161718192021222324252627282930313233343536status_t CameraClient::sendCommand(int32_t cmd, int32_t arg1, int32_t arg2) { ...... if (cmd == CAMERA_CMD_SET_DISPLAY_ORIENTATION) { // Mirror the preview if the camera is front-facing. orientation = getOrientation(arg1, mCameraFacing == CAMERA_FACING_FRONT); if (orientation == -1) return BAD_VALUE; if (mOrientation != orientation) { mOrientation = orientation; if (mPreviewWindow != 0) { native_window_set_buffers_transform(mPreviewWindow.get(), mOrientation); } } return OK; } else if (cmd == CAMERA_CMD_ENABLE_SHUTTER_SOUND) { switch (arg1) { //这里就是对参数arg1的使用，通过参数来开关拍照声音 case 0: return enableShutterSound(false); case 1: return enableShutterSound(true); default: return BAD_VALUE; } return OK; } else if (cmd == CAMERA_CMD_PLAY_RECORDING_SOUND) { //录像声音 mCameraService-&gt;playSound(CameraService::SOUND_RECORDING); } else if (cmd == CAMERA_CMD_SET_VIDEO_BUFFER_COUNT) { // Silently ignore this command return INVALID_OPERATION; } else if (cmd == CAMERA_CMD_PING) { // If mHardware is 0, checkPidAndHardware will return error. return OK; } //以上是framework可以处理的命令 return mHardware-&gt;sendCommand(cmd, arg1, arg2); //HAL层处理} 在HAL层中处理的消息类型主要是打开和停止人脸检测过程，QCamera2HWI.cpp (\\device\\asus\\flo\\camera\\qcamera2\\hal) 123456789101112131415int QCamera2HardwareInterface::sendCommand(int32_t command, int32_t /*arg1*/, int32_t /*arg2*/){ int rc = NO_ERROR; switch (command) { case CAMERA_CMD_START_FACE_DETECTION: case CAMERA_CMD_STOP_FACE_DETECTION: //开关人脸检测 rc = setFaceDetection(command == CAMERA_CMD_START_FACE_DETECTION? true : false); break; default: rc = NO_ERROR; break; } return rc;} 综上，如上就是sendCommand的过程 然后，回调Callback 从之前的文章可以看到callback主要有三种类型 notifyCallback dataCallback dataTimestampCallback 这个过程我们就不能按照之前的从上至下的跟过程了，这次需要反着来，从HAL层回调到 CameraHardwareInterface.h (frameworks\\av\\services\\camera\\libcameraservice\\device1) 12345678910111213141516171819202122232425262728293031static void __notify_cb(int32_t msg_type, int32_t ext1, int32_t ext2, void *user){ ALOGV(\"%s\", __FUNCTION__); CameraHardwareInterface *__this = static_cast&lt;CameraHardwareInterface *&gt;(user); __this-&gt;mNotifyCb(msg_type, ext1, ext2, __this-&gt;mCbUser);}static void __data_cb(int32_t msg_type, const camera_memory_t *data, unsigned int index, camera_frame_metadata_t *metadata, void *user){ ALOGV(\"%s\", __FUNCTION__); CameraHardwareInterface *__this = static_cast&lt;CameraHardwareInterface *&gt;(user); ...... __this-&gt;mDataCb(msg_type, mem-&gt;mBuffers[index], metadata, __this-&gt;mCbUser);}static void __data_cb_timestamp(nsecs_t timestamp, int32_t msg_type, const camera_memory_t *data, unsigned index, void *user){ ALOGV(\"%s\", __FUNCTION__); CameraHardwareInterface *__this = static_cast&lt;CameraHardwareInterface *&gt;(user); ...... __this-&gt;mDataCbTimestamp(timestamp, msg_type, mem-&gt;mBuffers[index], __this-&gt;mCbUser);} 其中的mNotifyCb，mDataCb，mDataCbTimestamp是在CameraClient::initialize函数中设置的 123456789101112131415161718192021void setCallbacks(notify_callback notify_cb, data_callback data_cb, data_callback_timestamp data_cb_timestamp, void* user){ mNotifyCb = notify_cb; mDataCb = data_cb; mDataCbTimestamp = data_cb_timestamp; mCbUser = user; ALOGV(\"%s(%s)\", __FUNCTION__, mName.string()); if (mDevice-&gt;ops-&gt;set_callbacks) { mDevice-&gt;ops-&gt;set_callbacks(mDevice, __notify_cb, __data_cb, __data_cb_timestamp, __get_memory, this); }} 回调自然是到CameraClient中去找了 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647void CameraClient::notifyCallback(int32_t msgType, int32_t ext1, int32_t ext2, void* user) { ......}void CameraClient::dataCallback(int32_t msgType, const sp&lt;IMemory&gt;&amp; dataPtr, camera_frame_metadata_t *metadata, void* user) { LOG2(\"dataCallback(%d)\", msgType); Mutex* lock = getClientLockFromCookie(user); if (lock == NULL) return; Mutex::Autolock alock(*lock); CameraClient* client = static_cast&lt;CameraClient*&gt;(getClientFromCookie(user)); if (client == NULL) return; if (!client-&gt;lockIfMessageWanted(msgType)) return; if (dataPtr == 0 &amp;&amp; metadata == NULL) { ALOGE(\"Null data returned in data callback\"); client-&gt;handleGenericNotify(CAMERA_MSG_ERROR, UNKNOWN_ERROR, 0); return; } switch (msgType &amp; ~CAMERA_MSG_PREVIEW_METADATA) { case CAMERA_MSG_PREVIEW_FRAME: client-&gt;handlePreviewData(msgType, dataPtr, metadata); break; case CAMERA_MSG_POSTVIEW_FRAME: client-&gt;handlePostview(dataPtr); break; case CAMERA_MSG_RAW_IMAGE: client-&gt;handleRawPicture(dataPtr); break; case CAMERA_MSG_COMPRESSED_IMAGE: client-&gt;handleCompressedPicture(dataPtr); break; default: client-&gt;handleGenericData(msgType, dataPtr, metadata); break; }}void CameraClient::dataCallbackTimestamp(nsecs_t timestamp, int32_t msgType, const sp&lt;IMemory&gt;&amp; dataPtr, void* user) { ......} 这里主要看下dataCallback的过程吧， 1234567891011121314151617switch (msgType &amp; ~CAMERA_MSG_PREVIEW_METADATA) { case CAMERA_MSG_PREVIEW_FRAME: //预览帧数据 client-&gt;handlePreviewData(msgType, dataPtr, metadata); break; case CAMERA_MSG_POSTVIEW_FRAME: //postview image client-&gt;handlePostview(dataPtr); break; case CAMERA_MSG_RAW_IMAGE: //原始数据 client-&gt;handleRawPicture(dataPtr); break; case CAMERA_MSG_COMPRESSED_IMAGE: //真实图片 client-&gt;handleCompressedPicture(dataPtr); break; default: client-&gt;handleGenericData(msgType, dataPtr, metadata); break;} 这里最后会调用到 c-&gt;dataCallback，然后根据消息类型来做处理，然后在通过binder机制 123456789101112131415// generic data callback from camera service to app with image datavoid dataCallback(int32_t msgType, const sp&lt;IMemory&gt;&amp; imageData, camera_frame_metadata_t *metadata){ ALOGV(\"dataCallback\"); Parcel data, reply; data.writeInterfaceToken(ICameraClient::getInterfaceDescriptor()); data.writeInt32(msgType); data.writeStrongBinder(imageData-&gt;asBinder()); if (metadata) { data.writeInt32(metadata-&gt;number_of_faces); data.write(metadata-&gt;faces, sizeof(camera_face_t) * metadata-&gt;number_of_faces); } remote()-&gt;transact(DATA_CALLBACK, data, &amp;reply, IBinder::FLAG_ONEWAY);} 1234567891011121314151617181920212223status_t BnCameraClient::onTransact( uint32_t code, const Parcel&amp; data, Parcel* reply, uint32_t flags){ switch(code) { ...... case DATA_CALLBACK: { ALOGV(\"DATA_CALLBACK\"); CHECK_INTERFACE(ICameraClient, data, reply); int32_t msgType = data.readInt32(); sp&lt;IMemory&gt; imageData = interface_cast&lt;IMemory&gt;(data.readStrongBinder()); camera_frame_metadata_t *metadata = NULL; if (data.dataAvail() &gt; 0) { metadata = new camera_frame_metadata_t; metadata-&gt;number_of_faces = data.readInt32(); metadata-&gt;faces = (camera_face_t *) data.readInplace( sizeof(camera_face_t) * metadata-&gt;number_of_faces); } dataCallback(msgType, imageData, metadata); if (metadata) delete metadata; return NO_ERROR; } break; ......} 这里转到Camera.cpp 12345678910111213// callback from camera service when frame or image is readyvoid Camera::dataCallback(int32_t msgType, const sp&lt;IMemory&gt;&amp; dataPtr, camera_frame_metadata_t *metadata){ sp&lt;CameraListener&gt; listener; { Mutex::Autolock _l(mLock); listener = mListener; } if (listener != NULL) { listener-&gt;postData(msgType, dataPtr, metadata); }} 通过listener的方式来往上层甩数据，那么问题来了，这个listener是什么时候设置的？ 回想一下第一篇FWK分析博客中的native_setup过程中有这么一段 123sp&lt;JNICameraContext&gt; context = new JNICameraContext(env, weak_this, clazz, camera);context-&gt;incStrong((void*)android_hardware_Camera_native_setup);camera-&gt;setListener(context); 就是在这里设置的listener,JNICameraContext继承CameraListener，复写父类的方法 123456789101112class JNICameraContext: public CameraListener{ ...... }class CameraListener: virtual public RefBase{public: virtual void notify(int32_t msgType, int32_t ext1, int32_t ext2) = 0; virtual void postData(int32_t msgType, const sp&lt;IMemory&gt;&amp; dataPtr, camera_frame_metadata_t *metadata) = 0; virtual void postDataTimestamp(nsecs_t timestamp, int32_t msgType, const sp&lt;IMemory&gt;&amp; dataPtr) = 0;}; 承接上面那一段，这里我们只看postData() android_hardware_Camera.cpp (frameworks\\base\\core\\jni) 1234567891011121314151617181920212223242526272829303132333435363738void JNICameraContext::postData(int32_t msgType, const sp&lt;IMemory&gt;&amp; dataPtr, camera_frame_metadata_t *metadata){ ...... int32_t dataMsgType = msgType &amp; ~CAMERA_MSG_PREVIEW_METADATA; // return data based on callback type switch (dataMsgType) { case CAMERA_MSG_VIDEO_FRAME: // should never happen break; // For backward-compatibility purpose, if there is no callback // buffer for raw image, the callback returns null. case CAMERA_MSG_RAW_IMAGE: ALOGV(\"rawCallback\"); if (mRawImageCallbackBuffers.isEmpty()) { env-&gt;CallStaticVoidMethod(mCameraJClass, fields.post_event, mCameraJObjectWeak, dataMsgType, 0, 0, NULL); } else { copyAndPost(env, dataPtr, dataMsgType); } break; // There is no data. case 0: break; default: ALOGV(\"dataCallback(%d, %p)\", dataMsgType, dataPtr.get()); copyAndPost(env, dataPtr, dataMsgType); break; } // post frame metadata to Java if (metadata &amp;&amp; (msgType &amp; CAMERA_MSG_PREVIEW_METADATA)) { postMetadata(env, CAMERA_MSG_PREVIEW_METADATA, metadata);//这里有人脸数据 }} 这里涉及到的 env-&gt;CallStaticVoidMethod(mCameraJClass, fields.post_event, mCameraJObjectWeak, dataMsgType, 0, 0, NULL); copyAndPost(env, dataPtr, dataMsgType); postMetadata(env, CAMERA_MSG_PREVIEW_METADATA, metadata); 直接或间接的使用到fileds.post_event函数，这里是JNI中的方法注册， fields.post_event = env-&gt;GetStaticMethodID(clazz, “postEventFromNative”, “(Ljava/lang/Object;IIILjava/lang/Object;)V”); 这个是在register_android_hardware_Camera()函数中调用的，这里不做过多停留，这个实际会调用到 Camera.java (frameworks\\base\\core\\java\\android\\hardware) 123456789101112private static void postEventFromNative(Object camera_ref, int what, int arg1, int arg2, Object obj){ Camera c = (Camera)((WeakReference)camera_ref).get(); if (c == null) return; if (c.mEventHandler != null) { Message m = c.mEventHandler.obtainMessage(what, arg1, arg2, obj); c.mEventHandler.sendMessage(m); }} 这里也是采用了JAVA中很常用的handler message处理 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596private class EventHandler extends Handler{ private final Camera mCamera; public EventHandler(Camera c, Looper looper) { super(looper); mCamera = c; } @Override public void handleMessage(Message msg) { switch(msg.what) { case CAMERA_MSG_SHUTTER: if (mShutterCallback != null) { mShutterCallback.onShutter(); } return; case CAMERA_MSG_RAW_IMAGE: if (mRawImageCallback != null) { mRawImageCallback.onPictureTaken((byte[])msg.obj, mCamera); } return; case CAMERA_MSG_COMPRESSED_IMAGE: if (mJpegCallback != null) { mJpegCallback.onPictureTaken((byte[])msg.obj, mCamera); } return; case CAMERA_MSG_PREVIEW_FRAME: PreviewCallback pCb = mPreviewCallback; if (pCb != null) { if (mOneShot) { // Clear the callback variable before the callback // in case the app calls setPreviewCallback from // the callback function mPreviewCallback = null; } else if (!mWithBuffer) { // We're faking the camera preview mode to prevent // the app from being flooded with preview frames. // Set to oneshot mode again. setHasPreviewCallback(true, false); } pCb.onPreviewFrame((byte[])msg.obj, mCamera); } return; case CAMERA_MSG_POSTVIEW_FRAME: if (mPostviewCallback != null) { mPostviewCallback.onPictureTaken((byte[])msg.obj, mCamera); } return; case CAMERA_MSG_FOCUS: AutoFocusCallback cb = null; synchronized (mAutoFocusCallbackLock) { cb = mAutoFocusCallback; } if (cb != null) { boolean success = msg.arg1 == 0 ? false : true; cb.onAutoFocus(success, mCamera); } return; case CAMERA_MSG_ZOOM: if (mZoomListener != null) { mZoomListener.onZoomChange(msg.arg1, msg.arg2 != 0, mCamera); } return; case CAMERA_MSG_PREVIEW_METADATA: if (mFaceListener != null) { mFaceListener.onFaceDetection((Face[])msg.obj, mCamera); } return; case CAMERA_MSG_ERROR : Log.e(TAG, \"Error \" + msg.arg1); if (mErrorCallback != null) { mErrorCallback.onError(msg.arg1, mCamera); } return; case CAMERA_MSG_FOCUS_MOVE: if (mAutoFocusMoveCallback != null) { mAutoFocusMoveCallback.onAutoFocusMoving(msg.arg1 == 0 ? false : true, mCamera); } return; default: Log.e(TAG, \"Unknown message type \" + msg.what); return; } }} 到这里基本上就是上层的处理了，callback都是在相机应用中设置的，然后各种数据就在相机应用中得到对应的处理。 具体的每一个数据怎么处理，这里我们不做分析，后续有需要，可以在细讲一下，旨在弄清楚代码是怎么走的。 本文中代码使用的是Android5.1原始代码，欢迎大家留言交流。","link":"/2015/08/30/《Android Framework 之路》Android5.1 Camera Framework（三）/"},{"title":"《Android Framework 之路》BootAnimation（2）","text":"前言 上一篇主要讲解了BootAnimation是从何而来，如何启动，从开机，到SurfaceFlinger服务起来，然后到执行开机动画，如果要深入的看里面的代码，是需要花一定的时间的，我们旨在了解大致的流程，具体流程中的函数，变量意义，具体实现，读者请自研。 由来已知，执行待述~ BootAnimation执行代码位置frameworks/base/cmds/bootanimation目录中包含如下文件 文件名 作用 Android.mk mk文件，编译模块使用 AudioPlayer.cpp、AudioPlayer.h 音频播放 BootAnimation.cpp、BootAnimation.h 开机动画的源文件和头文件 bootanimation_main.cpp 开机动画的入口 源码分析bootanimation_main.cpp文件中定义main函数，也就是C语言中的执行文件的入口函数 123456789101112131415161718192021222324252627int main(int argc, char** argv){//宏定义判断是否设置进程的优先级#if defined(HAVE_PTHREADS) setpriority(PRIO_PROCESS, 0, ANDROID_PRIORITY_DISPLAY);#endif char value[PROPERTY_VALUE_MAX]; //这个配置项决定是否存在开机动画 property_get(&quot;debug.sf.nobootanimation&quot;, value, &quot;0&quot;); int noBootAnimation = atoi(value); ALOGI_IF(noBootAnimation, &quot;boot animation disabled&quot;); if (!noBootAnimation) { //创建ProcessSate对象 // 这个过程会打开/dev/binder设备，形成和内核binder机制的交互的通道; 映射fd到内存 sp&lt;ProcessState&gt; proc(ProcessState::self()); //创建线程并加入到线程池 ProcessState::self()-&gt;startThreadPool(); // 创建开机动画对象 sp&lt;BootAnimation&gt; boot = new BootAnimation(); //把主线程加入到线程池 IPCThreadState::self()-&gt;joinThreadPool(); } return 0;} 创建开机动画对象会执行到BootAnimation的构造方法，先看下BootAnimation的头文件 BootAnimation.h 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384......namespace android {class AudioPlayer;class Surface;class SurfaceComposerClient;class SurfaceControl;// ---------------------------------------------------------------------------class BootAnimation : public Thread, public IBinder::DeathRecipient{public: BootAnimation(); virtual ~BootAnimation(); sp&lt;SurfaceComposerClient&gt; session() const;private: virtual bool threadLoop(); virtual status_t readyToRun(); virtual void onFirstRef(); virtual void binderDied(const wp&lt;IBinder&gt;&amp; who); //Texture类定义 struct Texture { GLint w; //宽度 GLint h; //高度 GLuint name; //名称 }; //动画内容结构体 struct Animation { //动画帧 struct Frame { String8 name; FileMap* map; mutable GLuint tid; bool operator &lt; (const Frame&amp; rhs) const { return name &lt; rhs.name; } }; //动画部分，因为动画可能是由几个部分组成 struct Part { int count; int pause; String8 path; SortedVector&lt;Frame&gt; frames; bool playUntilComplete; float backgroundColor[3]; FileMap* audioFile; }; int fps; int width; int height; Vector&lt;Part&gt; parts; }; status_t initTexture(Texture* texture, AssetManager&amp; asset, const char* name); status_t initTexture(const Animation::Frame&amp; frame); bool android(); bool readFile(const char* name, String8&amp; outString); bool movie(); void checkExit(); sp&lt;SurfaceComposerClient&gt; mSession; sp&lt;AudioPlayer&gt; mAudioPlayer; AssetManager mAssets; Texture mAndroid[2]; int mWidth; int mHeight; EGLDisplay mDisplay; EGLDisplay mContext; EGLDisplay mSurface; sp&lt;SurfaceControl&gt; mFlingerSurfaceControl; sp&lt;Surface&gt; mFlingerSurface; ZipFileRO *mZip;};// ---------------------------------------------------------------------------}; // namespace android#endif // ANDROID_BOOTANIMATION_H 大致的定义和声明就是这么多，看下具体实现 BootAnimation.cpp 首先执行构造方法 12345BootAnimation::BootAnimation() : Thread(false), mZip(NULL){ //用于界面显示的mSession，与SurfaceFlinger交互的客户端 mSession = new SurfaceComposerClient();} 然后执行 1234567void BootAnimation::onFirstRef() { status_t err = mSession-&gt;linkToComposerDeath(this); ALOGE_IF(err, &quot;linkToComposerDeath failed (%s) &quot;, strerror(-err)); if (err == NO_ERROR) { run(&quot;BootAnimation&quot;, PRIORITY_DISPLAY); }} 由于BootAnimation继承Thread类，首先会调用readyToRun函数 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576status_t BootAnimation::readyToRun() { mAssets.addDefaultAssets(); sp&lt;IBinder&gt; dtoken(SurfaceComposerClient::getBuiltInDisplay( ISurfaceComposer::eDisplayIdMain)); DisplayInfo dinfo; status_t status = SurfaceComposerClient::getDisplayInfo(dtoken, &amp;dinfo); if (status) return -1; // create the native surface sp&lt;SurfaceControl&gt; control = session()-&gt;createSurface(String8(&quot;BootAnimation&quot;), dinfo.w, dinfo.h, PIXEL_FORMAT_RGB_565); SurfaceComposerClient::openGlobalTransaction(); control-&gt;setLayer(0x40000000); SurfaceComposerClient::closeGlobalTransaction(); sp&lt;Surface&gt; s = control-&gt;getSurface(); // initialize opengl and egl const EGLint attribs[] = { EGL_RED_SIZE, 8, EGL_GREEN_SIZE, 8, EGL_BLUE_SIZE, 8, EGL_DEPTH_SIZE, 0, EGL_NONE }; EGLint w, h, dummy; EGLint numConfigs; EGLConfig config; EGLSurface surface; EGLContext context; EGLDisplay display = eglGetDisplay(EGL_DEFAULT_DISPLAY); eglInitialize(display, 0, 0); eglChooseConfig(display, attribs, &amp;config, 1, &amp;numConfigs); surface = eglCreateWindowSurface(display, config, s.get(), NULL); context = eglCreateContext(display, config, NULL, NULL); eglQuerySurface(display, surface, EGL_WIDTH, &amp;w); eglQuerySurface(display, surface, EGL_HEIGHT, &amp;h); if (eglMakeCurrent(display, surface, surface, context) == EGL_FALSE) return NO_INIT; mDisplay = display; mContext = context; mSurface = surface; mWidth = w; mHeight = h; mFlingerSurfaceControl = control; mFlingerSurface = s; // If the device has encryption turned on or is in process // of being encrypted we show the encrypted boot animation. char decrypt[PROPERTY_VALUE_MAX]; property_get(&quot;vold.decrypt&quot;, decrypt, &quot;&quot;); bool encryptedAnimation = atoi(decrypt) != 0 || !strcmp(&quot;trigger_restart_min_framework&quot;, decrypt); ZipFileRO* zipFile = NULL; if ((encryptedAnimation &amp;&amp; (access(SYSTEM_ENCRYPTED_BOOTANIMATION_FILE, R_OK) == 0) &amp;&amp; ((zipFile = ZipFileRO::open(SYSTEM_ENCRYPTED_BOOTANIMATION_FILE)) != NULL)) || ((access(OEM_BOOTANIMATION_FILE, R_OK) == 0) &amp;&amp; ((zipFile = ZipFileRO::open(OEM_BOOTANIMATION_FILE)) != NULL)) || ((access(SYSTEM_BOOTANIMATION_FILE, R_OK) == 0) &amp;&amp; ((zipFile = ZipFileRO::open(SYSTEM_BOOTANIMATION_FILE)) != NULL))) { mZip = zipFile; } return NO_ERROR;} 上面主要做两个操作： 初始化显示界面用于播放开机动画，egl的一些内容；根据手机是否加密选择不同的开机动画文件，然后拿到入口zipFile其中用到了一个文件路径在BootAnimation.cpp的开头有定义 12345#define OEM_BOOTANIMATION_FILE &quot;/oem/media/bootanimation.zip&quot; //这个应该是OEM厂商自己定制#define SYSTEM_BOOTANIMATION_FILE &quot;/system/media/bootanimation.zip&quot; //正常情况下的Android原始开机动画#define SYSTEM_ENCRYPTED_BOOTANIMATION_FILE &quot;/system/media/bootanimation-encrypted.zip&quot; //加密手机的开机动画 readyToRun方法执行完之后，接着看threaLoop函数 1234567891011121314151617181920bool BootAnimation::threadLoop(){ bool r; // We have no bootanimation file, so we use the stock android logo // animation. if (mZip == NULL) { r = android(); //没有开机动画文件，执行android logo } else { r = movie(); //存在开机动画文件，则执行对应的开机动画文件解析出来的内容 } eglMakeCurrent(mDisplay, EGL_NO_SURFACE, EGL_NO_SURFACE, EGL_NO_CONTEXT); eglDestroyContext(mDisplay, mContext); eglDestroySurface(mDisplay, mSurface); mFlingerSurface.clear(); mFlingerSurfaceControl.clear(); eglTerminate(mDisplay); IPCThreadState::self()-&gt;stopProcess(); return r;} ——————————————&gt;android() 1234567891011121314151617181920212223242526272829303132333435363738394041bool BootAnimation::android(){ //初始化两个纹理用于显示logo initTexture(&amp;mAndroid[0], mAssets, &quot;images/android-logo-mask.png&quot;); initTexture(&amp;mAndroid[1], mAssets, &quot;images/android-logo-shine.png&quot;); // clear screen 清屏 glShadeModel(GL_FLAT); glDisable(GL_DITHER); glDisable(GL_SCISSOR_TEST); glClearColor(0,0,0,1); glClear(GL_COLOR_BUFFER_BIT); eglSwapBuffers(mDisplay, mSurface); glEnable(GL_TEXTURE_2D); glTexEnvx(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_REPLACE); const GLint xc = (mWidth - mAndroid[0].w) / 2; const GLint yc = (mHeight - mAndroid[0].h) / 2; const Rect updateRect(xc, yc, xc + mAndroid[0].w, yc + mAndroid[0].h); glScissor(updateRect.left, mHeight - updateRect.bottom, updateRect.width(), updateRect.height()); // Blend state glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA); glTexEnvx(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_REPLACE); const nsecs_t startTime = systemTime(); //不停的显示知道exitPending()返回true do { ...... EGLBoolean res = eglSwapBuffers(mDisplay, mSurface); ...... checkExit(); } while (!exitPending()); glDeleteTextures(1, &amp;mAndroid[0].name); glDeleteTextures(1, &amp;mAndroid[1].name); return false;} 主要工作，初始化显示的logo纹理，不断刷新界面直到exitPending()返回true，exitPenging()是Thread类中定义的函数，在checkExit()函数中通过requestExit()来执行退出 12345678910111213void BootAnimation::checkExit() { // Allow surface flinger to gracefully request shutdown char value[PROPERTY_VALUE_MAX]; //EXIT_PROP_NAME &quot;service.bootanim.exit&quot; 这个配置项在SurfaceFlinger的bootFinished函数中设置为1，然后这里才能退出开机动画，这个过程设计到开机启动到launcher的整个过程，这里不赘述 property_get(EXIT_PROP_NAME, value, &quot;0&quot;); int exitnow = atoi(value); if (exitnow) { requestExit(); if (mAudioPlayer != NULL) { mAudioPlayer-&gt;requestExit(); } }} ——————————————&gt;movie() movie()这个函数有点长，我们截断一点一点的看 读取bootanimation.zip中的配置文件 123456789101112131415if (!readFile(&quot;desc.txt&quot;, desString)) { return false;}char const* s = desString.string();//读取desc.txt文件// Create and initialize an AudioPlayer if we have an audio_conf.txt fileString8 audioConf;//判断是否需要创建AudioPlayer,这部分我们暂时不关注if (readFile(&quot;audio_conf.txt&quot;, audioConf)) { mAudioPlayer = new AudioPlayer; if (!mAudioPlayer-&gt;init(audioConf.string())) { ALOGE(&quot;mAudioPlayer.init failed&quot;); mAudioPlayer = NULL; }} 解析desc.txt文件，就是上面拿到的那个char const *s 123456789101112131415161718192021222324252627282930313233343536373839for (;;) { //一行一行的截取 const char* endl = strstr(s, &quot;\\n&quot;); if (!endl) break; String8 line(s, endl - s); const char* l = line.string(); //几个需要捕获的参数,帧率 宽高，次数 int fps, width, height, count, pause; char path[ANIM_ENTRY_NAME_MAX]; char color[7] = &quot;000000&quot;; // default to black if unspecified char pathType; //读取帧率和宽高 if (sscanf(l, &quot;%d %d %d&quot;, &amp;width, &amp;height, &amp;fps) == 3) { // ALOGD(&quot;&gt; w=%d, h=%d, fps=%d&quot;, width, height, fps); animation.width = width; animation.height = height; animation.fps = fps; } //或者读取part内容 else if (sscanf(l, &quot; %c %d %d %s #%6s&quot;, &amp;pathType, &amp;count, &amp;pause, path, color) &gt;= 4) { // ALOGD(&quot;&gt; type=%c, count=%d, pause=%d, path=%s, color=%s&quot;, pathType, count, pause, path, color); Animation::Part part; part.playUntilComplete = pathType == &apos;c&apos;; part.count = count; part.pause = pause; part.path = path; part.audioFile = NULL; if (!parseColor(color, part.backgroundColor)) { ALOGE(&quot;&gt; invalid color &apos;#%s&apos;&quot;, color); part.backgroundColor[0] = 0.0f; part.backgroundColor[1] = 0.0f; part.backgroundColor[2] = 0.0f; } animation.parts.add(part); } s = ++endl; } 读取所有的数据 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647// read all the data structuresconst size_t pcount = animation.parts.size();void *cookie = NULL;if (!mZip-&gt;startIteration(&amp;cookie)) { return false;}ZipEntryRO entry;char name[ANIM_ENTRY_NAME_MAX];while ((entry = mZip-&gt;nextEntry(cookie)) != NULL) { const int foundEntryName = mZip-&gt;getEntryFileName(entry, name, ANIM_ENTRY_NAME_MAX); if (foundEntryName &gt; ANIM_ENTRY_NAME_MAX || foundEntryName == -1) { ALOGE(&quot;Error fetching entry file name&quot;); continue; } const String8 entryName(name); const String8 path(entryName.getPathDir()); const String8 leaf(entryName.getPathLeaf()); if (leaf.size() &gt; 0) { for (size_t j=0 ; j&lt;pcount ; j++) { if (path == animation.parts[j].path) { int method; // supports only stored png files if (mZip-&gt;getEntryInfo(entry, &amp;method, NULL, NULL, NULL, NULL, NULL)) { if (method == ZipFileRO::kCompressStored) { FileMap* map = mZip-&gt;createEntryFileMap(entry); if (map) { Animation::Part&amp; part(animation.parts.editItemAt(j)); if (leaf == &quot;audio.wav&quot;) { // a part may have at most one audio file part.audioFile = map; } else { Animation::Frame frame; frame.name = leaf; frame.map = map; part.frames.add(frame); } } } } } } }}mZip-&gt;endIteration(cookie); 显示动画 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111// clear screenglShadeModel(GL_FLAT);glDisable(GL_DITHER);glDisable(GL_SCISSOR_TEST);glDisable(GL_BLEND);glClearColor(0,0,0,1);glClear(GL_COLOR_BUFFER_BIT);eglSwapBuffers(mDisplay, mSurface);glBindTexture(GL_TEXTURE_2D, 0);glEnable(GL_TEXTURE_2D);glTexEnvx(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_REPLACE);glTexParameterx(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);glTexParameterx(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT);glTexParameterx(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);glTexParameterx(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);const int xc = (mWidth - animation.width) / 2;const int yc = ((mHeight - animation.height) / 2);nsecs_t lastFrame = systemTime();nsecs_t frameDuration = s2ns(1) / animation.fps;Region clearReg(Rect(mWidth, mHeight));clearReg.subtractSelf(Rect(xc, yc, xc+animation.width, yc+animation.height));for (size_t i=0 ; i&lt;pcount ; i++) { const Animation::Part&amp; part(animation.parts[i]); const size_t fcount = part.frames.size(); glBindTexture(GL_TEXTURE_2D, 0); for (int r=0 ; !part.count || r&lt;part.count ; r++) { // Exit any non playuntil complete parts immediately if(exitPending() &amp;&amp; !part.playUntilComplete) break; // only play audio file the first time we animate the part if (r == 0 &amp;&amp; mAudioPlayer != NULL &amp;&amp; part.audioFile) { mAudioPlayer-&gt;playFile(part.audioFile); } glClearColor( part.backgroundColor[0], part.backgroundColor[1], part.backgroundColor[2], 1.0f); for (size_t j=0 ; j&lt;fcount &amp;&amp; (!exitPending() || part.playUntilComplete) ; j++) { const Animation::Frame&amp; frame(part.frames[j]); nsecs_t lastFrame = systemTime(); if (r &gt; 0) { glBindTexture(GL_TEXTURE_2D, frame.tid); } else { if (part.count != 1) { glGenTextures(1, &amp;frame.tid); glBindTexture(GL_TEXTURE_2D, frame.tid); glTexParameterx(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR); glTexParameterx(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR); } initTexture(frame); } if (!clearReg.isEmpty()) { Region::const_iterator head(clearReg.begin()); Region::const_iterator tail(clearReg.end()); glEnable(GL_SCISSOR_TEST); while (head != tail) { const Rect&amp; r(*head++); glScissor(r.left, mHeight - r.bottom, r.width(), r.height()); glClear(GL_COLOR_BUFFER_BIT); } glDisable(GL_SCISSOR_TEST); } glDrawTexiOES(xc, yc, 0, animation.width, animation.height); eglSwapBuffers(mDisplay, mSurface); nsecs_t now = systemTime(); nsecs_t delay = frameDuration - (now - lastFrame); //ALOGD(&quot;%lld, %lld&quot;, ns2ms(now - lastFrame), ns2ms(delay)); lastFrame = now; if (delay &gt; 0) { struct timespec spec; spec.tv_sec = (now + delay) / 1000000000; spec.tv_nsec = (now + delay) % 1000000000; int err; do { err = clock_nanosleep(CLOCK_MONOTONIC, TIMER_ABSTIME, &amp;spec, NULL); } while (err&lt;0 &amp;&amp; errno == EINTR); } checkExit(); } usleep(part.pause * ns2us(frameDuration)); // For infinite parts, we&apos;ve now played them at least once, so perhaps exit if(exitPending() &amp;&amp; !part.count) break; } // free the textures for this part if (part.count != 1) { for (size_t j=0 ; j&lt;fcount ; j++) { const Animation::Frame&amp; frame(part.frames[j]); glDeleteTextures(1, &amp;frame.tid); } }} 备注 主要工作，贴代码，加自己的理解，有问题留言。","link":"/2016/08/10/《Android Framework 之路》BootAnimation（2）/"},{"title":"《Android 基础（二十）》 CoordinatorLayout Behavior","text":"介绍 Interaction behavior plugin for child views of {@link CoordinatorLayout}.A Behavior implements one or more interactions that a user can take on a child view. These interactions may include drags, swipes, flings, or any other gestures. @param &lt; V &gt; The View type that this Behavior operates on &gt; &gt;交互行为主要用于CoordinatorLayout的子View。一个Behavior可以在一个字View上实现一个或者多个交互内容。这些交互可能包括拖拽，滑动，滚动或者是其他手势。 &gt;参数V代表这个Behavior可以操作的视图类型 ###类结构 基本使用 关注两个方面： 1、实现child view 监听另外一个child view的状态变化，例如大小、位置、显示状态等 关注layoutDependsOn和onDependentViewChanged方法。 2、实现child view监听CoordinatorLayout内NestedScrollingChild的接口实现类的滑动状态 关注onStartNestedScroll和onNestedPreScroll方法。如上一篇博文中提到的NestedScrollView，而不能使用普通的ScrollView 第一种情况，监听View的状态位置跟随 布局文件123456789101112131415161718192021222324252627282930&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;android.support.design.widget.CoordinatorLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:app=\"http://schemas.android.com/apk/res-auto\" xmlns:tools=\"http://schemas.android.com/tools\" android:id=\"@+id/main_layout\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:fitsSystemWindows=\"true\" tools:context=\"mraz.com.coordinatorlayoutdemo.ScrollingActivity\"&gt; &lt;TextView android:id=\"@+id/depentent\" android:layout_width=\"100dp\" android:layout_height=\"100dp\" android:layout_gravity=\"top|left\" android:background=\"#73ff00\" android:gravity=\"center\" android:text=\"depentent\" android:textColor=\"@android:color/black\" /&gt; &lt;TextView android:layout_width=\"100dp\" android:layout_height=\"100dp\" android:layout_gravity=\"top|right\" android:background=\"#ffee00\" android:gravity=\"center\" android:text=\"auto\" android:textColor=\"@android:color/holo_red_dark\" app:layout_behavior=\"mraz.com.coordinatorlayoutdemo.FollowingBehavior\" /&gt;&lt;/android.support.design.widget.CoordinatorLayout&gt; Behavior12345678910111213141516171819202122232425262728package mraz.com.coordinatorlayoutdemo;import android.content.Context;import android.support.design.widget.CoordinatorLayout;import android.support.v4.view.ViewCompat;import android.util.AttributeSet;import android.view.View;/** * Created by Mraz on 2016/8/15. */public class FollowingBehavior extends CoordinatorLayout.Behavior&lt;View&gt; { public FollowingBehavior(Context context, AttributeSet attrs) { super(context, attrs); } @Override public boolean layoutDependsOn(CoordinatorLayout parent, View child, View dependency) { return (dependency.getId() == R.id.depentent);//依赖左边的View } @Override public boolean onDependentViewChanged(CoordinatorLayout parent, View child, View dependency) { int offsetX = dependency.getTop() - child.getTop();//拿到左边View和右边view的顶部差距 ViewCompat.offsetTopAndBottom(child, offsetX);//移动 return true; }} 效果 第二种情况，监听滚动状态CoordinatorLayout实现NestedScrollingParent接口， NestedScrollView实现NestedScrollingParent， NestedScrollingChild, ScrollingView接口 12public class NestedScrollView extends FrameLayout implements NestedScrollingParent, NestedScrollingChild, ScrollingView 简而言之，一个加强的ScrollView，但是实现的这几个接口是怎么回事呢？一个个的看下NestedScrollingParent 接口 含义 onStartNestedScroll child执行startNestedScroll方法的时候会调用，返回true代表代表要和child联动 onNestedScrollAccepted onStartNestedScroll执行完成并返回true之后执行，用于做联动前的准备 onStopNestedScroll nested scroll结束后执行 onNestedScroll nested scroll进行中时执行，传递的参数是消耗了和没有消耗的滚动距离 onNestedPreScroll neseted scroll进行并且target没有消耗滚动时执行，nested scrolling执行dispatchNestedPreScroll后执行该方法 onNestedFling 请求一个滚动结束后的fling onNestedPreFling target view没有消耗flinger之前执行 getNestedScrollAxes 返回NestedScrollingParent的滚动轴 NestedScrollingChild 接口 含义 setNestedScrollingEnabled 设置视图是否可以nested scrolling isNestedScrollingEnabled 获取当前view是否可以nested scrolling startNestedScroll 开始执行nested scroll,沿着给点的轴方向，返回true,代表找到了parent hasNestedScrollingParent 判断nested scrolling是否存在parent dispatchNestedScroll 派发一个滚动给parent dispatchNestedPreScroll 在没有消耗之前派发给parent，也就是parent有可能会在child之前消耗 dispatchNestedPreFling 消耗之前派发给parent ScrollingView 接口 含义 computeHorizontalScrollRange 计算横向滚动的范围 computeHorizontalScrollOffset 计算横向偏移量 computeHorizontalScrollExtent 计算横向额外距离 computeVerticalScrollRange 滚动视图的可滚动范围是所有子元素的高度 computeVerticalScrollOffset 计算垂直方向滚动条的滑块的偏移。此值用来计算滚动条轨迹的滑块的位置 computeVerticalScrollExtent 计算纵向额外距离 基本上方法和上面的比较类似，不赘述 布局文件123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;android.support.design.widget.CoordinatorLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:app=\"http://schemas.android.com/apk/res-auto\" xmlns:tools=\"http://schemas.android.com/tools\" android:id=\"@+id/main_layout\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:fitsSystemWindows=\"true\" android:scrollbars=\"vertical\" tools:context=\"mraz.com.coordinatorlayoutdemo.ScrollingActivity\"&gt; &lt;android.support.v4.widget.NestedScrollView android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\"&gt; &lt;LinearLayout android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:orientation=\"vertical\"&gt; &lt;TextView android:layout_width=\"100dp\" android:layout_height=\"200dp\" android:layout_gravity=\"top|left\" android:background=\"#73ff00\" android:gravity=\"center\" android:text=\"depentent\" android:textColor=\"@android:color/black\" /&gt; &lt;TextView android:layout_width=\"100dp\" android:layout_height=\"200dp\" android:layout_gravity=\"top|left\" android:background=\"#73ff00\" android:gravity=\"center\" android:text=\"depentent\" android:textColor=\"@android:color/black\" /&gt; &lt;TextView android:layout_width=\"100dp\" android:layout_height=\"200dp\" android:layout_gravity=\"top|left\" android:background=\"#73ff00\" android:gravity=\"center\" android:text=\"depentent\" android:textColor=\"@android:color/black\" /&gt; &lt;TextView android:layout_width=\"100dp\" android:layout_height=\"200dp\" android:layout_gravity=\"top|left\" android:background=\"#73ff00\" android:gravity=\"center\" android:text=\"depentent\" android:textColor=\"@android:color/black\" /&gt; &lt;TextView android:layout_width=\"100dp\" android:layout_height=\"200dp\" android:layout_gravity=\"top|left\" android:background=\"#73ff00\" android:gravity=\"center\" android:text=\"depentent\" android:textColor=\"@android:color/black\" /&gt; &lt;TextView android:layout_width=\"100dp\" android:layout_height=\"200dp\" android:layout_gravity=\"top|left\" android:background=\"#73ff00\" android:gravity=\"center\" android:text=\"depentent\" android:textColor=\"@android:color/black\" /&gt; &lt;TextView android:layout_width=\"100dp\" android:layout_height=\"200dp\" android:layout_gravity=\"top|left\" android:background=\"#73ff00\" android:gravity=\"center\" android:text=\"depentent\" android:textColor=\"@android:color/black\" /&gt; &lt;TextView android:layout_width=\"100dp\" android:layout_height=\"200dp\" android:layout_gravity=\"top|left\" android:background=\"#73ff00\" android:gravity=\"center\" android:text=\"depentent\" android:textColor=\"@android:color/black\" /&gt; &lt;TextView android:layout_width=\"100dp\" android:layout_height=\"200dp\" android:layout_gravity=\"top|left\" android:background=\"#73ff00\" android:gravity=\"center\" android:text=\"depentent\" android:textColor=\"@android:color/black\" /&gt; &lt;/LinearLayout&gt; &lt;/android.support.v4.widget.NestedScrollView&gt; &lt;android.support.v4.widget.NestedScrollView android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:layout_gravity=\"center\" app:layout_behavior=\"mraz.com.coordinatorlayoutdemo.MyScrollingBehavior\"&gt; &lt;LinearLayout android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:orientation=\"vertical\"&gt; &lt;TextView android:layout_width=\"100dp\" android:layout_height=\"200dp\" android:layout_gravity=\"top|left\" android:background=\"#ff00aa\" android:gravity=\"center\" android:text=\"right\" android:textColor=\"@android:color/black\" /&gt; &lt;TextView android:layout_width=\"100dp\" android:layout_height=\"200dp\" android:layout_gravity=\"top|left\" android:background=\"#ff00aa\" android:gravity=\"center\" android:text=\"right\" android:textColor=\"@android:color/black\" /&gt; &lt;TextView android:layout_width=\"100dp\" android:layout_height=\"200dp\" android:layout_gravity=\"top|left\" android:background=\"#ff00aa\" android:gravity=\"center\" android:text=\"right\" android:textColor=\"@android:color/black\" /&gt; &lt;TextView android:layout_width=\"100dp\" android:layout_height=\"200dp\" android:layout_gravity=\"top|left\" android:background=\"#ff00aa\" android:gravity=\"center\" android:text=\"right\" android:textColor=\"@android:color/black\" /&gt; &lt;TextView android:layout_width=\"100dp\" android:layout_height=\"200dp\" android:layout_gravity=\"top|left\" android:background=\"#ff00aa\" android:gravity=\"center\" android:text=\"right\" android:textColor=\"@android:color/black\" /&gt; &lt;TextView android:layout_width=\"100dp\" android:layout_height=\"200dp\" android:layout_gravity=\"top|left\" android:background=\"#ff00aa\" android:gravity=\"center\" android:text=\"right\" android:textColor=\"@android:color/black\" /&gt; &lt;TextView android:layout_width=\"100dp\" android:layout_height=\"200dp\" android:layout_gravity=\"top|left\" android:background=\"#ff00aa\" android:gravity=\"center\" android:text=\"right\" android:textColor=\"@android:color/black\" /&gt; &lt;TextView android:layout_width=\"100dp\" android:layout_height=\"200dp\" android:layout_gravity=\"top|left\" android:background=\"#ff00aa\" android:gravity=\"center\" android:text=\"right\" android:textColor=\"@android:color/black\" /&gt; &lt;TextView android:layout_width=\"100dp\" android:layout_height=\"200dp\" android:layout_gravity=\"top|left\" android:background=\"#ff00aa\" android:gravity=\"center\" android:text=\"right\" android:textColor=\"@android:color/black\" /&gt; &lt;/LinearLayout&gt; &lt;/android.support.v4.widget.NestedScrollView&gt; &lt;android.support.v4.widget.NestedScrollView android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:layout_gravity=\"right\" app:layout_behavior=\"mraz.com.coordinatorlayoutdemo.MyScrollingBehavior\"&gt; &lt;LinearLayout android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:orientation=\"vertical\"&gt; &lt;TextView android:layout_width=\"100dp\" android:layout_height=\"200dp\" android:layout_gravity=\"top|left\" android:background=\"#ffe600\" android:gravity=\"center\" android:text=\"right\" android:textColor=\"@android:color/black\" /&gt; &lt;TextView android:layout_width=\"100dp\" android:layout_height=\"200dp\" android:layout_gravity=\"top|left\" android:background=\"#ffe600\" android:gravity=\"center\" android:text=\"right\" android:textColor=\"@android:color/black\" /&gt; &lt;TextView android:layout_width=\"100dp\" android:layout_height=\"200dp\" android:layout_gravity=\"top|left\" android:background=\"#ffe600\" android:gravity=\"center\" android:text=\"right\" android:textColor=\"@android:color/black\" /&gt; &lt;TextView android:layout_width=\"100dp\" android:layout_height=\"200dp\" android:layout_gravity=\"top|left\" android:background=\"#ffe600\" android:gravity=\"center\" android:text=\"right\" android:textColor=\"@android:color/black\" /&gt; &lt;TextView android:layout_width=\"100dp\" android:layout_height=\"200dp\" android:layout_gravity=\"top|left\" android:background=\"#ffe600\" android:gravity=\"center\" android:text=\"right\" android:textColor=\"@android:color/black\" /&gt; &lt;TextView android:layout_width=\"100dp\" android:layout_height=\"200dp\" android:layout_gravity=\"top|left\" android:background=\"#ffe600\" android:gravity=\"center\" android:text=\"right\" android:textColor=\"@android:color/black\" /&gt; &lt;TextView android:layout_width=\"100dp\" android:layout_height=\"200dp\" android:layout_gravity=\"top|left\" android:background=\"#ffe600\" android:gravity=\"center\" android:text=\"right\" android:textColor=\"@android:color/black\" /&gt; &lt;TextView android:layout_width=\"100dp\" android:layout_height=\"200dp\" android:layout_gravity=\"top|left\" android:background=\"#ffe600\" android:gravity=\"center\" android:text=\"right\" android:textColor=\"@android:color/black\" /&gt; &lt;TextView android:layout_width=\"100dp\" android:layout_height=\"200dp\" android:layout_gravity=\"top|left\" android:background=\"#ffe600\" android:gravity=\"center\" android:text=\"right\" android:textColor=\"@android:color/black\" /&gt; &lt;/LinearLayout&gt; &lt;/android.support.v4.widget.NestedScrollView&gt;&lt;/android.support.design.widget.CoordinatorLayout&gt; Behavior1234567891011121314151617181920212223242526272829303132package mraz.com.coordinatorlayoutdemo;import android.content.Context;import android.support.design.widget.CoordinatorLayout;import android.support.v4.view.ViewCompat;import android.support.v4.widget.NestedScrollView;import android.util.AttributeSet;import android.view.View;public class MyScrollingBehavior extends CoordinatorLayout.Behavior { public MyScrollingBehavior(Context context, AttributeSet attrs) { super(context, attrs); } @Override public boolean onStartNestedScroll(CoordinatorLayout coordinatorLayout, View child, View directTargetChild, View target, int nestedScrollAxes) { return (nestedScrollAxes &amp; ViewCompat.SCROLL_AXIS_VERTICAL) != 0;//只对垂直滚动感兴趣 } @Override public void onNestedPreScroll(CoordinatorLayout coordinatorLayout, View child, View target, int dx, int dy, int[] consumed) { super.onNestedPreScroll(coordinatorLayout, child, target, dx, dy, consumed); int leftScrolled = target.getScrollY();//获取左侧滚动距离 child.setScrollY(leftScrolled);//设置联动 } @Override public boolean onNestedPreFling(CoordinatorLayout coordinatorLayout, View child, View target, float velocityX, float velocityY) { ((NestedScrollView) child).fling((int) velocityY);//松手后速度传递下去 return true; }} 效果","link":"/2016/08/23/《Android 基础（二十）》 CoordinatorLayout Behavior/"},{"title":"《Android 基础（四十)》 FlexboxLayout","text":"1. 简介 Flexbox-layout，是Google推出的流式布局。具体的基本介绍可以参考Github上的Wiki。看一下类的英文说明： `/** A layout that arranges its children in a way its attributes can be specified like the CSS Flexible Box Layout Module. This class extends the {@link ViewGroup} like other layout classes such as {@link LinearLayout} or {@link RelativeLayout}, the attributes can be specified from a layout XML or from code. The supported attributes that you can use are: {@code flexDirection} {@code flexWrap} {@code justifyContent} {@code alignItems} {@code alignContent} {@code showDivider} {@code showDividerHorizontal} {@code showDividerVertical} {@code dividerDrawable} {@code dividerDrawableHorizontal} {@code dividerDrawableVertical} for the FlexboxLayout. And for the children of the FlexboxLayout, you can use: {@code layout_order} {@code layout_flexGrow} {@code layout_flexShrink} {@code layout_flexBasisPercent} {@code layout_alignSelf} {@code layout_minWidth} {@code layout_minHeight} {@code layout_maxWidth} {@code layout_maxHeight} {@code layout_wrapBefore} /` 应该很容易看懂，主要是提供类似于CSS中Flexible Box Layout的能力。 2. 属性值 针对FlexboxLayout 属性 ------------------------- flexDirection flexWrap justifyContent alignItems alignContent showDivider showDividerHorizontal showDividerVertical dividerDrawable dividerDrawableHorizontal dividerDrawableVertical 针对FlexboxLayout中的子元素 属性 ----------------------- layout_order layout_flexGrow layout_flexShrink layout_flexBasisPercent layout_alignSelf layout_minWidth layout_minHeight layout_maxWidth layout_maxHeight layout_wrapBefore 3. FlexboxLayout属性自测3.1 flexDirection flexDirection属性支持row , row_reverse , column , column_reverse 四个取值。分别代表左右，右左，上下，下上。 flexDIrection | 效果图 -------------- | --- row | row_reverse | column | column_reverse | 3.2 flexWrap flexWrap, 表示换行与否，支持wrap , nowrap , wrap_reverse。默认为noWrap，表示不换行，wrap表示自动换行，还有一个wrap_reverse 表示副轴反转。 以flexDirection为row时为例 flexWrap | ------------ | wrap | nowrap | wrap_reverse | 3.3 justifyContent justifyContent，表示控件沿主轴对齐方向。支持flex_start , flex_end , center , space_between , space_around五种取值。 下面以flexDirection为row , flexWrap为wrap为例，注意比较效果之间的差异，就可以很直观的了解到每个属性值的作用。 justifyContent | 效果图 -------------- | --- flex_start | flex_end | center | space_between | space_around | 3.4 alignItems alignItems , 描述元素在副轴上的对齐方向（针对单行) , 支持flex_start , flex_end , center , baseline , stretch五种取值。 以flexDirection为row , flexWrap为nowrap为例，注意比较不同属性之间的效果差异。由于上面示例中我们针对flexboxlayout的高度使用的时wrap_content , 下面这个示例中我们给flexboxlayout一个合适的固定高度活着改成match_parent更容易看出效果 alignItems | 效果图 ---------- | --- flex_start | flex_end | center | baseline | stretch | 3.5 alignContent alignContent , 表示控件在副轴上的对齐方向（针对多行元素）。支持flex_start , flex_end , center , space_between , space_around , stretch六种取值 flexboxlayout改成match_parent , 以flexDirection为row , flexWrap为wrap为例， 看看效果 alignContent | 效果图 ------------- | --- flex_start | flex_end | center | space_between | space_around | stretch | 3.6 showDivider and dividerDrawable showDivider , 显示分割线。支持none , beginning , middle , end 四种取值 绘制一条分割线，然后flexDirection为row , flexWrap为wrap，dividerDrawable为@drawable/divider为例，看看效果 12345&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;shape xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt; &lt;solid android:color=&quot;@color/colorAccent&quot;&gt;&lt;/solid&gt; &lt;size android:width=&quot;2dp&quot;/&gt;&lt;/shape&gt; showDivider | 效果图 ----------- | --- none | beginning | middle | end | 3.7 showDividerHorizontal and dividerDrawableHorizontal 横向分割线，支持none , beginning , middle , end 四种取值，四种取值和上面的使用差不多，我们只举一个例子 分割线 12345&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;shape xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt; &lt;solid android:color=&quot;@color/colorAccent&quot;&gt;&lt;/solid&gt; &lt;size android:height=&quot;2dp&quot;/&gt;&lt;/shape&gt; 布局文件 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;RelativeLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot;&gt; &lt;com.google.android.flexbox.FlexboxLayout android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:background=&quot;#EBEBEB&quot; app:flexDirection=&quot;column&quot; app:showDividerHorizontal=&quot;middle&quot; app:dividerDrawableHorizontal=&quot;@drawable/divider&quot; app:flexWrap=&quot;wrap&quot;&gt; &lt;TextView android:paddingLeft=&quot;10dp&quot; android:paddingRight=&quot;10dp&quot; android:paddingTop=&quot;4dp&quot; android:paddingBottom=&quot;4dp&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:layout_margin=&quot;4dp&quot; android:background=&quot;@drawable/item_bg&quot; android:text=&quot;Android&quot; /&gt; &lt;TextView android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:layout_margin=&quot;4dp&quot; android:background=&quot;@drawable/item_bg&quot; android:paddingLeft=&quot;10dp&quot; android:paddingRight=&quot;10dp&quot; android:paddingTop=&quot;4dp&quot; android:paddingBottom=&quot;4dp&quot; android:text=&quot;android studio&quot; /&gt; &lt;TextView android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:layout_margin=&quot;4dp&quot; android:background=&quot;@drawable/item_bg&quot; android:paddingLeft=&quot;10dp&quot; android:paddingRight=&quot;10dp&quot; android:paddingTop=&quot;4dp&quot; android:paddingBottom=&quot;4dp&quot; android:text=&quot;Android安全&quot; /&gt; &lt;TextView android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:layout_margin=&quot;4dp&quot; android:background=&quot;@drawable/item_bg&quot; android:paddingLeft=&quot;10dp&quot; android:paddingRight=&quot;10dp&quot; android:paddingTop=&quot;4dp&quot; android:paddingBottom=&quot;4dp&quot; android:text=&quot;Android框架&quot; /&gt; &lt;/com.google.android.flexbox.FlexboxLayout&gt;&lt;/RelativeLayout&gt; 3.8 showDividerVertical and dividerDrawableVertical 和上面的用法相似，看下效果把 分割线 12345&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;shape xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt; &lt;solid android:color=&quot;@color/colorAccent&quot;&gt;&lt;/solid&gt; &lt;size android:width=&quot;2dp&quot;/&gt;&lt;/shape&gt; 4. FlexboxLayout子元素属性自测4.1 layout_order 默认情况 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;RelativeLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot;&gt; &lt;com.google.android.flexbox.FlexboxLayout android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:background=&quot;#EBEBEB&quot; app:flexDirection=&quot;row&quot; app:flexWrap=&quot;wrap&quot;&gt; &lt;TextView android:paddingLeft=&quot;10dp&quot; android:paddingRight=&quot;10dp&quot; android:paddingTop=&quot;4dp&quot; android:paddingBottom=&quot;4dp&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:layout_margin=&quot;4dp&quot; android:background=&quot;@drawable/item_bg&quot; android:gravity=&quot;center&quot; android:text=&quot;Android&quot; /&gt; &lt;TextView android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:layout_margin=&quot;4dp&quot; android:background=&quot;@drawable/item_bg&quot; android:paddingLeft=&quot;10dp&quot; android:paddingRight=&quot;10dp&quot; android:paddingTop=&quot;4dp&quot; android:paddingBottom=&quot;4dp&quot; android:text=&quot;android studio&quot; /&gt; &lt;TextView android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:layout_margin=&quot;4dp&quot; android:background=&quot;@drawable/item_bg&quot; android:paddingLeft=&quot;10dp&quot; android:paddingRight=&quot;10dp&quot; android:paddingTop=&quot;4dp&quot; android:paddingBottom=&quot;4dp&quot; android:text=&quot;Android安全&quot; /&gt; &lt;/com.google.android.flexbox.FlexboxLayout&gt;&lt;/RelativeLayout&gt; 顺序排一下 2，3，1 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;RelativeLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot;&gt; &lt;com.google.android.flexbox.FlexboxLayout android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:background=&quot;#EBEBEB&quot; app:flexDirection=&quot;row&quot; app:flexWrap=&quot;wrap&quot;&gt; &lt;TextView android:paddingLeft=&quot;10dp&quot; android:paddingRight=&quot;10dp&quot; android:paddingTop=&quot;4dp&quot; android:paddingBottom=&quot;4dp&quot; app:layout_order=&quot;2&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:layout_margin=&quot;4dp&quot; android:background=&quot;@drawable/item_bg&quot; android:gravity=&quot;center&quot; android:text=&quot;Android&quot; /&gt; &lt;TextView android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:layout_margin=&quot;4dp&quot; app:layout_order=&quot;3&quot; android:background=&quot;@drawable/item_bg&quot; android:paddingLeft=&quot;10dp&quot; android:paddingRight=&quot;10dp&quot; android:paddingTop=&quot;4dp&quot; android:paddingBottom=&quot;4dp&quot; android:text=&quot;android studio&quot; /&gt; &lt;TextView android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:layout_margin=&quot;4dp&quot; android:background=&quot;@drawable/item_bg&quot; android:paddingLeft=&quot;10dp&quot; android:paddingRight=&quot;10dp&quot; app:layout_order=&quot;1&quot; android:paddingTop=&quot;4dp&quot; android:paddingBottom=&quot;4dp&quot; android:text=&quot;Android安全&quot; /&gt; &lt;/com.google.android.flexbox.FlexboxLayout&gt;&lt;/RelativeLayout&gt; 4.2 layout_flexGrow layout_flexGrow ,子元素的放大比例， 决定如何分配剩余空间（如果存在剩余空间的话），默认值为0,不会分配剩余空间，如果某一行中有一个item的 layout_flexGrow 是一个正值，那么会将这行全部剩余空间分配给这个Item , 如果这一行有多个Item这个属性都为正值，那么剩余空间的按照layout_flexGrow定义的比例（有点像LinearLayout的layout_weight属性）进行分配 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;RelativeLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot;&gt; &lt;com.google.android.flexbox.FlexboxLayout android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:background=&quot;#EBEBEB&quot; app:flexDirection=&quot;row&quot; app:flexWrap=&quot;wrap&quot;&gt; &lt;TextView android:paddingLeft=&quot;10dp&quot; android:paddingRight=&quot;10dp&quot; android:paddingTop=&quot;4dp&quot; android:paddingBottom=&quot;4dp&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:layout_margin=&quot;4dp&quot; android:background=&quot;@drawable/item_bg&quot; app:layout_flexGrow=&quot;10.0&quot; android:text=&quot;Android&quot; /&gt; &lt;TextView android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:layout_margin=&quot;4dp&quot; android:background=&quot;@drawable/item_bg&quot; android:paddingLeft=&quot;10dp&quot; android:paddingRight=&quot;10dp&quot; android:paddingTop=&quot;4dp&quot; android:paddingBottom=&quot;4dp&quot; android:text=&quot;android studio&quot; /&gt; &lt;TextView android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:layout_margin=&quot;4dp&quot; android:background=&quot;@drawable/item_bg&quot; android:paddingLeft=&quot;10dp&quot; android:paddingRight=&quot;10dp&quot; android:paddingTop=&quot;4dp&quot; android:paddingBottom=&quot;4dp&quot; app:layout_flexGrow=&quot;10.0&quot; android:text=&quot;Android安全&quot; /&gt; &lt;/com.google.android.flexbox.FlexboxLayout&gt;&lt;/RelativeLayout&gt; 可以看到黄色框内的两个元素（也就是第一个子元素和第三个子元素）按照1：1 的比例分配了这一行中剩余的空间。 4.3 layout_flexShrink layout_flexShrink , 子元素缩小比例 , 与上面的属性值有点对应关系，当空间不足时，子元素需要缩小（针对单行），默认值为1，如果所有子元素的layout_flexShrink 值为1,空间不足时，都等比缩小，如果有一个为0，其他为1，空间不足时，为0的不缩小，负值无效。 这里引用Github上的一个图，看看效果 4.4 layout_alignSelf layout_alignSelf 属性可以给子元素设置对齐方式，上面讲的alignItems属性可以设置对齐，这个属性的功能和alignItems一样，只不过alignItems作用于所有子元素，而layout_alignSelf 作用于单个子元素。默认值为auto, 表示继承alignItems属性，如果为auto以外的值，则会覆盖alignItems属性。支持auto , flex_start , flex_end , center , baseline , stretch六种取值。除了auto以外，其他和alignItems属性一样，而auto表示继承alignItems的属性，所以基本上效果相同，这里不做过多解释。 4.5 layout_flexBasisPercent layout_flexBasisPercen , 表示设置子元素的长度为它父容器长度的百分比。这个值只有设置了父容器的长度时才有效（也就是MeasureSpec mode 是 MeasureSpec.EXACTLY）。默认值时-1。 设置第一个元素 app:layout_flexBasisPercent=”50%” 4.6 layout_minWidth / layout_minHeight 强制限制 FlexboxLayout的子元素（宽或高）不会小于最小值，不管layout_flexShrink这个属性的值为多少，子元素不会被缩小到小于设置的这个最小值。 4.7 layout_maxWidth / layout_maxHeight 这个和上面的刚好相反，强制限制FlexboxLayout子元素不会大于这个最大值, 不管layout_flexGrow的值为多少，子元素不会被放大到超过这个最大值。 4.8 layout_wrapBefore layout_wrapBefore 属性控制强制换行，默认值为false,如果将一个子元素的这个属性设置为true，那么这个子元素将会成为一行的第一个元素。这个属性将忽略flex_wrap 设置的 noWrap值。 设置第三个元素 app:layout_wrapBefore=”true” 可以看到第三个元素另起了一行","link":"/2017/08/19/《Android 基础（四十)》 FlexboxLayout/"},{"title":"《Android 基础（四十一）》 ExpandableListView","text":"1. 简介 看下源码中的英文介绍 /** A view that shows items in a vertically scrolling two-level list. This differs from the {@link ListView} by allowing two levels: groups which can individually be expanded to show its children. The items come from the {@link ExpandableListAdapter} associated with this view. Expandable lists are able to show an indicator beside each item to display the item’s current state (the states are usually one of expanded group, collapsed group, child, or last child). Use {@link #setChildIndicator(Drawable)} or {@link #setGroupIndicator(Drawable)} (or the corresponding XML attributes) to set these indicators (see the docs for each method to see additional state that each Drawable can have). The default style for an {@link ExpandableListView} provides indicators which will be shown next to Views given to the {@link ExpandableListView}. The layouts android.R.layout.simple_expandable_list_item_1 and android.R.layout.simple_expandable_list_item_2 (which should be used with {@link SimpleCursorTreeAdapter}) contain the preferred position information for indicators. The context menu information set by an {@link ExpandableListView} will be a {@link ExpandableListContextMenuInfo} object with {@link ExpandableListContextMenuInfo#packedPosition} being a packed position that can be used with {@link #getPackedPositionType(long)} and the other similar methods. Note: You cannot use the value wrap_content for the android:layout_height attribute of a ExpandableListView in XML if the parent’s size is also not strictly specified (for example, if the parent were ScrollView you could not specify wrap_content since it also can be any length. However, you can use wrap_content if the ExpandableListView parent has a specific size, such as 100 pixels. @attr ref android.R.styleable#ExpandableListView_groupIndicator @attr ref android.R.styleable#ExpandableListView_indicatorLeft @attr ref android.R.styleable#ExpandableListView_indicatorRight @attr ref android.R.styleable#ExpandableListView_childIndicator @attr ref android.R.styleable#ExpandableListView_childIndicatorLeft @attr ref android.R.styleable#ExpandableListView_childIndicatorRight @attr ref android.R.styleable#ExpandableListView_childDivider @attr ref android.R.styleable#ExpandableListView_indicatorStart @attr ref android.R.styleable#ExpandableListView_indicatorEnd @attr ref android.R.styleable#ExpandableListView_childIndicatorStart @attr ref android.R.styleable#ExpandableListView_childIndicatorEnd */ ExpandableListView是不同于ListView的两级列表View，可以收起可以展开。通过ExpandableListAdapter来配置需要现实的items。 2. 基本使用2.1 布局文件 group.xml(一级节点item布局) 123456789101112131415&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:paddingLeft=&quot;30dp&quot; android:orientation=&quot;vertical&quot; &gt; &lt;TextView android:id=&quot;@+id/group_text&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:paddingTop=&quot;10dip&quot; android:paddingBottom=&quot;10dip&quot; android:text=&quot;&quot; /&gt;&lt;/LinearLayout&gt; child.xml(二级节点item) 12345678910111213&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:orientation=&quot;horizontal&quot; android:paddingLeft=&quot;40dp&quot;&gt; &lt;TextView android:id=&quot;@+id/textOne&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:text=&quot;&quot; /&gt;&lt;/LinearLayout&gt; actiivty_main.xml(主界面布局) 1234567891011121314151617&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:tools=&quot;http://schemas.android.com/tools&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; tools:context=&quot;cn.onlyloveyd.expandablelistviewdemo.MainActivity&quot;&gt; &lt;ExpandableListView android:id=&quot;@+id/expandable_list&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:groupIndicator=&quot;@drawable/expand&quot; android:childIndicator=&quot;@drawable/collapse&quot; /&gt;&lt;/LinearLayout&gt; 2.2 代码 YEAdapter.java(可伸展列表对应的Adapter) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157public class YEAdapter extends BaseExpandableListAdapter { //一级节点数据 private List&lt;GroupItem&gt; mGroupItems; private Context mContext; public YEAdapter(Context context, List&lt;GroupItem&gt; mData) { mGroupItems = mData; mContext = context; } /** * 一级节点数量 * @return */ @Override public int getGroupCount() { return mGroupItems.size(); } /** * 指定位置一级节点下二级节点数量 * @param groupPosition * @return */ @Override public int getChildrenCount(int groupPosition) { return mGroupItems.get(groupPosition).mChildList.size(); } /** * 获取一级节点对象 * @param groupPosition * @return */ @Override public Object getGroup(int groupPosition) { return mGroupItems.get(groupPosition); } /** * 获取二级节点对象 * @param groupPosition * @param childPosition * @return */ @Override public Object getChild(int groupPosition, int childPosition) { return mGroupItems.get(groupPosition).mChildList.get(childPosition); } /** * 获取一级节点ID，这里用位置值表示 * @param groupPosition * @return */ @Override public long getGroupId(int groupPosition) { return groupPosition; } /** * 获取二级节点ID，这里用位置值表示 * @param groupPosition * @param childPosition * @return */ @Override public long getChildId(int groupPosition, int childPosition) { return childPosition; } /** * ID是否稳定 * @return */ @Override public boolean hasStableIds() { return true; } /** * 获取一级节点view * @param groupPosition * @param isExpanded * @param convertView * @param parent * @return */ @Override public View getGroupView(int groupPosition, boolean isExpanded, View convertView, ViewGroup parent) { View view=null; TextView mTv; if(convertView!=null){ view = convertView; mTv = (TextView) view.getTag(); }else{ view = View.inflate(mContext,R.layout.group, null); mTv = (TextView) view.findViewById(R.id.group_text); view.setTag(mTv); } mTv.setText(mGroupItems.get(groupPosition).title); return view; } /** * 获取二级节点View * @param groupPosition * @param childPosition * @param isLastChild * @param convertView * @param parent * @return */ @Override public View getChildView(int groupPosition, int childPosition, boolean isLastChild, View convertView, ViewGroup parent) { View view=null; TextView mTextView; if(convertView!=null){ view = convertView; mTextView = (TextView) view.getTag(); }else{ view = View.inflate(mContext,R.layout.child, null); mTextView = (TextView) view.findViewById(R.id.textOne); view.setTag(mTextView); } mTextView.setText(mGroupItems.get(groupPosition).mChildList.get(childPosition).message); return view; } /** * 二级菜单是否可选（true为可选，false为不可选，也就是响应和不响应点击事件） * @param groupPosition * @param childPosition * @return */ @Override public boolean isChildSelectable(int groupPosition, int childPosition) { return true; } /** * 一级节点对象 */ public static class GroupItem { String title; List&lt;ChildItem&gt; mChildList; } /** * 二级节点对象 */ public static class ChildItem { String message; }} 具体解释请查阅注释信息 MainActivity.java 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960public class MainActivity extends AppCompatActivity { @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); List&lt;YEAdapter.GroupItem&gt; mGroupItems = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; 5; i++) { YEAdapter.GroupItem item = new YEAdapter.GroupItem(); item.title = &quot;this is &quot; + i + &quot;nd group item&quot;; List&lt;YEAdapter.ChildItem&gt; mChildItems = new ArrayList&lt;&gt;(); for (int j = 0; j &lt; 4; j++) { YEAdapter.ChildItem item1 = new YEAdapter.ChildItem(); item1.message = &quot;this is &quot; + i + &quot;nd group item&apos;s &quot; + j + &quot;nd child&quot;; mChildItems.add(item1); } item.mChildList = mChildItems; mGroupItems.add(item); } ExpandableListView expandableListView = (ExpandableListView) this.findViewById(R.id.expandable_list); YEAdapter yeAdapter = new YEAdapter(this, mGroupItems); expandableListView.setAdapter(yeAdapter); expandableListView.setOnChildClickListener(new ExpandableListView.OnChildClickListener() { @Override public boolean onChildClick(ExpandableListView parent, View v, int groupPosition, int childPosition, long id) { Toast.makeText(MainActivity.this, groupPosition + &quot;nd group&apos;s &quot; + childPosition + &quot;nd Item is clicked!&quot;, Toast.LENGTH_SHORT).show(); return false; } }); expandableListView.setOnGroupClickListener(new ExpandableListView.OnGroupClickListener() { @Override public boolean onGroupClick(ExpandableListView parent, View v, int groupPosition, long id) { Toast.makeText(MainActivity.this, groupPosition + &quot;nd group is clicked&quot;, Toast.LENGTH_SHORT).show(); return false; } }); expandableListView.setOnGroupCollapseListener(new ExpandableListView.OnGroupCollapseListener() { @Override public void onGroupCollapse(int groupPosition) { Toast.makeText(MainActivity.this, &quot;the &quot; + groupPosition + &quot;nd group is collapsed&quot;, Toast.LENGTH_SHORT).show(); } }); expandableListView.setOnGroupExpandListener(new ExpandableListView.OnGroupExpandListener() { @Override public void onGroupExpand(int groupPosition) { Toast.makeText(MainActivity.this, &quot;the &quot; + groupPosition + &quot;nd group is expanded&quot;, Toast.LENGTH_SHORT).show(); } }); }} 2.3 实际效果 3. 类结构3.1 属性值属性值 | 含义 ------------------- | ----------------------- groupIndicator | 一级节点指示器 indicatorLeft | 一级节点指示器距离左边界距离 indicatorRight | 一级节点指示器距离右边界距离 childIndicator | 意义同group中相同 childIndicatorLeft | 意义同group中相同 childIndicatorRight | 意义同group中相同 childDivider | 设置二级节点的分割想，颜色或者drawable indicatorStart | 同indicatorLeft indicatorEnd | 同indicatorRight childIndiatorStart | 同childIndicatorLeft childIndicatorEnd | 同childIndicatorRight 主要看看分割线效果 设置图片 divider.xml 1234567&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;shape xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt; &lt;solid android:color=&quot;@color/colorAccent&quot;/&gt; &lt;corners android:radius=&quot;3dp&quot;/&gt;&lt;/shape&gt; 设置颜色 android:childDivider=”@color/colorPrimary” 那么一级节点如何设置分割线? 看这个例子 123android:childDivider=&quot;@color/colorPrimary&quot;android:divider=&quot;@drawable/divider&quot;android:dividerHeight=&quot;2dp&quot; 给一级菜单和二级菜单设置不同的分割线，看下效果 二级节点依然显示的时我们设置的分割线，但是当一级节点展开时，展开的节点的一级分割线变成了二级节点的分割线样式，收起后恢复成一级节点的分割线样式。 3.2 常用方法 具体内容请查阅源码。 4. 设置上下文菜单4.1 expandable_menu.xml123456789101112&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;menu xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; &gt; &lt;item android:id=&quot;@+id/menu_item1&quot; android:title=&quot;菜单项1&quot;&gt; &lt;/item&gt; &lt;item android:id=&quot;@+id/menu_item2&quot; android:title=&quot;菜单项2&quot;&gt; &lt;/item&gt;&lt;/menu&gt; 4.2 onCreateContextMenu123456@Overridepublic void onCreateContextMenu(ContextMenu menu, View v, ContextMenu.ContextMenuInfo menuInfo) { super.onCreateContextMenu(menu, v, menuInfo); menu.setHeaderTitle(&quot;expandable menu&quot;); getMenuInflater().inflate(R.menu.expandable_menu, menu);} 4.3 onContextItemSelected12345678910111213141516@Overridepublic boolean onContextItemSelected(MenuItem item) { // TODO Auto-generated method stub super.onContextItemSelected(item); switch (item.getItemId()) { case R.id.menu_item1: Toast.makeText(this, &quot;this is first menu item&quot;, Toast.LENGTH_SHORT).show(); break; case R.id.menu_item2: Toast.makeText(this, &quot;this is second menu item&quot;, Toast.LENGTH_SHORT).show(); break; default: break; } return super.onContextItemSelected(item);} 4.4 item长按事件显示菜单并注册上下文菜单123456789101112expandableListView.setOnItemLongClickListener(new AdapterView.OnItemLongClickListener() { @Override public boolean onItemLongClick(AdapterView&lt;?&gt; parent, View view, int position, long id) { if (ExpandableListView.getPackedPositionType(id) == ExpandableListView.PACKED_POSITION_TYPE_CHILD) { expandableListView.showContextMenu(); return true; } return false; }});registerForContextMenu(expandableListView); 5. 备注 程序源码","link":"/2017/08/27/《Android 基础（四十一）》 ExpandableListView/"},{"title":"《Android 安全（二）》Smali语法基础","text":"Github原文 Smali smali/baksmali 是Android的Java VM实现dalvik使用的dex格式的汇编程序/反汇编程序。 语法松散地基于Jasmin/ dedexer的语法，并支持dex格式的全部功能（注释，调试信息，行信息等） BuildProcedure(构建程序)依赖 这可能是一份不完整的清单。如果您遇到遗漏的内容，请随时发表评论，我会将其添加 jdk(8) git 其他所有内容都应该通过gradle / gradlew下载 构建123git clone https://github.com/JesusFreke/smali.gitcd smali./gradlew build (windows上，使用gradlew.bat 代替./gradlew) 生成的jar包位置 123smali/build/libs/smali-&lt;version&gt;.jarbaksmali/build/libs/baksmali-&lt;version&gt;.jar 除此之外，通过 1./gradlew proguard 可以构建出体积更小混淆后的jar文件 123smali/build/libs/smali-&lt;version&gt;-small.jarbaksmali/build/libs/baksmali-&lt;version&gt;-small.jar DeodexInstructions(Deodex说明)说明 从v2.1.0开始，baksmali支持反编译ART oat文件。 支持的最低oat版本为56，也就是Android 6.0 / Marshmallow版本中的oat文件版本。 由于与字段排序有关的一些潜在问题，暂不支持M版本之前的oat文件反编译（例如Lollipop）。 你可以在oat文件上运行baksmali以获取其中所有odex文件的列表。 123456789101112131415161718&gt; adb pull /system/framework/arm/boot.oat boot.oat&gt; baksmali boot.oatboot.oat contains multiple dex files. You must specify which one to disassemble with the -e optionValid entries include:/system/framework/core-libart.jar/system/framework/conscrypt.jar/system/framework/okhttp.jar/system/framework/core-junit.jar/system/framework/bouncycastle.jar/system/framework/ext.jar/system/framework/framework.jar/system/framework/framework.jar:classes2.dex/system/framework/telephony-common.jar/system/framework/voip-common.jar/system/framework/ims-common.jar/system/framework/mms-common.jar/system/framework/android.policy.jar/system/framework/apache-xml.jar 通过如下操作我们可以反编译boot.oat中的framework jar文件 12&gt; adb pull /system/framework/arm/boot.oat /tmp/framework/boot.oat&gt; baksmali -x -c boot.oat -d /tmp/framework -e /system/framework/framework.jar /tmp/framework/boot.oat -o framework 或者通过如下方式反编译一个应用程序oat 123&gt; adb pull /system/framework/arm/boot.oat /tmp/framework/boot.oat&gt; adb pull /system/app/Calculator/oat/arm/Calculator.odex Calculator.odex&gt; baksmali -x -c boot.oat -d /tmp/framework Calculator.odex -o Calculator 注意，在反编译oat文件时不需要-a选项来指定API Level，baksmali会自动使用oat文件中的API Level。 从v1.4.0开始，deodexing过程已经大大简化了，不再需要通过-c选项指定其他类路径。 Deodexing现在很简单 1baksmali -a &lt;api_level&gt; -x &lt;odex_file&gt; -d &lt;framework_dir&gt; odex文件常识 简而言之，odex文件就是classes.dex文件的优化版本，针对特定设备的优化。 值得一提的是，odex文件依赖于生成时加载的每个“BOOTCLASSPATH”文件。 odex文件仅在与这些确切的BOOTCLASSPATH文件一起使用时才有效。 dalvik通过存储odex文件所依赖的每个文件的校验和来强制执行此操作，并确保在加载odex文件时每个文件的校验和匹配。 除了加载的主apk / jar之外，BOOTCLASSPATH只是可以加载类的jars / apk列表而已。 一般android系统的基础BOOTCLASSPATH中包含5个jar包 - core.jar，ext.jar，framework.jar，android.policy.jar和services.jar。 这些都可以在/ system / framework中找到。 但是，有些apks依赖于额外的jar或apks文件。 例如，对于使用谷歌地图的应用程序，com.google.android.maps.jar将附加到该应用程序的apk的BOOTCLASSPATH中。 下面这几个由于odex的依赖性造成的问题有时会让事情变得比较麻烦。 首先 - 你不能从一个系统镜像中获取apk + odex文件并在另一个系统映像上运行它（除非其他系统映像使用完全相同的framework文件）。 另一个问题是，如果对任何BOOTCLASSPATH文件进行任何更改，它将使依赖于该文件的每个odex无效 - 基本上每个设备上的apk / jar都会失效。 Deodexing(反编译Odex) 以下示例默认你使用下载页面上提供的baksmali wrapper脚本来调用baksmali。 如果你是直接调用jar，可以将“baksmali”替换为“java -jar baksmali.jar” deodexing的两个主要选项是-x和-d。 -x是告诉baksmali你想要deodex的对象，-d告诉baksmali从哪里加载依赖项。 依赖内容可以是odex文件的形式，也可以是包含classes.dex文件的jar / apk。两者皆可。 例如，你想从ICS镜像中反编译Calculator.odex文件并且所有的framework odex文件和jar包都放在一个名为framework的文件夹中，你就可以通过如下方式操作： 1baksmali -a 15 -x Calculator.odex -d framework -o Calculator 反编译Calculator.odex，并将生成的deodexed smali文件放入名为Calculator的目录中。 Troubleshooting(问题解决)Heap Space 你可能遇到的一个问题是它是否已用完堆内存。 该错误可能类似于“java.lang.OutOfMemoryError：Java heap space”。 要解决此问题，可以使用-Xmx参数来增加堆大小。 尝试将其设置为512m。 当然，如果需要，你可以进一步增加它。 如果你使用wrapper script来调用baksmali，则可以使用-JXmx。 例如： 1baksmali -JXmx512m -x blah.odex 或者通过如下方式直接调用jar包 1java -Xmx512m -jar baksmali.jar -x blah.odex Registers(寄存器)介绍 在dalvik字节码中，寄存器是32位，并且可以保存任何类型的值。 2个寄存器用于保存64位类型（Long和Double）。 置顶方法中寄存器数量 有两种方法可以指定方法中有多少可用寄存器。 .registers指令指定方法中寄存器的总数，而.locals指令指定方法中非参数寄存器的数量。 寄存器总数包括保存方法参数所需的寄存器。 方法参数如何传递至方法 调用方法时，方法的参数将会被放置到倒数的n个寄存器中。如果某个方法有2个参数，5个寄存器（v0-v4），此时参数会被放置到最后两个寄存器中，也就是v3和v4。 对于非static方法，第一个参数永远都是调用该方法的对象。 比如，非static方法LMyObject;-&gt;callMe(II)V.，这个方法有2个int型参数，但是还存在一个隐型的 LMyObject; 参数在两个整型参数之前，所以这个方法有3个参数。 假设通过.registers 5 指令或者.local 2指令(i.e. 2个local寄存器和3个参数寄存器)来指定这个方法有5个寄存器(v0 - v4)，当方法被调用时，调用此方法的对象(也就是 this 引用)将会被放置到v2寄存器中，而第一个整型参数将会被放置到v3寄存器中，第二个整型参数会被放置到v4寄存器中。 对于static方法，只是少了一个隐型参数，this而已。 Register names(寄存器名称) 对于寄存器，有两种命名方案：普通的v开头命名方案和针对参数寄存器的p开头命名方案。我们继续看上面那个有3个参数，5个寄存器的方法，下面这个表格分别用两种命名方式来表示寄存器。 Local | Param | 数量 ----- | ----- | ----------- v0 | | 第一个local寄存器 v1 | | 第二个local寄存器 v2 | p0 | 第一个参数寄存器 v3 | p1 | 第二个参数寄存器 v4 | p2 | 第三个参数寄存器 Motivation for introducing parameter registers(引入参数寄存器的原因) p开头命名方案的引入是为了解决大家在编辑smali过程中的共同烦恼。比方说，你想添加一下代码到一个有几个参数的方法，然后你发现，你需要一个额外的寄存器。你可能会想“这不是小问题嘛，只需要在.registers指令上加一个不就完事了”。 显然，问题不可能那么简单。记住一点，方法参数是存放在可用寄存器中倒数的几个寄存器中。如果你增加寄存器的数量，你将会改变方法参数存放的寄存器。因此，你必须更改.registers指令并重新编号每个参数寄存器。 但是如果在整个方法中使用p命名方案引用参数寄存器，则可以轻松更改方法中的寄存器数量，而无需担心重新编号任何现有寄存器。 注意：默认情况下，baksmali将使用参数寄存器的p命名方案。如果由于某种原因要禁用此命令并强制baksmali始终使用v命名方案，则可以使用-p / - no-parameter-registers选项。 Long/Double值 如前所述，Long和Double类型（分别为J和D）是64位值，需要2个寄存器。在引用方法参数时要记住这一点。 比如，有一个非static方法 1LMyObject;-&gt;MyMethod(IJZ)V 方法参数类型依次是：LMyObject;, int, long, bool。所以，这个方法需要5个寄存器来存放参数。 Register | Type -------- | ---- p0 | this p1 | I p2,p3 | J p4 | Z SmaliBaksmali2.2 v2.2版本后，smail和baksmali有了新的脚手架工具。 12baksmali disassemble app.apk -o appsmali assemble app -o classes.dex 执行baksmali help 和 smali help 查看入门内容。 注意以下几点： 你可以把apk或者oat文件当成文件夹，单独指定其中的文件作为对象，就像这样 baksmali disassemble app.apk/classes2.dex 。执行 baksmali help input 查阅更多相关信息。 deodexing时指定bootclasspath/classpath的命令选项做了小的调整。现在deodexing oat 文件，一般这样操作 adb pull /system/framework framework &amp;&amp; baksmali deodex app.odex -b framework/arm/boot.oat baksmail现在包含一系列列举dex/oat/apk 文件各种相关信息的命令 baksmali list dex boot.oat 列举出oat文件中所有dex（此命令也适用于apk文件） baksmali list classes app.apk 列举apk/dex等文件中的所有类 baksmali list methods app.apk | wc -l 获取当前dex文件中的方法数 V2.2支持在Nougat版本上解码oat文件，并包含一些针对Marshmallow版本的错误修正 在dexlib2等文件中有一些重大的API更改。因此，如果你打算将工具升级到dexlib2 v2.2，你可能需要花点事件去解决一些问题 SmaliBaksmali2.0smali/baksmali 2.0版本是下一个重大更新版本，主要就是dexlib的更新。当前正处于测试阶段，如果想体验一下，可以自行前往下载界面下载2.0b1 jar文件。 这对你意味着什么？大部分内容对你没有影响，值得一提的是它运行更快并且使用更少的内存。 但是，下面这几点你还是需要稍微注意一下。 Multithreading(多线程) smali和baksmali现在是多线程的！默认情况下，它们使用可用的CPU数，最多为6。你可以使用-j选项进行设置。 为了在具有多线程的smali中获得最佳性能，最好稍微提高内存。如果你正在使用smali wrapper script，则可以通过添加-JXmx512m选项手动执行此操作。 1smali -JXmx512m out -o classes.dex 当然，你可以使用默认只位512m的smali wrapper script Language Changes(语言改动) 我利用一次重大修订的机会来调整语言本身的一些内容。 .parameter -&gt; .param12345.method parameters(IILjava/lang/String;)V .parameter .parameter .parameter stringParameter... 变成 123.method parameters(IILjava/lang/String;)V .param p3, &quot;stringParameter&quot;... .parameter指令现在为.param，它的工作方式与.local指令类似。 .param指令不是按顺序将.parameter信息与每个参数匹配，而是使用register参数指定与之关联的参数。 .array-data changes123456.array-data 0x4 0x0t 0x0t 0x80t 0x0t 0x0t 0x0t 0x40t 0x0t 0x0t 0x0t 0x20t 0x0t 0x0t 0x0t 0x10t 0x0t.end array-data 变成 123456.array-data 4 0x800000 0x400000 0x200000 0x100000.end array-data .array-data中的每个数字现在都是它自己的元素，而不是之前的语法，它会连接每个数字的little-endian编码，然后将完整的连接字节数组重新解释为n-byte little-endian序编码元素。 const/high16 and const-wide/high1612const/high16 v0, 0x1234const-wide/high16 v0, 0x1234 变成 12const/high16 v0, 0x12340000const-wide/high16 v0, 0x1234000000000000 更改了* / high16指令的语法，以便它使用加载到寄存器中的实际值，而不仅仅是存储在指令中的16位。 也就是说指定除了顶部16位以外的位为非0是错误的。例如 const/high16 v0, 0x12340001 将会是错误的。 smalidea smalidea是一个针对Intellij IDEA以及Android Studio 的smali语言插件。 Download(下载) 当前为alpha版本，持续开发中。 Features(特性)当前能力 语法高亮/语法错误 字节码级调试 断点 指令级单步调试 给任意寄存器添加watcher 调试过程中，完全java风格表达式本地窗口支持等 跳转到定义处 查找引用 重命名 在java代码中引用smali类(但是当前还不能真正被编译) 问题报告 - 从错误对话框轻松创建新的github问题 计划能力 自动补全（指令名称，类名/方法名/变量名等等） 纯Smali工程编译 健壮性错误检测（如，全字节码检测） 流畅地项目导入过程 自动检测源目录 选择SDK APK作为新项目导入引导 添加“Smali Class”到“New…”菜单中 在“locals”窗格中显示具有值的所有寄存器 “watch”窗格中设置寄存器的值 有潜力功能 smali+java混合工程编译 “引入新寄存器” 导入或者deodex设备framework作为新模块或者作为sdk 公开寄存器类型分析数据 随时显示寄存器的预期类型 寻找寄存器设值位置 安装 下载最新smalidea zip 文件 在IDEA或者Android Studio中“Settings-&gt;Plugins”中”Install plugin from disk” “Apply”并且重启 调试注意：单指令单步调试在 IDEA 14.1及以上版本支持(Android Studio是基于IDEA的，所以类似)。而此之前的版本，执行单步调试的时候，回调转到下一个.line指令，而不是下一条指令。 使用baksmali反编译一个应用到”src”文件夹，并将其作为一个新工程的源文件夹。 baksmali d myapp.apk -o ~/projects/myapp/src IDEA中，导入新项目，选择刚才的新工程目录 ~/projects/myapp 在导入项目时使用“Create project from existing sources”选项 项目导入完成后，右键src文件夹，“Mark Directory As-&gt;Sources Root” 打开项目设置界面，选择或者创建合适的JDK 在设备上安装启动此应用 运行DDMS，找到对应的应用进程 在IDEA中，创建一个新的“Remote”调试配置(Run-&gt;Edit Configurations)，并改变调试端口至8700 Run -&gt; Debug 当断点被触发时，应用程序将会暂停，此时你可以单步，添加watch等 或者 在Android Studio3.2下进行如下操作： 使用baksmali反编译一个应用到”src”文件夹，并将其作为一个新工程的源文件夹。 baksmali d myapp.apk -o ~/projects/myapp/src 在Android Studio中，关闭当前项目，执行“Open an existing Android Studio project” 项目创建完成后，右键src文件夹，“Mark Directory As-&gt;Sources Root” 确保应用AndroidManifest.xml中“android:debuggable=“true”。打开“USB调试”并且在“开发者选项”中使用“选择待调试应用” 启动应用程序并将JDWP服务转发到localhost， adb forward tcp:8700 jdwp:$(timeout 0.5 adb jdwp | tail -n 1) 在Android Studio中，创建一个新的“Remote”调试配置(Run-&gt;Edit Configurations)，并改变调试端口至8700 在Android Studio中， Run -&gt; Debug 当断点被触发时，应用程序将会暂停，此时你可以单步，添加watch等 TypesMethodsAndField(类型，方法和字段) 类型 dalvik字节码有两个主要的类型，基本类型和引用类型。引用对象指的是对象，数组等基础类型外的所有类型。 每个基本类型都由单个字母代表。这并不是我想出来的点子，他们真真实实地以字符串的形式存储在dex文件中。它们在 dex-format.html 文档中被明确的指出来过(Android源码仓中dalvik/docs/dex-format.html)。 V | void - 只能用于返回类型 - | --------------- Z | boolean B | byte S | short C | char I | int J | long(64bits) F | float D | double(64bits) Object则是以 Lpackage/name/ObjectName; 的形式出现， L 表明这是一个对象类型， package/name/ 指代包名， ObjectName 为当前对象类型名称， : 作为对象的结尾。这等价于java的 package.name.ObjectName ，以String这个具体的类型为例子， Ljava/lang/String; 等价于 java.lang.String 。 Arrays(数字)则是以 [I 的形式出现，这指代的是一个int类型一维数组，也就是java中 int[] 。至于多维数组，只需要在前面添加一个或者多个 [ 字符。 [[I = int[][] ， [[[I = int[][][] (注意，数字的最大维度为255)。 对象数据，如 [Ljava/lang/String; 道理和上面是一样的。 方法 方法总是以非常详细的形式指定，包括方法的类型，方法名称，参数类型和返回类型。虚拟机需要所有这些信息才能找到正确的方法，并能够对字节码执行静态分析（用于验证/优化目的）。 一般形式如下： 1Lpackage/name/ObjectName;-&gt;MethodName(III)Z 上面这个示例中， Lpackage/name/ObjectName; 表示类型， MethodName 表示方法名， (III)Z 中 III 表示参数类型（3个int型）， Z 表示方法的返回类型（bool类型）。 方法参数一个接一个地列出，它们之间没有分隔符。 下面有一个更复杂的示例： 1method(I[[IILjava/lang/String;[Ljava/lang/Object;)Ljava/lang/String; 等价于 1String method(int, int[][], int, String, Object[]) 字段 字段同样总是以详细形式指定，包括包含字段的类型，字段名称和字段类型。同样，这些信息也是为了帮助虚拟机能够找到正确的字段，以及对字节码执行静态分析。 一般形式如下： 1Lpackage/name/ObjectName;-&gt;FieldName:Ljava/lang/String; 这应该是不言自明的 - 它们分别是包名，字段名和字段类型。 UnresolvableOdexInstruction（暂时无法解决的Odex指令）说明 在deodexing过程中，我们使用baksmali产生的一些smali文件中，你可能会注意到baksmali用一个throw或其他东西替换odexed指令的一些情况，其中的注释如“Replaced unresolvable optimized instruction with a throw”。 详情 比如，下面这段java代码： 12Object blah = null;blah.toString(); 相对应的Smali代码为： 12const v0, 0invoke-virtual {v0}, Ljava/lang/Object;-&gt;toString(); 这当然会导致空指针异常 - 但它是有效的代码。在实践中，这些案例更加隐蔽。 当代码被odexed时，invoke-virtual指令将被一个invoke-virtual-quick指令替换，如下所示： 12const v0, 0invoke-virtual-quick {v0), vtable@7 其中vtable @ 7是指向Object是抽象方法表中toString()方法的索引。 但请注意，上面的代码并没有提到该方法所在的类。由于v0始终为null，并且我们只有vtable索引，因此baksmali不可能知道要查看哪个类。所以，不可能deodex 这条指令。但是，我们可以尽量对其进行处理：用具有完全相同效果的内容来替换这条指令。记住v0始终为null，所以通过它调用任何方法都会导致空指针。所以Samli就使用同样会抛出空指针的内容来替换这条无法解决的odex指令。 除此之外，紧随上面这些无法解决的odex指令的code，由于永远无法执行而成为了冗余代码（除非有其他分支可以访问到它们）。或者在一些其他情况下，代码依赖的是一个我们无法解决的odex指令方法结果，那么这部分代码也是不可能被deodex的，因为，这部分代码无法被访问到，全被移除或者注释掉了。 因此，简而言之，这些情况不应影响字节码的语义/功能。当你看到“replaced unresolvable optimized instruction”，不必大惊小怪。Baksmali对这部分呢日用的处理不影响代码功能/语义（如果对功能/语义造成了影响，那就是baksmali的bug）。 目前，存在与此相关的已知问题，其中如果try块中的所有代码都被注释掉，因为它依赖一个无法解析的odex指令，则（空）try块保留在其中，并且当安装到设备上时，空 try块会导致dalvik拒绝dex文件。","link":"/2019/03/20/《Android 安全（二）》Smali语法基础/"},{"title":"《Android开源库》 EventBus 用法详解（译文）","text":"介绍 EventBus是一个使用发布者/订阅者模式 并且低耦合的Android开源库，。 EventBus只需几行代码即可实现中央通信解耦类：简化代码，删除依赖关系，加快应用程序开发速度。 优势 简化组件通信 解耦事件发送端和接收端 在Activity,Fragment和后天线程之间运行良好 避免复杂且易出错的依赖问题和生命周期问题 运行速度快。为了高性能专门做过优化 jar包小（&lt;50K） 在实践中已通过100,000,000次安装的应用程序证明 具有指定分发线程和用户优先级等高级特性 特性 简单但强大：EventBus是一个微小的库，具有超级容易学习的API。然而，您的软件架构可能因组件解耦而受益：订阅者在使用事件时不用关心这个事件是谁发送的。 大量验证：EventBus是最常用的Android库之一：成千上万的应用程序使用EventBus，其中不乏非常受欢迎的应用程序。我们认为差不多有十亿应用程序使用EventBus。 高性能：Android系统上，性能尤为重要。 EventBus被针对性的做了大量的分析和优化;EventBus可能是这类开源库中速度最快的 解决方案。 基于API的便捷注解（不牺牲性能）：只需将@Subscribe注解添加订阅方法即可。由于构建的时候花费了时间来建立注解的索引，所以EventBus不需要在应用程序的运行时间执行注释反射，注解反射的方式在Android上相当慢。 Android主线程发送：当与UI交互时，EventBus可以在主线程中传递事件，而不用去关心事件是从如何发布的。 后台线程发送：如果您的订阅者长时间运行任务，EventBus也可以使用后台线程来避免UI阻塞。 事件和订阅者继承：在EventBus中，面向对象的范例适用于事件和订阅者类。让我们假设事件类A是B的父类。类型B的发布事件也将被发布到对A感兴趣的订阅者。类似地，考虑订阅类的继承。 零配置：您可以从代码中的任何地方立即使用默认的EventBus实例。 可配置：要根据需要调整EventBus，可以使用构建器模式调整其行为。 添加EventBus到工程 EventBus在JCenter和Maven Central上可用，因此只需将依赖项添加到项目中。 Gradle 1compile &apos;org.greenrobot:eventbus:3.0.0&apos; Maven 12345&lt;dependency&gt; &lt;groupId&gt;org.greenrobot&lt;/groupId&gt; &lt;artifactId&gt;eventbus&lt;/artifactId&gt; &lt;version&gt;3.0.0&lt;/version&gt;&lt;/dependency&gt; jar包 开始使用EventBus一、简单的三步教你使用EvnetBus定义事件 事件是纯Java对象，没有其他的特殊要求 12345678public class MessageEvent { public final String message; public MessageEvent(String message) { this.message = message; }} #####准备订阅者 订阅者需要实现在事件发布时将被调用的事件处理方法（也称为“订阅方法”）。 这些订阅方法将用@Subscribe注释定义。 注意，使用EventBus 3可以自由选择方法名（没有像EventBus 2中的命名约定）。 1234567891011// This method will be called when a MessageEvent is posted (in the UI thread for Toast)@Subscribe(threadMode = ThreadMode.MAIN)public void onMessageEvent(MessageEvent event) { Toast.makeText(getActivity(), event.message, Toast.LENGTH_SHORT).show();}// This method will be called when a SomeOtherEvent is posted@Subscribepublic void handleSomethingElse(SomeOtherEvent event) { doSomethingWith(event);} 订阅者还需要向总线注册和注销。 只有订阅者注册后，他们才会收到事件。 在Android的在活动和片段中，通常应该根据其生命周期进行注册。 对于大多数情况下在onStart中注册，在onStop中销毁就OK了。 #####发布事件 在代码的任意地方发布事件，所有与当前事件匹配且注册过的订阅者都将会收到事件。 1EventBus.getDefault().post(new MessageEvent(&quot;Hello everyone!&quot;)); 二、传递线程 EventBus可以为你处理线程：事件可以发布在不同于发布线程的线程中。事件可以发布在和发布线程不同的线程里。一个普遍的场景就是处理UI的变化。在Android系统中，UI更改必须在UI（主）线程中完成。另一方面，网络或者任何耗时的任务，都不允许在主线程中执行。EventBus帮助你处理这些任务并且与UI线程同步（无需深入了解线程转换，使用AsyncTask等）。 在EventBus中，你可以通过使用四个ThreadMode中的一个来定义将调用事件处理方法的线程。 ThreadMode: POSTING 订阅者将会在事件发布的线程中被调用。这是默认模式。事件的传递是同步完成的，一旦事件发布完成，所有的订阅者都将会被调用。由于完全避免了线程切换，这种模式的开销是最小的。所以，针对那些不需要主线程并且能在很短时间内完成的简单任务，我们推荐使用这种模式。这种模式下的事件处理方法必须快速返回，避免阻塞发布事件的线程，因为这个线程有可能是主线程。 例如： 123456// Called in the same thread (default)// ThreadMode is optional here@Subscribe(threadMode = ThreadMode.POSTING)public void onMessage(MessageEvent event) { log(event.message);} ThreadMode: MAIN 订阅者将在Android的主线程（有时称为UI线程）中调用。 如果发布线程是主线程，则将直接调用事件处理方法（与ThreadMode.POSTING描述的同步）。 使用此模式的事件处理程序必须快速返回，以避免阻塞主线程。 例如： 12345// Called in Android UI&apos;s main thread@Subscribe(threadMode = ThreadMode.MAIN)public void onMessage(MessageEvent event) {textField.setText(event.message);} ThreadMode: BACKGROUND 订阅者将在后台线程中调用。 如果发布线程不是主线程，事件处理程序方法将直接在发布线程中调用。 如果发布线程是主线程，EventBus使用单个后台线程来按顺序传递所有事件。 使用此模式的事件处理方法应尽快返回以避免阻塞后台线程。 例如： 12345// Called in the background thread@Subscribe(threadMode = ThreadMode.BACKGROUND)public void onMessage(MessageEvent event){ saveToDisk(event.message);} ThreadMode: ASYNC 事件处理方法在单独的线程中调用。 这个线程总是独立于发布线程和主线程。 这种模式下，发布事件不会等待事件处理方法的执行结果。 如果事件处理方法的执行需要一些时间，则应该使用此模式，如网络访问。 避免同时触发大量长时间运行的异步处理方法以限制并发线程的数量。 EventBus使用线程池来有效地重用已完成任务的线程。 例如： 12345// Called in a separate thread@Subscribe(threadMode = ThreadMode.ASYNC)public void onMessage(MessageEvent event){ backend.send(event.message);} 三、配置 通过EventBusBuilder，我们可以配置EventBus的各个方面。 例如，下面是如何构建一个当发送的事件没有订阅者时不报异常的EventBus 1234EventBus eventBus = EventBus.builder() .logNoSubscriberMessages(false) .sendNoSubscriberEvent(false) .build(); 另外一个例子是，如何构建一个在订阅者排除异常时报错的EventBus 1EventBus eventBus = EventBus.builder().throwSubscriberException(true).build(); 注意：默认情况下，EventBus捕获从订阅者方法抛出的异常，并发送不强制要求处理的SubscriberExceptionEvent。 使用EventBus.getDefault()是一种从应用程序的任何位置获取共享EventBus实例的简单方法。 EventBusBuilder还允许使用方法installDefaultEventBus()配置此默认实例。 例如，可以配置默认的EventBus实例来重新抛出在订阅方法中发生的异常。 但是让我们只对DEBUG构建，因为这可能会崩溃的应用程序异常 1EventBus.builder().throwSubscriberException(BuildConfig.DEBUG).installDefaultEventBus(); 注意：在第一次使用默认EventBus实例之前，只能执行一次。 后续调用installDefaultEventBus()将抛出异常。 这可确保应用程序中的行为一致。 您的应用程序类是在使用之前配置默认EventBus实例的不错地方。 ####四、粘性事件 一些事件携带在事件发布之后感兴趣的信息。 例如，事件表示某些初始化完成。 或者如果您有一些传感器或位置数据，并且想要保持最近的值。 而不是实现自己的缓存，你可以使用粘性事件。 所以EventBus保持内存中某个类型的最后一个粘性事件。 然后粘性事件可以传递给订阅者或明确地查询。 因此，您不需要任何特殊的逻辑来考虑已有的数据 粘性示例 下面表示，一个粘性事件发布了一段时间以前： 1EventBus.getDefault().postSticky(new MessageEvent(&quot;Hello everyone!&quot;)); 现在一个新的活动开始。 在注册期间，所有粘性订阅者方法将立即获得先前发布的粘性事件： 1234567891011121314151617@Overridepublic void onStart() { super.onStart(); EventBus.getDefault().register(this);} // UI updates must run on MainThread@Subscribe(sticky = true, threadMode = ThreadMode.MAIN)public void onEvent(MessageEvent event) { textField.setText(event.message);} @Overridepublic void onStop() { EventBus.getDefault().unregister(this); super.onStop();} #####手动获取和删除粘性事件 如你所见，最后一个粘性事件在注册时自动传递给匹配的订阅者。 但有时手动检查粘性事件可能会更方便。 另外，可能需要移除（消费）粘性事件才能使得它们不再被递送。 例： 1234567MessageEvent stickyEvent = EventBus.getDefault().getStickyEvent(MessageEvent.class);// Better check that an event was actually posted beforeif(stickyEvent != null) { // &quot;Consume&quot; the sticky event EventBus.getDefault().removeStickyEvent(stickyEvent); // Now do something with it} 方法removeStickyEvent是重载的：当你传入类时，它将返回先前持有的粘性事件。 使用这个变化，我们可以改进前面的例子： 12345MessageEvent stickyEvent = EventBus.getDefault().removeStickyEvent(MessageEvent.class);// Better check that an event was actually posted beforeif(stickyEvent != null) { // Now do something with it} 五、优先级和事件取消 尽管EventBus的大多数用例不需要优先级或事件取消，但在某些特殊情况下它们可能派上用场。 例如，如果应用处于前台，则事件可以触发一些UI逻辑，但如果应用当前对用户不可见，则事件可以不同地反应。 #####订阅者优先级 你可以通过在注册期间为订阅者提供优先级来更改事件传递的顺序。 1234@Subscribe(priority = 1);public void onEvent(MessageEvent event) { ...} 在相同的传递线程（ThreadMode）中，较高优先级的订阅者将在其他优先级较低的订阅者之前接收事件。 默认优先级为0。 注意：优先级不影响不同线程模式的订阅者之间的传递顺序！ 取消事件传送 你可以通过从订阅者的事件处理方法调用cancelEventDelivery（Object event）来取消事件传递过程。 任何其他活动传送将被取消，后续订阅者将不会收到活动。 12345678// Called in the same thread (default)@Subscribepublic void onEvent(MessageEvent event){ // Process the event ... // Prevent delivery to other subscribers EventBus.getDefault().cancelEventDelivery(event) ;} 事件通常由更高优先级的订阅者取消。 取消仅限于在发布线程（ThreadMode.PostThread）中运行的事件处理方法。 六、订阅者索引 订阅者索引是EventBus 3的一个新功能。它是一个可选的优化，以加速初始订阅者注册。 订阅者索引可以在构建时通过EventBus注解创建。 因为不需要使用索引，为了更好的性能建议在Android上使用。 索引前提条件 注意，只有@Subscriber方法可以索引，其中订阅者和事件类是public的。 此外，由于Java的注释处理本身的技术限制，@Subscribe注释不能在匿名类中识别。 当EventBus不能使用索引时，它会在运行时自动回退到反射。 因此，它仍然可以工作，只是有点慢。 如何生成索引 使用注解 如果你不使用Android Gradle插件版本2.2.0或更高版本，请使用配置与android-apt。 要启用索引生成，需要使用annotationProcessor属性将EventBus注释处理器添加到构建中。 还要设置参数eventBusIndex来指定要生成的索引的完全限定类。 例如，将以下部分添加到Gradle构建脚本中： 1234567891011121314android { defaultConfig { javaCompileOptions { annotationProcessorOptions { arguments = [ eventBusIndex : &apos;com.example.myapp.MyEventBusIndex&apos; ] } } }} dependencies { compile &apos;org.greenrobot:eventbus:3.0.0&apos; annotationProcessor &apos;org.greenrobot:eventbus-annotation-processor:3.0.1&apos;} 使用android-apt 如果上述方法不适用于你，你可以使用android-apt Gradle插件添加EventBus注释处理器到你的构建中。 将以下部分添加到Gradle构建脚本中： 123456789101112131415161718buildscript { dependencies { classpath &apos;com.neenbedankt.gradle.plugins:android-apt:1.8&apos; }} apply plugin: &apos;com.neenbedankt.android-apt&apos; dependencies { compile &apos;org.greenrobot:eventbus:3.0.0&apos; apt &apos;org.greenrobot:eventbus-annotation-processor:3.0.1&apos;} apt { arguments { eventBusIndex &quot;com.example.myapp.MyEventBusIndex&quot; }} 下次构建项目时（没有错误），将为您生成由eventBusIndex指定的类。 然后当设置EventBus通过它像这样： 1EventBus eventBus = EventBus.builder().addIndex(new MyEventBusIndex()).build(); 或者，如果您想在整个应用程序中使用默认实例： 123EventBus.builder().addIndex(new MyEventBusIndex()).installDefaultEventBus();// Now the default instance uses the given index. Use it like this:EventBus eventBus = EventBus.getDefault(); 索引你的开源库 你可以将相同的原则应用于作为库（而不是最终应用程序）的一部分的代码。 这样，您可能有多个索引类，您可以在EventBus设置期间添加所有索引类，例如： 123EventBus eventBus = EventBus.builder() .addIndex(new MyEventBusAppIndex()) .addIndex(new MyEventBusLibIndex()).build(); 七、ProGuard ProGuard模糊方法名称并可能删除不被调用的方法（死代码删除）。 因为Subscriber方法不是直接调用，ProGuard假定它们未被使用。 因此，如果您启用ProGuard缩减，您必须告诉Proguard保留这些Subscriber方法。 在ProGuard配置文件（proguard.cfg）中使用以下规则以防止订阅者被删除： 12345678910-keepattributes *Annotation*-keepclassmembers class ** { @org.greenrobot.eventbus.Subscribe &lt;methods&gt;;}-keep enum org.greenrobot.eventbus.ThreadMode { *; } # Only required if you use AsyncExecutor-keepclassmembers class * extends org.greenrobot.eventbus.util.ThrowableFailureEvent { &lt;init&gt;(java.lang.Throwable);} 注意：无论是否使用订户索引，您都需要此配置。 八、AsyncExecutorAsyncExecutor AsyncExecutor就像一个线程池，但是具有失败（异常）处理。 失败会抛出异常，AsyncExecutor会将这些异常包装在事件中，并自动发布。 免责声明：AsyncExecutor是一个非核心实用程序类。 它可能会在后台线程中保存一些错误处理代码，但它不是一个核心的EventBus类。 通常，调用AsyncExecutor.create（）创建一个实例并将其保存在应用程序范围中。 然后执行某些东西，实现RunnableEx接口并将其传递给AsyncExecutor的execute方法。 与Runnable不同，RunnableEx可能会抛出异常。 如果RunnableEx实现抛出异常，它将被捕获并被包装到ThrowableFailureEvent中，这将被发布。 执行部分示例： 12345678910AsyncExecutor.create().execute( new AsyncExecutor.RunnableEx() { @Override public void run() throws LoginException { // No need to catch any Exception (here: LoginException) remote.login(); EventBus.getDefault().postSticky(new LoggedInEvent()); } }); 接收部分示例： 123456789@Subscribe(threadMode = ThreadMode.MAIN)public void handleLoginEvent(LoggedInEvent event) { // do something} @Subscribe(threadMode = ThreadMode.MAIN)public void handleFailureEvent(ThrowableFailureEvent event) { // do something} AsyncExecutor Builder 如果要自定义AsyncExecutor实例，请调用静态方法AsyncExecutor.builder（）。 它将返回一个构建器，您可以自定义EventBus实例，线程池和失败事件的类。 另一个定制选项是执行范围，它提供故障事件上下文信息。 例如，失败事件可能仅与特定的Activity实例或类相关。 如果您的自定义失败事件类实现了HasExecutionScope接口，AsyncExecutor将自动设置执行范围。 像这样，您的订阅者可以查询失败事件的执行范围，并根据它做出反应。 原文出处 翻译原文： http://greenrobot.org/eventbus/","link":"/2017/02/14/《Android开源库》 EventBus 用法详解（译文）/"},{"title":"《Android开源库》 MPAndroidChart Wiki(译文)～Part 3","text":"13. 图例 默认情况下，所有的图表都支持图例并且会自动生成。给图表设置完数据之后，图例会被绘制出来。图例通常由多个条目组成，每个条目由标签形式/形状表示。 自动生成的图例包含的条目数取决于不同颜色的数量（跨所有DataSet对象）以及DataSet标签。图例的标签取决于为图表中使用的DataSet对象设置的标签。如果没有指定DataSet对象的标签，图表将自动生成。 为了自定义Legend，我们可以通过如下方式从图表中拿到Legend对象： 1Legend legend = chart.getLegend(); 13.1 控制Legend是否被绘制方法 | 使用 --------------------------- | -------------------------------- setEnabled(boolean enabled) | 设置图例禁用或者启用。如果设置为false,图例将不会被绘制出来 13.2 样式/修改图例方法 | 使用 ------------------------ | --------------- setTextColor(int color) | 设置图例标签的文本颜色 setTextSize(float size) | 设置图例标签的字体大小（dp） setTypeface(Typeface tf) | 设置图例标签的字体 13.3 换行/避免裁剪方法 | 使用 ----------------------------------- | --------------------------------------------------------------------------- setWordWrapEnabled(boolean enabled) | 如果设置为true,如果图例标签过长，将会另起一行来展示超出图表范围的内容，而不是截断它。请注意，启动后会降低性能并且这个只对处理图表下的图例标签有效 setMaxSizePercent(float maxSize) | 设置最大图例的百分比（相对整个图表大小）。默认为0.95f (95%) 13.4 自定义图例方法 | 使用 ----------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------- setPosition(LegendPosition pos) | 设置图例的显示位置。可选项：RIGHT_OF_CHART, RIGHT_OF_CHART_CENTER, RIGHT_OF_CHART_INSIDE, BELOW_CHART_LEFT, BELOW_CHART_RIGHT, BELOW_CHART_CENTER or PIECHART_CENTER (只有饼图使用这个)等等 setForm(LegendForm shape) | 设置LegendForm。这是在带有图例条目表示的DataSet的颜色的图例标签旁边绘制的形状。可选项：SQUARE，CIRCLE、LINE。 setFormSize(float size) | 设置legend-forms的大小（dp） setXEntrySpace(float space) | 设置横轴上的图例项之间的空间 setYEntrySpace(float space) | 设置垂直轴上的图例条目之间的空间 setFormToTextSpace(float space) | 设置图例标签和相应图例之间的空格 setWordWrapEnabled(boolean enabled) | 设置 Legend 是否自动换行？ 目前仅支持BelowChartLeft，BelowChartRight，BelowChartCenter. 13.5 设置自定义标签&amp;颜色方法 | 使用 ---------------------------------------- | ------------------------------------------------------------------------------------------------------------------ setCustom(int[] colors, String[] labels) | 设置自定义图例标签和颜色数组，颜色数量和标签数量相同且一一对应。这个方法将使默认的图例计算功能失效。调用resetCustom()来重新打开自动计算图例的功能(然后调用notifyDataSetChanged()来执行重新计算) resetCustom() | 调用这个方法之后自定义图例标签功能将会失效。标签将会被自动计算(调用notifyDataSetChanged()之后) setExtra(int[] colors, String[] labels) | 设置颜色数组和标签数据，颜色和标签一一对应，这些标签将会接在自动计算得到的标签之后（如果图例已经被计算出来， 我们需要调用notifyDataSetChanged()来让我们的修改生效） 13.6 示例1234567891011121314Legend l = chart.getLegend(); l.setFormSize(10f); // set the size of the legend forms/shapes l.setForm(LegendForm.CIRCLE); // set what type of form/shape should be used l.setPosition(LegendPosition.BELOW_CHART_LEFT); l.setTypeface(...); l.setTextSize(12f); l.setTextColor(Color.BLACK); l.setXEntrySpace(5f); // set the space between the legend entries on the x-axis l.setYEntrySpace(5f); // set the space between the legend entries on the y-axis // set custom labels and colors l.setCustom(ColorTemplate.VORDIPLOM_COLORS, new String[] { &quot;Set1&quot;, &quot;Set2&quot;, &quot;Set3&quot;, &quot;Set4&quot;, &quot;Set5&quot; }); // and many more... 14. 动态 &amp; 实时数据 从版本v1.6.3开始支持，持续改进中。 为了实现动态增删图表中的数据，开源库提供了大量的方法，方便我们实现图表中DataSet 数据条目的增加和删除。 14.1 动态添加/删除数据的可能性 DataSet类（和它的所有子类）： 方法 | 使用 ----------------- | ------------------ addEntry(Entry e) | 把指定Entry添加到DataSetChartData类（和它的所有子类） 方法 | 使用 ----------------------------------- | ------------------------- addEntry(Entry e, int dataSetIndex) | 把指定Entry添加到DataSet的指定索引位置 addDataSet(DataSet d) | 把指定DataSet添加到ChartData中 除此之外，还存在动态移除数据的方法，具体如下： DateSet类（和它的所有子类） 方法 | 使用 -------------------------------------- | ----------------------------------------- public boolean removeFirst() | 移除第一个Entry(索引为0)。成功返回true,失败返回false public boolean removeLast() | 移除最后一个Entry(索引为size-1)。成功返回true,失败返回false public boolean removeEntry(Entry e) | 移除指定Entry。成功返回true public boolean removeEntry(int xIndex) | 移除指定索引的Entry。成功返回true ChartData类（和它的所有子类） 方法 | 使用 -------------------------------------------------------- | ----------------------------------------------- public boolean removeEntry(Entry e, int dataSetIndex) | 移除指定索引位置DataSet中的给定Entry对象。成功则返回true public boolean removeEntry(int xIndex, int dataSetIndex) | 移除指定索引位置DataSet中的给定xIndex索引对应的Entry对象。成功则返回true public boolean removeDataSet(DataSet d) | 从ChartData中移除指定DataSet。成功则返回true public boolean removeDataSet(int index) | 从ChartData中移除指定索引位置对应的DataSet。成功则返回true 14.2 注意 在动态增加或者删除数据之后，记得调用notifyDataSetChanged() ，然后调用invalidate()来执行刷新操作。 123456789101112// EXAMPLE 1// add entries to the &quot;data&quot; objectexampleData.addEntry(...);chart.notifyDataSetChanged(); // let the chart know it&apos;s data changedchart.invalidate(); // refresh// EXAMPLE 2// add entries to &quot;dataSet&quot; objectdataSet.addEntry(...);exampleData.notifyDataChanged(); // let the data know a dataSet changedchart.notifyDataSetChanged(); // let the chart know it&apos;s data changedchart.invalidate(); // refresh 注意：像moveViewTo(…)这样的方法，将会自动调用invalidate()。 14.3 动态数据示例 有关如何实现动态数据添加/删除的示例，请参考示例应用程序和其中的如下Activity： DynamicalAddingActivity RealtimeDataActivity 15. 修改视窗 本库提供了各种方法来修改视窗（图表的可见部分）。注意，这些修改视窗的方法仅适用于LineChart, BarChart, ScatterChart和CandleStickChart。 下面提到的方法都是Chart类提供的方法。修改视窗的另一种方法是通过ViewPortHandler直接访问它（没有图表提供的中间安全性）。这仅适用于熟悉API的高级用户。 请注意，只有在设置数据之后才能调用上面这些修改视窗的方法 15.1 限制可见范围方法 | 使用 -------------------------------------------------------------------- | ---------------------------------------------------------------------------------------------------------------- setVisibleXRangeMaximum(float maxXRange) | 设置在X轴上一次性最大可见范围。如果这个值设置为10，则X轴取值超过10之外的图表在不滚动的情况是无法被看到的 setVisibleXRangeMinimum(float minXRange) | 设置在X轴上一次性能看到的最小范围，如果这个值设置成10，则不管你怎么放大，X轴的取值范围都不会小于10 setVisibleYRangeMaximum(float maxYRange, AxisDependency axis) | 设置Y轴上一次性最大可见范围。通过AxisDependency明确对应的Y轴 setViewPortOffsets(float left, float top, float right, float bottom) | 设置当前视窗的自定义偏移量（实际图表窗口侧面的偏移量），设置这个值将阻止图表自动计算其偏移量。使用resetViewPortOffsets()方法来恢复自动计算偏移量的功能。注意，如果你不知道这个是干什么的，请先搞清楚再使用 resetViewPortOffsets() | 重置所有setViewPortOffsets(…)设置的偏移量。允许图表自动计算所有偏移量 setExtraOffsets(float left, float top, float right, float bottom) | 在自动计算的偏移量的基础上增加额外的偏移量。这个方法不会改变自动计算的偏移量结果，只是在其基础上追加 15.2 移动视图方法 | 使用 ------------------------------------------------------------- | ----------------------------------------------------------------------------------------- fitScreen() | 重设所有缩放和拖动，使图表完全适合它的边界（完全缩小） moveViewToX(float xValue) | 将当前视窗的左侧（边）到指定的 x 值 moveViewToY(float yValue, AxisDependency axis) | 使得指定的y值显示在对应y轴( 左or右 )的中间 moveViewTo(float xValue, float yValue, AxisDependency axis) | 将当前视窗的左侧移动到x轴上的指定x值，并将视窗居中到所提供的y轴上的指定y值，相当于setVisibleXRange(…) 和 setVisibleYRange(…) 组合使用 centerViewTo(float xValue, float yValue, AxisDependency axis) | 将使当前视窗的中心移动到指定的x值和y值相当于 setVisibleXRange(…) 和 setVisibleYRange(…) 组合使用 15.3 移动视图动画方法 | 使用 ------------------------------------------------------------------------------------ | ------------------------------- moveViewToAnimated(float xValue, float yValue, AxisDependency axis, long duration) | 和上面moveViewTo结果一样，只是这个过程有动画效果 centerViewToAnimated(float xValue, float yValue, AxisDependency axis, long duration) | 和上面centerViewTo结果一样，只是这个过程有动画效果 15.4 缩放方法 | 使用 ----------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------- zoomIn() | 以图表中心为中心点，1.4倍步幅放大 zoomOut() | 以图表中心为中心点，0.7倍步幅缩小 zoom(float scaleX, float scaleY, float x, float y) | 根据所给的参数进行放大或缩小。 参数 x 和 y 是变焦中心的坐标（单位：像素）。 记住，1f = 无放缩 。 zoomAndCenterAnimated(float scaleX, float scaleY, float xValue, float yValue, AxisDependency axis, long duration) | 按照给定的缩放因子进行缩放，并将视图中心移动到指定位置（带动画） 15.5 完整示例123456chart.setData(...); // first set data// now modify viewportchart.setVisibleXRangeMaximum(20); // allow 20 values to be displayed at once on the x-axis, not morechart.moveViewToX(10); // set the left edge of the chart to x-index 10// moveViewToX(...) also calls invalidate()","link":"/2017/06/16/《Android开源库》 MPAndroidChart Wiki(译文)～Part 3/"},{"title":"《Android开源库》 PagerSlidingTabStrip从头到脚","text":"版权声明：本文为博主原创文章，未经博主允许不得转载。 https://blog.csdn.net/poorkick/article/details/53868426 简介 PagerSlidingTabStrip，是我个人经常使用到的一个和ViewPager配合的页面指示器，可以满足开发过程中常用的需求，如类似于今日头条的首页新闻内容导航栏等等，之前自己开发的JuheNews和正在开发的GankIOClient均有使用到它，所以想对其进行一个全面的介绍。 PagerSlidingTabStrip源码地址： https://github.com/astuetz/PagerSlidingTabStrip 简单使用 添加库依赖 123dependencies { compile &apos;com.astuetz:pagerslidingtabstrip:1.0.1&apos;} 定义布局文件 123456789&lt;com.astuetz.PagerSlidingTabStrip android:id=&quot;@+id/psts_indicator&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;40dp&quot;/&gt;&lt;android.support.v4.view.ViewPager android:id=&quot;@+id/vp_content&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot;/&gt; 关联ViewPager 12345678910111213141516171819public class MainActivity extends AppCompatActivity { @BindView(R.id.psts_indicator) PagerSlidingTabStrip pstsIndicator; @BindView(R.id.activity_main) LinearLayout activityMain; @BindView(R.id.vp_content) ViewPager vpContent; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); ButterKnife.bind(this); MainPagerAdapter mainPagerAdapter = new MainPagerAdapter(getSupportFragmentManager()); vpContent.setAdapter(mainPagerAdapter); pstsIndicator.setViewPager(vpContent); }} 结果 后话 看到这个效果，是不是很炸裂，如此的丑陋，上图是什么属性都没有修改默认的效果图，接着我们看下源码，看下可以从哪方面来进行改造。 源码解析 这个开源库，简单点说就是大家都非常熟悉的自定义View，所以，解读的方式可以从自定义属性到此视图的构造，onMeasure,onLayout, onDraw等等 自定义的属性值 123456789101112131415161718192021222324252627&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;resources&gt; &lt;declare-styleable name=&quot;PagerSlidingTabStrip&quot;&gt; &lt;!--底部滑动指示器的颜色--&gt; &lt;attr name=&quot;pstsIndicatorColor&quot; format=&quot;color&quot; /&gt; &lt;!--底部用于给指示器滑动的区域的颜色--&gt; &lt;attr name=&quot;pstsUnderlineColor&quot; format=&quot;color&quot; /&gt; &lt;!--分割线的颜色--&gt; &lt;attr name=&quot;pstsDividerColor&quot; format=&quot;color&quot; /&gt; &lt;!--指示器的高度--&gt; &lt;attr name=&quot;pstsIndicatorHeight&quot; format=&quot;dimension&quot; /&gt; &lt;!--底部区域的高度--&gt; &lt;attr name=&quot;pstsUnderlineHeight&quot; format=&quot;dimension&quot; /&gt; &lt;!--分割线与上下的间距--&gt; &lt;attr name=&quot;pstsDividerPadding&quot; format=&quot;dimension&quot; /&gt; &lt;!--每个Tab的左右边距--&gt; &lt;attr name=&quot;pstsTabPaddingLeftRight&quot; format=&quot;dimension&quot; /&gt; &lt;!--选中tab的滚动偏移量,个人基本没有用到过--&gt; &lt;attr name=&quot;pstsScrollOffset&quot; format=&quot;dimension&quot; /&gt; &lt;!--每个Tab的背景图，StateListDrawable--&gt; &lt;attr name=&quot;pstsTabBackground&quot; format=&quot;reference&quot; /&gt; &lt;!--是否根据tab均为位置，true的时候均分，默认为false,一般都是使用默认值--&gt; &lt;attr name=&quot;pstsShouldExpand&quot; format=&quot;boolean&quot; /&gt; &lt;!--标题文本是否大写，默认为true--&gt; &lt;attr name=&quot;pstsTextAllCaps&quot; format=&quot;boolean&quot; /&gt; &lt;/declare-styleable&gt;&lt;/resources&gt; 看下大致的布局和属性对号入座 PagerSlidingTabStrip.java类结构 类中的getter和setter方法，基本上和上面的自定义属性可以对上号，不仅可以在布局文件中定义，还可以通过java代码进行设置。 类中使用到的变量，大部分都是和自定义属性挂钩的，主要关注几个 变量 | 意义 -------------------- | --------------------------------------------------------------------------------------- ATTRS | 引用Android系统的两个属性，文本字体大小和字体颜色 pageListener | 内部使用的OnPagerChangeListener,通过setViewPager实现和ViewPager的联动 delegatePageListener | 暴露给开发者的接口，类本身使用到了两个OnPageChangeListener，一个用来实现自己的逻辑，而这个则是留给开发者实现自己需要针对ViewPager的页面变化的逻辑 tabsContainer | 内部容器，用户所见文本指示器和图标指示器的父节点，所以，如果需要针对文本指示器或者是图标指示器做什么操作，通过这个查找孩子节点即可 IconTabProvider 类中比较关键的一些内容，接口IconTabProvider，ViewPager对应的Adapter实现该方法并返回每个ViewPager对应的图标即可实现图标指示器。 PageListener &lt;用户自定义的OnPagerListener的事件处理集成于此处&gt; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162private class PageListener implements OnPageChangeListener { @Override public void onPageScrolled(int position, float positionOffset, int positionOffsetPixels) { //存储当前位置信息 currentPosition = position; currentPositionOffset = positionOffset; //滑动到子视图 scrollToChild(position, (int) (positionOffset * tabsContainer.getChildAt(position).getWidth())); invalidate();//触发重绘 //用户自定义的OnPagerChangeListener事件之onPagerScrolled if (delegatePageListener != null) { delegatePageListener.onPageScrolled(position, positionOffset, positionOffsetPixels); } } @Override public void onPageScrollStateChanged(int state) { //已经滑动完成，offset归0 if (state == ViewPager.SCROLL_STATE_IDLE) { scrollToChild(pager.getCurrentItem(), 0); } //用户自定义的OnPagerChangeListener事件之onPageScrollStateChanged if (delegatePageListener != null) { delegatePageListener.onPageScrollStateChanged(state); } } @Override public void onPageSelected(int position) { //这里类内部没有做什么处理，只处理用户自定义的OnPagerSelected方法 if (delegatePageListener != null) { delegatePageListener.onPageSelected(position); } }}/** *滑动指定子视图 */ private void scrollToChild(int position, int offset) { if (tabCount == 0) { return; } int newScrollX = tabsContainer.getChildAt(position).getLeft() + offset; if (position &gt; 0 || offset &gt; 0) { newScrollX -= scrollOffset; } if (newScrollX != lastScrollX) { lastScrollX = newScrollX; scrollTo(newScrollX, 0); }} PagerSlidingTabStrip构造方法 构造方法的内容不多，基本上全是基本属性的获取，自定义View中常用的TypedArray ，记得回收recycle()，这里关注一下 TypedValue.applyDimension方法的使用，全部转换成px。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465public PagerSlidingTabStrip(Context context, AttributeSet attrs, int defStyle) { super(context, attrs, defStyle); setFillViewport(true); setWillNotDraw(false); tabsContainer = new LinearLayout(context); tabsContainer.setOrientation(LinearLayout.HORIZONTAL); tabsContainer.setLayoutParams(new LayoutParams(LayoutParams.MATCH_PARENT, LayoutParams.MATCH_PARENT)); addView(tabsContainer); DisplayMetrics dm = getResources().getDisplayMetrics(); scrollOffset = (int) TypedValue.applyDimension(TypedValue.COMPLEX_UNIT_DIP, scrollOffset, dm); indicatorHeight = (int) TypedValue.applyDimension(TypedValue.COMPLEX_UNIT_DIP, indicatorHeight, dm); underlineHeight = (int) TypedValue.applyDimension(TypedValue.COMPLEX_UNIT_DIP, underlineHeight, dm); dividerPadding = (int) TypedValue.applyDimension(TypedValue.COMPLEX_UNIT_DIP, dividerPadding, dm); tabPadding = (int) TypedValue.applyDimension(TypedValue.COMPLEX_UNIT_DIP, tabPadding, dm); dividerWidth = (int) TypedValue.applyDimension(TypedValue.COMPLEX_UNIT_DIP, dividerWidth, dm); tabTextSize = (int) TypedValue.applyDimension(TypedValue.COMPLEX_UNIT_SP, tabTextSize, dm); // get system attrs (android:textSize and android:textColor) TypedArray a = context.obtainStyledAttributes(attrs, ATTRS); tabTextSize = a.getDimensionPixelSize(0, tabTextSize); tabTextColor = a.getColor(1, tabTextColor); a.recycle(); // get custom attrs a = context.obtainStyledAttributes(attrs, R.styleable.PagerSlidingTabStrip); indicatorColor = a.getColor(R.styleable.PagerSlidingTabStrip_pstsIndicatorColor, indicatorColor); underlineColor = a.getColor(R.styleable.PagerSlidingTabStrip_pstsUnderlineColor, underlineColor); dividerColor = a.getColor(R.styleable.PagerSlidingTabStrip_pstsDividerColor, dividerColor); indicatorHeight = a.getDimensionPixelSize(R.styleable.PagerSlidingTabStrip_pstsIndicatorHeight, indicatorHeight); underlineHeight = a.getDimensionPixelSize(R.styleable.PagerSlidingTabStrip_pstsUnderlineHeight, underlineHeight); dividerPadding = a.getDimensionPixelSize(R.styleable.PagerSlidingTabStrip_pstsDividerPadding, dividerPadding); tabPadding = a.getDimensionPixelSize(R.styleable.PagerSlidingTabStrip_pstsTabPaddingLeftRight, tabPadding); tabBackgroundResId = a.getResourceId(R.styleable.PagerSlidingTabStrip_pstsTabBackground, tabBackgroundResId); shouldExpand = a.getBoolean(R.styleable.PagerSlidingTabStrip_pstsShouldExpand, shouldExpand); scrollOffset = a.getDimensionPixelSize(R.styleable.PagerSlidingTabStrip_pstsScrollOffset, scrollOffset); textAllCaps = a.getBoolean(R.styleable.PagerSlidingTabStrip_pstsTextAllCaps, textAllCaps); a.recycle(); /* 初始化矩形Paint */ rectPaint = new Paint(); rectPaint.setAntiAlias(true); rectPaint.setStyle(Style.FILL); /* 初始化分割线Paint */ dividerPaint = new Paint(); dividerPaint.setAntiAlias(true); dividerPaint.setStrokeWidth(dividerWidth); /* 是否延伸，默认WRAP_CONTENT,这种比较合理 */ defaultTabLayoutParams = new LinearLayout.LayoutParams(LayoutParams.WRAP_CONTENT, LayoutParams.MATCH_PARENT); expandedTabLayoutParams = new LinearLayout.LayoutParams(0, LayoutParams.MATCH_PARENT, 1.0f); if (locale == null) { locale = getResources().getConfiguration().locale; }} onDraw 12345678910111213141516171819202122232425262728293031323334353637383940414243@Overrideprotected void onDraw(Canvas canvas) { super.onDraw(canvas); if (isInEditMode() || tabCount == 0) { return; } final int height = getHeight(); // 设置Indicator颜色 rectPaint.setColor(indicatorColor); // 获取当前选中Tab View currentTab = tabsContainer.getChildAt(currentPosition); //获取Left,Right值 float lineLeft = currentTab.getLeft(); float lineRight = currentTab.getRight(); // if there is an offset, start interpolating left and right coordinates between current and next tab if (currentPositionOffset &gt; 0f &amp;&amp; currentPosition &lt; tabCount - 1) { //结合下一个Tab获取当前要绘制的indicator的位置,这里的currentPositionOffset 比较关键，可以看到这个值是与ViewPager相关的，在onPagerScrolled方法中，这个值在不断的更新 View nextTab = tabsContainer.getChildAt(currentPosition + 1); final float nextTabLeft = nextTab.getLeft(); final float nextTabRight = nextTab.getRight(); lineLeft = (currentPositionOffset * nextTabLeft + (1f - currentPositionOffset) * lineLeft); lineRight = (currentPositionOffset * nextTabRight + (1f - currentPositionOffset) * lineRight); } // 绘制Indicator canvas.drawRect(lineLeft, height - indicatorHeight, lineRight, height, rectPaint); // 绘制UnderLine rectPaint.setColor(underlineColor); canvas.drawRect(0, height - underlineHeight, tabsContainer.getWidth(), height, rectPaint); // 绘制分割线 dividerPaint.setColor(dividerColor); for (int i = 0; i &lt; tabCount - 1; i++) { View tab = tabsContainer.getChildAt(i); canvas.drawLine(tab.getRight(), dividerPadding, tab.getRight(), height - dividerPadding, dividerPaint); }} setViewPager， setOnPageChangeListener 一个用来与ViewPager联动，一个用来处理自定义的OnPagerListener逻辑 123456789101112131415public void setViewPager(ViewPager pager) { this.pager = pager; if (pager.getAdapter() == null) { throw new IllegalStateException(&quot;ViewPager does not have adapter instance.&quot;); } pager.setOnPageChangeListener(pageListener); notifyDataSetChanged(); } public void setOnPageChangeListener(OnPageChangeListener listener) { this.delegatePageListener = listener; } PagerSlidingTabStrip综合用法 文本指示器选中后文本大小和颜色变化 关键点在于实现自己的OnPagerListener 12345678910111213141516171819202122232425262728293031323334353637383940@Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); ButterKnife.bind(this); MainPagerAdapter mainPagerAdapter = new MainPagerAdapter(getSupportFragmentManager()); vpContent.setAdapter(mainPagerAdapter); pstsIndicator.setViewPager(vpContent); vpContent.addOnPageChangeListener(new ViewPager.OnPageChangeListener() { @Override public void onPageScrolled(int position, float positionOffset, int positionOffsetPixels) { } @Override public void onPageSelected(int position) { updateTextStyle(position); } @Override public void onPageScrollStateChanged(int state) { } }); updateTextStyle(vpContent.getCurrentItem()); } private void updateTextStyle(int position) { LinearLayout tabsContainer = (LinearLayout) pstsIndicator.getChildAt(0); for(int i=0; i&lt; tabsContainer.getChildCount(); i++) { TextView textView = (TextView) tabsContainer.getChildAt(i); if(position == i) { textView.setTextSize(18); textView.setTextColor(getResources().getColor(R.color.colorToolbar)); } else { textView.setTextSize(12); textView.setTextColor(getResources().getColor(R.color.colorBlack)); } } } 图标指示器选中图标颜色变化 关键点在于实现自己的OnPagerListener和继承PagerSlidingTabStrip.IconTabProvider 123456789101112private void updateIconStyle(int position) { LinearLayout tabsContainer = (LinearLayout) pstsIndicator.getChildAt(0); for (int i = 0; i &lt; tabsContainer.getChildCount(); i++) { ImageButton imageButton = (ImageButton) tabsContainer.getChildAt(i); imageButton.setImageTintMode(PorterDuff.Mode.SRC_IN); if (i == position) { imageButton.setImageTintList(getResources().getColorStateList(R.color.ib_color_list)); } else { imageButton.setImageTintList(getResources().getColorStateList(R.color.ib_color_list_normal)); } }} 写在最后的话PagerSlidingTabStrip，总体来说简洁方便，如果开发者想集成自己的一些内容，比如说Indicator改成其他的形状，或者说想做到既有文字又有图片的效果，都可以自己修改代码来实现，比较的方便。 祝大家圣诞快乐。 Ending ~","link":"/2016/12/25/《Android开源库》 PagerSlidingTabStrip从头到脚/"},{"title":"《Android开源库》 Realm For Android~ Queries（译文）","text":"查询 Realm 中的所有读取（包括查询）操作都是延迟执行的，且数据绝不会被拷贝。 Realm 的查询引擎使用 Fluent interface 来构造多条件查询。 使用 User 类 - 1234567891011121314151617public class User extends RealmObject { @PrimaryKey private String name; private int age; @Ignore private int sessionId; // Standard getters &amp; setters generated by your IDE… public String getName() { return name; } public void setName(String name) { this.name = name; } public int getAge() { return age; } public void setAge(int age) { this.age = age; } public int getSessionId() { return sessionId; } public void setSessionId(int sessionId) { this.sessionId = sessionId; }} 比如查找所有叫做 John 或 Peter 的用户，你可以这么写： 12345678910111213141516// Build the query looking at all users:RealmQuery&lt;User&gt; query = realm.where(User.class);// Add query conditions:query.equalTo(&quot;name&quot;, &quot;John&quot;);query.or().equalTo(&quot;name&quot;, &quot;Peter&quot;);// Execute the query:RealmResults&lt;User&gt; result1 = query.findAll();// Or alternatively do the same all at once (the &quot;Fluent interface&quot;):RealmResults&lt;User&gt; result2 = realm.where(User.class) .equalTo(&quot;name&quot;, &quot;John&quot;) .or() .equalTo(&quot;name&quot;, &quot;Peter&quot;) .findAll(); 这个查询将返回一个包含名为John或者Peter的人的RealmResults实例。在findAll()方法被调用的时候，查询操作就执行了。findAll()是findAll家族的一员，例如findAllSorted()将返回一个排序后的结果集；findAllAsync()将在后台线程中执行异步查询。具体详情请阅API指南。 这些对象并非拷贝，也就是说你得到的是一个匹配对象引用的列表，你对匹配对象所有的操作都是直接施加于它的原始对象。RealmResults 继承自 Java 的 AbstractList，行为类似。例如你可以通过 index 来访问其中的某个对象。 当查询没有任何匹配时，返回的 RealmResults 对象将不会为 null，取而代之的是它的 size() 方法将返回 0。 修改或删除 RealmResults 中任何一个对象都必须在写入事务中完成。 你也可以查询关系. 查询条件 使用where()方法构建一个由RealmQuery 对象代表的查询。一旦构建了RealmQuery ，你可以使用各种各样的谓词来过滤查询得到的数据。大多数谓词意义从字面上都能看出来。 谓词的第一个参数是字段名。 如果字段的类型不支持谓词，则抛出异常。 有关详细信息，请参阅RealmQuery的API参考。 对于所有数据类型，你有以下谓词： equalTo() notEqualTo() 要将字段与值列表匹配，请使用in（）。 例如，要查找名称“Jill”，“William”或“Trillian”，您可以在（“name”，new String [] {“Jill”，“William”，“Trillian”}中使用。 in（）谓词适用于字符串，二进制数据和数字字段。 数字数据类型（包括日期）允许这些附加谓词： between() (两个端点会被包含在内, 即，有界间隔) greaterThan() lessThan() greaterThanOrEqualTo() lessThanOrEqualTo() 字符串字段允许如下附加谓词： contains() beginsWith() endsWith() like() 所有四个字符串谓词都有可选的第三个参数，用于控制大小写区分。 将其设置为Case.INSENSITIVE以在匹配时忽略大小写，或者将Case.SENSITIVE设置为执行区分大小写匹配。 默认值为Case.SENSITIVE。 谓词like（）执行glob样式通配符匹配。 匹配模式由字符和一个或多个通配符组成： 匹配0个或多个Unicode字符 ？匹配1个Unicode字符 例如，考虑一个有四个对象的Realm，名为name的字段，其值有William，Bill，Jill和Trillian。 类似于（“name”，“？ill ”）的谓词将匹配前三个对象，类似（“name”，“ ia？”）将匹配第一个和最后一个对象。 二进制数据，字符串和RealmObject（RealmList）的列表可以是空的，即具有零的长度。 如下是检查是否为空的谓词： isEmpty() isNotEmpty() 如果不是必填字段，则值可以为null（记住，RealmObjects字段不是必填，值可以为null）。 用于匹配空值的两个有用谓词是： isNull() isNotNull() 逻辑运算符 每个查询条件都会被被隐式地被逻辑和（&amp;）组合在一起，而逻辑或（or）需要显式地去执行 or()。 使用 User 类 - 1234567891011121314151617public class User extends RealmObject { @PrimaryKey private String name; private int age; @Ignore private int sessionId; // Standard getters &amp; setters generated by your IDE… public String getName() { return name; } public void setName(String name) { this.name = name; } public int getAge() { return age; } public void setAge(int age) { this.age = age; } public int getSessionId() { return sessionId; } public void setSessionId(int sessionId) { this.sessionId = sessionId; }} 你也可以将查询条件组合在一起，使用 beginGroup()（相当于左括号）和 endGroup()（相当于右括号）： 12345678RealmResults&lt;User&gt; r = realm.where(User.class) .greaterThan(&quot;age&quot;, 10) // implicit AND .beginGroup() .equalTo(&quot;name&quot;, &quot;Peter&quot;) .or() .contains(&quot;name&quot;, &quot;Jo&quot;) .endGroup() .findAll(); 此外，也可以用 not() 否定一个条件。该 not() 运算符可以与 beginGroup()/endGroup() 一起使用来否定子条件。假如说你想查询名字不是“Peter”或者“Jo.”的User。查询方式如下： 12345678RealmResult&lt;User&gt; r = realm.where(User.class) .not() .beginGroup() .equalTo(&quot;name&quot;, &quot;Peter&quot;) .or() .contains(&quot;name&quot;, &quot;Jo&quot;) .endGroup() .findAll(); 当然，对于这种特定的查询，使用in()更为简洁： 1234RealmResult&lt;User&gt; r = realm.where(User.class) .not() .in(&quot;name&quot;, new String[]{&quot;Peter&quot;, &quot;Jo&quot;}) finalAll(); 排序 当你执行完查询获得结果后，可以对它进行排序： 123RealmResults&lt;User&gt; result = realm.where(User.class).findAll();result = result.sort(&quot;age&quot;); // Sort ascendingresult = result.sort(&quot;age&quot;, Sort.DESCENDING); 排序默认为升序; 使用Sort.DESCENDING作为第二个可选参数可以修改为降序。 可以同时使用多个字段进行排序。 唯一值 使用distinct（）谓词仅返回唯一值。 例如，要了解你的Realm中有多少不同的名字： 1RealmResults&lt;Person&gt; unique = realm.where(Person.class).distinct(&quot;name&quot;); 只支持整数和字符串字段; 如果你尝试使用distinct（）不支持的字段类型，将抛出异常。 与排序一样，你可以指定多个字段。 链式查询 因为查询结果并不会被复制，且在查询提交时并不会被执行，你可以链式串起查询并逐步进行分类筛选： 12RealmResults&lt;Person&gt; teenagers = realm.where(Person.class).between(&quot;age&quot;, 13, 20).findAll();Person firstJohn = teenagers.where().equalTo(&quot;name&quot;, &quot;John&quot;).findFirst(); 你也可以在子对象上使用链式查询。假设以上 Person 对象包含一个 Dog 对象列表： 1234567891011public class Dog extends RealmObject { private int age; // getters &amp; setters ...}public class Person extends RealmObject { private int age; private RealmList&lt;Dog&gt; dogs; // getters &amp; setters ...} 你可以查询找出所有年龄在 13 和 20 之间的 Person 并且他至少拥有一个 1 岁的 Dog： 1RealmResults&lt;Person&gt; teensWithPups = realm.where(Person.class).between(&quot;age&quot;, 13, 20).equalTo(&quot;dogs.age&quot;, 1).findAll(); 请注意，查询链最终是建立在 RealmResults 上而非 RealmQuery。如果你在某存在的 RealmQuery 上添加更多的查询条件，那么你在修改查询本身，而非查询链。请参考关联查询。 查询结果的自动更新（Auto-Updating Results） RealmResults 是对其所包含数据的实时、自动更新视图，这意味着它永远不需要被重新查询获取。数据对象的改变会在下一次 Looper 事件中被反映到相应的查询结果。 1234567891011121314151617181920final RealmResults&lt;Dog&gt; puppies = realm.where(Dog.class).lessThan(&quot;age&quot;, 2).findAll();puppies.size(); // =&gt; 0realm.executeTransaction(new Realm.Transaction() { @Override void public execute(Realm realm) { Dog dog = realm.createObject(Dog.class); dog.setName(&quot;Fido&quot;); dog.setAge(1); }});puppies.addChangeListener(new RealmChangeListener() { @Override public void onChange(RealmResults&lt;Dog&gt; results) { // results and puppies point are both up to date results.size(); // =&gt; 1 puppies.size(); // =&gt; 1 }}); 这对所有的 RealmResults 有效 —— 无论是否有过滤条件、是否是链式查询。 RealmResults 的这个特性不仅使得 Realm 快速高效，而且让你的代码更简洁。举例来说，假设你的 Activity 或者 Fragment 依赖于某个查询结果，你可以将相应的 Realm 对象或者 RealmResults 保存为一个属性，你不需要在每次访问时确定其是否被更新 —— Realm 会保证这些。 你可以通过订阅 Realm notifications 来得知 Realm 数据更新了，进而刷新 UI 而不必重新查询获得 RealmResults。 因为查询结果的自动更新特性，请不要依赖于固定的索引（indices）、不变的条目数。 按类型检索对象 从 Realm 中检索对象的最基本方法是 realm.where(Foo.class).findAll()，它返回了包含被查询模型类的所有对象的 RealmResults。 另外还有提供排序功能的 findAll()。参见 realm.where(Foo.class).findAllSorted() 了解详情。 聚合 RealmResult 自带一些聚合方法： 1234567RealmResults&lt;User&gt; results = realm.where(User.class).findAll();long sum = results.sum(&quot;age&quot;).longValue();long min = results.min(&quot;age&quot;).longValue();long max = results.max(&quot;age&quot;).longValue();double average = results.average(&quot;age&quot;);long matches = results.size(); 迭代 可以这样遍历 RealmResults： 1234RealmResults&lt;User&gt; results = realm.where(User.class).findAll();for (User u : results) { // ... do something with the object ...} 或者使用 for 循环： 12345RealmResults&lt;User&gt; results = realm.where(User.class).findAll();for (int i = 0; i &lt; results.size(); i++) { User u = results.get(i); // ... do something with the object ...} RealmResults 的自动更新会通过 looper 事件触发，但在事件到来之前，某些元素有可能不再满足查询条件或者其已被删除。 123456789101112final RealmResults&lt;User&gt; users = getUsers();realm.executeTransaction(new Realm.Transaction() { @Override public void execute(Realm realm) { users.get(0).deleteFromRealm(); // indirectly delete object }});for (User user : users) { showUser(user); // Will crash for the deleted user} 为避免该问题，可以使用 RealmResults 的 deleteFromRealm() 方法： 123456789101112final RealmResults&lt;User&gt; users = getUsers();realm.executeTransaction(new Realm.Transaction() { @Override public void execute(Realm realm) { users.deleteFromRealm(0); // Delete and remove object directly }});for (User user : users) { showUser(user); // Deleted user will not be shown} 删除 你可以从查询结果中删除数据： 12345678910111213141516171819// obtain the results of a queryfinal RealmResults&lt;Dog&gt; results = realm.where(Dog.class).findAll();// All changes to data must happen in a transactionrealm.executeTransaction(new Realm.Transaction() { @Override public void execute(Realm realm) { // remove single match results.deleteFirstFromRealm(); results.deleteLastFromRealm(); // remove a single object Dog dog = results.get(5); dog.deleteFromRealm(); // Delete all matches results.deleteAllFromRealm(); }}); 异步查询（Asynchronous Queries） 可以使用后台线程进行查询。 Realm 的大部分查询都非常快——快到可以使用在UI线程中而感觉不到延迟。但如果需要进行非常复杂的查询或者在大量数据中进行查询，那么使用后台线程进行查询将会是一个不错的主意。 示例：查找名字为 “John” 或者 “Peter” 的用户。 创建异步查询 12345RealmResults&lt;User&gt; result = realm.where(User.class) .equalTo(&quot;name&quot;, &quot;John&quot;) .or() .equalTo(&quot;name&quot;, &quot;Peter&quot;) .findAllAsync(); 请注意，这里的调用并不会阻塞，而是立即返回一个 RealmResults。这很类似于标准 Java 中 Future 的概念。查询将会在后台线程中被执行，当其完成时，之前返回的 RealmResults 实例会被更新。 如果你希望当查询完成、RealmResults 被更新时获得通知，你可以注册一个 RealmChangeListener。这个监听器会在 RealmResults 被更新时被调用（通常是在事务被提交后）。 注册回调1234567891011private RealmChangeListener callback = new RealmChangeListener&lt;RealmResults&lt;User&gt;&gt;() { @Override public void onChange(RealmResults&lt;User&gt; results) { // called once the query complete and on every update }};public void onStart() { RealmResults&lt;User&gt; result = realm.where(User.class).findAllAsync(); result.addChangeListener(callback);} 请在退出 Activity 或者 Fragment 时移除监听器的注册以避免内存泄漏。 123456public void onStop () { result.removeChangeListener(callback); // remove a particular listener // or result.removeChangeListeners(); // remove all registered listeners} 检查查询是否完成1234RealmResults&lt;User&gt; result = realm.where(User.class).findAllAsync();if (result.isLoaded()) { // Results are now available} 同步查询返回的 RealmResults 实例的 isLoaded 方法会永远返回 true。 强制装载异步查询 你可以选择性地等待异步查询完成，而这将会阻塞当前线程，使查询变成同步（与 Future.get() 类似的概念）。 12RealmResults&lt;User&gt; result = realm.where(User.class).findAllAsync();result.load() // be careful, this will block the current thread until it returns 非 Looper 线程 你可以在 Looper 线程中使用异步查询。异步查询需要使用 Handler 来传递查询结果。在没有 Looper 的线程中使用异步查询会导致 IllegalStateException 异常被抛出。 原文链接 https://realm.io/docs/java/latest/#queries","link":"/2017/03/06/《Android开源库》 Realm For Android~ Queries（译文）/"},{"title":"《Android 基础（四十九）》Navigation Of JetPack【译】","text":"原文地址: https://developer.android.google.cn/topic/libraries/architecture/navigation/ 介绍 Jetpack是Android软件组件的集合，可以使你更轻松地开发出色的Android应用程序。这些组件可帮助你遵循最佳实践，免除编写样板代码并简化复杂任务，因此你可以专注于开发者更关系的业务代码。Jetpack包含androidx.*库中，与平台API分开。这意味着它提供向后兼容性并且比Android平台更频繁地更新，确保你始终可以访问最新和最好的Jetpack组件版本。 Navigation组件简化了Android应用程序中导航的实现。 Navigation原则 任何应用内导航的目标应该是为用户提供一致且可预测的体验。为了实现这一目标，Navigation架构组件可帮助你构建符合以下每个导航原则的应用程序。 应用具有固定的起点 应用应该具有固定起点，即用户从启动器启动应用时看到的界面。此起点也应该是用户在按下后退按钮后返回启动器时看到的最后一个界面。 应用可能存在第一次使用时的设置界面或者登陆界面，这种特殊性的界面不应该被视为应用的起点。 堆栈用来代表应用的“导航状态” 应用的导航状态应使用后进先出的结构表示。此“导航堆栈”中堆栈底部为应用程序的起始界面，而栈顶为当前界面。 改变此堆栈的操作必须全部集中在栈顶，要么“pushing”一个新的目标到栈顶，要们从栈顶“poping”一个目标出栈。 “向上”按钮永远不会退出应用 起点界面中不应该出现向上按钮。当应用是通过其他应用使用deeplink的方式启动时，向上按钮应该将用户带回上层界面而不是当时启动此应用的其他应用。 Up和Back在应用程序任务中是等效的 当系统返回键不会导致应用程序退出时，如在应用程序的任务栈中，当前用户不处于起点界面，这个时候系统返回键就不会退出应用。这种情况下呢，我们的Up按钮操作应该和系统返回键的操作效果相同。 DeepLink或者Navigate至相同界面生成相同的堆栈 用户可以在起始界面进入应用程序并导航到一个目标界面。如果可以的话，用户同样可以通过deeplink，跳转到相同的目标界面。上面这两种情况下，针对目标界面，我们应该产生相同的目标堆栈。说白了就是，无论他们如何到达目标界面，用户应该能够使用“Back”或“Up”按钮，都可以在目标界面导航回到起始界面。清除已有导航栈，取而代之的是deeplink的导航栈。 使用Navigation架构组件实现导航 Navigation架构组件简化了应用中_destinations_之间导航的实现。一组目标界面组成应用程序的_navigation graph_。 目的地是你可以在应用中导航到的任何位置。虽然目标通常是代表特定屏幕的Fragment，但Navigation架构组件支持其他目标类型： Activity 导航图和子图 - 当目标是导航图或子图时，导航到该图或子图的起始目标 自定义目标类型 除目标之外，导航图还在称为_actions_的目标之间建立连接。图1显示了一个示例应用程序的导航图的直观表示，该应用程序包含由5个操作连接的6个目标。 项目中构建Navigation 在创建导航图之前，必须为项目配置导航架构组件。要在Android Studio中设置项目，请执行以下步骤： 如果使用Beta，Release Candidate或Stable构建，则必须启用导航编辑器。点击File &gt; Settings(Android Studio &gt; Preferenceson Mac)，在左侧菜单中选择Experimental，然后勾选Enable Navigation Editor并且重启Android Studio。 在应用或者模块的build.gradle中添加Navigation组件 123456789dependencies { def nav_version = &quot;1.0.0-alpha06&quot; implementation &quot;android.arch.navigation:navigation-fragment:$nav_version&quot; // use -ktx for Kotlin implementation &quot;android.arch.navigation:navigation-ui:$nav_version&quot; // use -ktx for Kotlin // optional - Test helpers androidTestImplementation &quot;android.arch.navigation:navigation-testing:$nav_version&quot; // use -ktx for Kotlin} 项目工程窗口，右键点击res目录并且选择New &gt; Android Resource File。New Resource File对话框出现。 在输入框中键入一个File name，如“nav_graph”。 在Resource type下拉框中选择Navigation。 点击OK后，将进行下列操作 navigation目录将出现在res目录下 nav_graph.xml文件将被创建于navigation目录下 nav_graph.xml将被导航编辑器打开。这个xml文件中包含你的导航视图。 点击Text切换到xml文本视图。一个空的导航视图如下： 12 &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;navigation xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt; 点击**Design**切换到导航编辑视图。 12345678910111213141516171819202122232425262728293031323334## []()看看导航编辑器 在导航编辑器中，你可以快速构建导航图，而不是手动构建图形的XML。如下图所示，导航编辑器有三个部分： ![alt](http://www.onlyloveyd.cn/upload/2018/10/qkqqribmrihonp7t4bj1s11mn8.png) 导航编辑器的三部分如下： 2. “目标”列表 - 列出“导航图编辑器”中当前的所有目标。 4. 导航图编辑器 - 包含导航图的可视化表示。 6. 属性编辑器 - 包含与导航图中的目标或操作关联的属性。 ## []()明确目的地 创建导航图的第一步是确定应用的目的地。你可以创建空白目标或从现有项目中的Fragment和Activity创建目标。 要确定应用的目标，请使用以下步骤： 2. 在“导航图编辑器”中，单击**New Destination**出现**New Destination**对话框。 4. 点击**Create blank destination**或者点击一个Fragment或者Activity。一个新的**Android Component**对话框将会出现 6. 键入名称到**Fragment Name**，作为新建Fragment的类名。 8. 键入名称到**Fragment Layout Name**，作为新建Fragment的布局名称。 10. 点击**Finish**。表示目标的框显示在“导航图编辑器”和“目标”列表中。然后将进行下列内部操作： * 如果你创建了空白目标，则“导航图编辑器”会在目标中显示消息“Hello blank fragment”。如果单击Fragment或Activity，则“导航图编辑器”将显示该Activity或Fragment的布局预览。 * 为项目创建Fragment子类。此类具有在步骤3中指定的名称 * 为项目创建资源文件。此文件具有在步骤4中指定的名称 下图显示空白和现有目的地。 ![alt](http://www.onlyloveyd.cn/upload/2018/10/p6qpdrsr5ij16p4skflhq77a2p.png) 12. 单击新插入的目标以突出显示目标。 “属性”面板中显示以下属性： * Type字段包含“Fragment”或“Activity”，以指示目标是否在源代码中实现为Fragment或Activity * Label字段包含目标XML布局文件名 * ID字段包含将用于在代码中引用目标的目标ID * Class字段包含目标类的名称 14. 单击**Text**选项卡以切换到XML文本视图。 XML现在包含基于现有类和布局文件的名称的id，名称（类名），标签和布局属性。具体如下： 1234 ## []()目的地之间建立衔接 有多个目的地时才能建立连接。以下是包含两个空白目标的导航图的XML： 123456789101112我们通过actions来连接目的地。如下步骤连接目的地： 2. 在导航图编辑器中，将鼠标悬停在你希望用户导航的目标的右侧。目的地上会出现一个圆圈。 ![alt](http://www.onlyloveyd.cn/upload/2018/10/0tb4sakcu8iilqp2oft9ui71re.png) 4. 单击并按住，将光标拖动到希望用户导航到的目标上，然后释放。绘制一条线以指示两个目的地之间的导航。 ![alt](http://www.onlyloveyd.cn/upload/2018/10/5mshju8q06hu5o0d2rb3s0aqv0.png) 6. 点击箭头凸显Actions。如下属性将出现在属性界面： * Type字段显示“Action” * ID字段包含系统为操作分配的ID * Destination字段包含目标Fragment或Activity的ID 8. 单击**Text**选项卡以切换到XML视图。已将一个**action**元素添加到父目标。该操作具有系统分配的ID和目标属性，其中包含下一个目标的ID。例如: 12345678910111213 ## []()将界面指定为起始目的地 导航图编辑器在应用程序的第一个目标名称旁边放置一个房屋图标。此图标表示这是导航图中的起始目标。你可以使用以下步骤将另一个目标指定为起始目标： 2. 从导航图编辑器中，单击目标凸显； 4. 单击“属性”面板中的**Set Start Destination**。选中目的地现在是起始目的地。 ## []()修改Activity以支持Navigation Activity通过在布局中添加NavHost界面来托管应用程序的导航。 NavHost是一个空视图，当用户浏览应用程序时，目的地会被换入和换出。 在Navigation架构组件中的默认NavHost实现是NavHostFragment。 在布局中添加NavHost以后，我们需要使用navGraph属性来将我们的导航图和NavHostFragment联系起来。 &lt;android.support.constraint.ConstraintLayout xmlns:android=”http://schemas.android.com/apk/res/android&quot; xmlns:app=”http://schemas.android.com/apk/res-auto&quot; xmlns:tools=”http://schemas.android.com/tools&quot; android:layout_width=”match_parent” android:layout_height=”match_parent” tools:context=”.MainActivity”&gt; &lt;fragment android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:id=&quot;@+id/my_nav_host_fragment&quot; android:name=&quot;androidx.navigation.fragment.NavHostFragment&quot; app:navGraph=&quot;@navigation/nav_graph&quot; app:defaultNavHost=&quot;true&quot; /&gt;&lt;/android.support.constraint.ConstraintLayout&gt; 1上面的例子中包含“app:defaultNavHost=&quot;true&quot;属性，这个属性保证来NavHostFragment可拦截系统返回键的事件。你可以覆写AppCompatActivity.onSupportNavigateUp()方法并调用NavController.navigateUp，如下所示： @Overridepublic boolean onSupportNavigateUp() { return Navigation.findNavController(this, R.id.nav_host_fragment).navigateUp();} 1234 ### []()以编程方式创建NavHostFragment 你也可以使用NavHostFragment.create()以编程方式创建具有特定图形资源的NavHostFragment，如下例所示： NavHostFragment finalHost = NavHostFragment.create(R.navigation.example_graph);getSupportFragmentManager().beginTransaction() .replace(R.id.nav_host, finalHost) .setPrimaryNavigationFragment(finalHost) // this is the equivalent to app:defaultNavHost=”true” .commit(); 123456789 ## []()绑定目的地跳转到UI Widgets 使用NavController类导航到目标。可以使用以下静态方法之一拿到NavController： * NavHostFragment.findNavController(Fragment) * Navigation.findNavController(Activity, @IdRes int viewId) * Navigation.findNavController(View) 拿到NavController以后，我们可以通过使用navigate()方法跳转到对应的目的地。navigate()方法接受一个resId作为参数。ID可以是导航图中特定目的地的ID或导航图中的 action ID。使用Action ID，相较于使用目的地ID有一些优势，如和导航相关的过渡效果。如下代码展示如何跳转到ViewTransactionsFragment： viewTransactionsButton.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View view) { Navigation.findNavController(view).navigate(R.id.viewTransactionsAction); }}); 12Android系统维护一个包含最后访问目的地的后栈。当用户打开应用程序时，应用程序的第一个目标位于堆栈中。每次调用navigate（）方法都会将另一个目标放在堆栈顶部。相反，按向上或向后按钮分别调用NavController.navigateUp（）和NavController.popBackStack（）方法，以从堆栈中弹出顶部目标。 对于按钮，你还可以使用Navigation类的createNavigateOnClickListener（）便捷方法导航到目标： button.setOnClickListener(Navigation.createNavigateOnClickListener(R.id.next_fragment, null)); 1234 ### []()将目标绑定到菜单驱动的UI组件 你可以通过在抽屉导航菜单或者是溢出菜单的xml中配置对应的目标ID来关联两者。以下代码段显示了详细信息界面目标，其ID为details_page_fragment 1目的地和菜单项使用同一个ID将会让两者自动关联。如下代码将展示如何让一个目的地和一个抽屉菜单关联（如menu_nav_drawer.xml） 1下面这段xml将展示如何将一个目的地和一个溢出菜单项关联（如menu_overflow.xml） &lt;item android:id=”@id/details_page_fragment” android:icon=”@drawable/ic_details” android:title=”@string/details” android:menuCategory:”secondary” /&gt; 1Navigation架构组件包含一个NavigationUI类。这个类中有几个静态方法可以用来关联菜单和目的地。例如，以下代码显示如何使用setupWithNavController（）方法将抽屉菜单项连接到NavigationView。 NavigationView navigationView = (NavigationView) findViewById(R.id.nav_view);NavigationUI.setupWithNavController(navigationView, navController); 1234567891011121314 有必要使用这些NavigationUI方法设置菜单驱动的导航组件，以便这些UI元素的状态与NavController的更改保持同步。 ## []()在目的地之间传递数据 你可以通过两种方式在目标之间传递数据：使用Bundle对象或使用safe args Gradle插件以类型安全的方式传递数据。按照以下步骤使用Bundle对象在目标之间传递数据： 2. 在导航图编辑器中，单击接收参数的目标位置。 4. 在属性面板的Arguments一栏中点击**Add (+)**，将会出现空名称和默认值字段。 6. 双击名称并输入参数的名称 8. 按Tab键切换到参数值文本框并输入参数的默认值 10. 点击此目标左边的action 箭头，属性面板将会出现我们刚才添加的参数 12. 点击**Text**切换到文本视图，对应的属性名称和默认值印入眼帘。 122. 在代码中，创建一个bundle对象并通过navigate（）方法将其传递到目标 Bundle bundle = new Bundle();bundle.putString(“amount”, amount);Navigation.findNavController(view).navigate(R.id.confirmationAction, bundle); 1接收方采用如下方式 TextView tv = view.findViewById(R.id.textViewAmount);tv.setText(getArguments().getString(“amount”)); 123456789 ## []()添加侦听器以处理导航事件 你可以使用addOnNavigatedListener（）方法将OnNavigatedListener添加到NavController。OnNavigatedListener在控制器导航到新目标时接收事件。你可以使用此处理程序进行特定于目标的更改，例如显示或隐藏某些UI元素。调用addOnNavigatedListener（）时，如果当前目标存在，则立即将其发送给您的侦听器。 ## []()以类型安全的方式在目标之间传递数据 Navigation 架构组件有一个Gradle插件，称为safeargs，它生成简单的对象和构建器类，以便对目标和操作指定的参数进行类型安全访问。Safe args建立在Bundle方法的基础之上，但需要一些额外的代码来换取更多类型的安全性。如果你使用的是Gradle，则可以使用safe args插件。要添加此插件，请将“androidx.navigation.safeargs”插件添加到build.gradle。 apply plugin: ‘com.android.application’apply plugin: ‘androidx.navigation.safeargs’ android { //…} 12345678910配置Gradle插件后，请按照以下步骤使用类型安全的args： 2. 在导航图编辑器中，单击接收参数的目标位置。 4. 在属性面板的Arguments一栏中点击**Add (+)**，将会出现空名称和默认值字段。 6. 双击名称并输入参数的名称 8. 按Tab键切换到参数类型下拉列表，选择参数类型 10. 按Tab键切换到参数值文本框并输入参数的默认值 12. 点击此目标左边的action 箭头，属性面板将会出现我们刚才添加的参数 14. 点击**Text**切换到文本视图，对应的属性名称和默认值印入眼帘。 12345678使用safeargs插件生成代码时，会为action以及发送和接收目标创建简单对象和构建器类。这些类是： * 一个针对目的地的类，包含action相关内容，以“Directions”结尾 所以，如果一个名为SpecifyAmountFragment的类，则生成对应的类为SpecifyAmountFragmentDirections，类中有一个和action相关的方法用来传递参数如confirmationAction() * 一个内部类，其名称基于用于传递参数的action。如果action的名称为confirmationAction，则这个类名为ConfirmationAction * 传递参数的目标的类，以“Args”结尾 所以，如果目的地为ConfirmationFragment，生成的参数类则为ConfirmationFragmentArgs，使用此类中的fromBundle()方法来解析对应的参数。 以下代码显示如何使用这些方法设置参数并将其传递给navigate（）方法。 @Overridepublic void onClick(View view) { EditText amountTv = (EditText) getView().findViewById(R.id.editTextAmount); int amount = Integer.parseInt(amountTv.getText().toString()); ConfirmationAction action = SpecifyAmountFragmentDirections.confirmationAction() action.setAmount(amount) Navigation.findNavController(view).navigate(action);} 1在接收目标的代码中，使用getArguments（）方法拿到bundle并使用其内容。 @Overridepublic void onViewCreated(View view, @Nullable Bundle savedInstanceState) { TextView tv = view.findViewById(R.id.textViewAmount); int amount = ConfirmationFragmentArgs.fromBundle(getArguments()).getAmount(); tv.setText(amount + “”)} 123456789101112131415161718 ## []()将目标分组为嵌套导航图 可以将一系列目的地分组为导航图中的子图。子图称为嵌套图，而包含图称为“根图”。嵌套图对于组织和重用应用程序UI的各个部分非常有用，例如单独的登录流程。与根图一样，嵌套图必须也有一个起始目标。嵌套图形封装了它的目的地;嵌套图外部的目标（例如根图上的目标）仅通过其起始目标访问嵌套图。下图显示了简单汇款应用程序的导航图。该图有两个流程：允许用户汇款的流程和允许用户查看其余额的流程。 ![alt](http://www.onlyloveyd.cn/upload/2018/10/1hllf7kaoohfapuo4tujp0fgr4.png) 分组目的地为嵌套图，可进行如下步骤： 2. 在“导航图编辑器”中，按住shift并单击要包含在嵌套图形中的目标。每个目的地都突出显示。 4. 打开上下文菜单，然后选择**Move to Nested Graph &gt; New Graph**。目标包含在嵌套图中。下图显示了Graph Editor中的嵌套图。 ![alt](http://www.onlyloveyd.cn/upload/2018/10/uc0fq8jn00jfbq2uq4jlg3g41o.png) 6. 单击嵌套图以突出显示它。 “属性”面板中显示以下属性： * Type字段为Nested Graph * ID字段包含嵌套图的系统分配ID。此ID用于引用代码中的嵌套图 8. 双击嵌套图。将显示嵌套图中的目标。 10. 在“目标”列表中，单击**“Root”**以返回到根导航图 12. 点击**Text**切换到文本视图。一个嵌套导航图被加入到导航图中。此导航图具有自己的收尾呼应的navigation元素。此嵌套图的ID为sendMoneyGraph，startDestination属性指向嵌套图中的第一个目标（chooseRecipient） 122. 在代码中，将连接根图的操作的资源ID传递给嵌套图 Navigation.findNavController(view).navigate(R.id.action_mainFragment_to_sendMoneyGraph); 12 ## []()使用引用其他导航图 123456789101112131415161718192021 ## []()为目标创建Deep Link 在Android中，deep link是指向应用中特定目标的URI。当你希望跳转到特定目的地以在应用中执行某项任务 时，这些URI非常有用，例如汇款流程，允许用户快速汇款给某人。 ### []()给目的地添加Deep Link 要在导航图中为目标添加Deep Link，请执行以下操作： 2. 从导航图编辑器中，为deep link选择一个destination 4. 单击“属性”面板的“Deep Link”部分中的+。将出现“Add Deep Link ”对话框。 6. 在URI字段中键入URI，例如“[www.cashdog.com/sendmoney”，它表示应用程序中发送货币嵌套图的起始目标。请注意以下事项：](http://www.cashdog.com/sendmoney%E2%80%9D%EF%BC%8C%E5%AE%83%E8%A1%A8%E7%A4%BA%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E4%B8%AD%E5%8F%91%E9%80%81%E8%B4%A7%E5%B8%81%E5%B5%8C%E5%A5%97%E5%9B%BE%E7%9A%84%E8%B5%B7%E5%A7%8B%E7%9B%AE%E6%A0%87%E3%80%82%E8%AF%B7%E6%B3%A8%E6%84%8F%E4%BB%A5%E4%B8%8B%E4%BA%8B%E9%A1%B9%EF%BC%9A) * 没有scheme的URI被假定为http和https。例如 [www.cashdog.com](http://www.cashdog.com) 匹配 [http://www.cashdog.com](http://www.cashdog.com) 和https://www.cashdog.com。 * 占位符以{placeholder_name}的形式匹配1个或多个字符。占位符的String值在参数Bundle中可用，并带有相同名称的键。例如http://www.example.com/users/{id} 匹配 [http://www.example.com/users/4](http://www.example.com/users/4) * .*通配符可用于匹配0个或多个字符 8. (可选）选中“自动验证”以要求Google验证URI的所有者 10. 单击添加。所选目标上方会显示一个链接图标，表示该目标具有Deep Link 12. 单击**Text**选项卡以切换到XML视图。已将嵌套的Deep Link元素添加到目标. 12345678 ### []()为Deep Link添加意图过滤 你必须在manifest.xml文件增加额外内容来启用Deep Link。 * 在Android Studio3.0和3.1中，你必须手动添加intent-filter元素。 * 在Android Studio3.2+版本中，你可以通过添加**nav-graph**元素到Activity 中来实现。 12345678910 作为清单合并构建步骤的一部分，此元素将替换为匹配导航图中所有deeplink所需的生成的元素 ### []()以编程方式使用NavDeepLinkBuil创建Deep Link 你可以使用NavDeepLinkBuilder类构造PendingIntent，将用户带到特定目标界面。 触发此deep link时，将清除任务后台堆栈并替换为deep link目标界面。 嵌套图形时，每个嵌套级别的起始目标（即层次结构中每个元素的起始目标）也会添加到堆栈中。 你可以使用NavDeepLinkBuilder（Context）直接构造PendingIntent，如下例所示。请注意，如果提供的上下文不是Activity，则构造函数使用PackageManager.getLaunchIntentForPackage（）作为要启动的默认Activity（如果可用）。 PendingIntent pendingIntent = new NavDeepLinkBuilder(context) .setGraph(R.navigation.mobile_navigation) .setDestination(R.id.android) .setArguments(args) .createPendingIntent(); 1234 ## []()在目的地之间创建过渡效果 添加方式和上面添加deep link或者action操作类似，操作结果代码如下： 1234567891011 ### []()在目标之间添加共享元素 除了过渡动画之外，Navigation架构组件还支持在目标之间添加共享元素过渡。 与动画不同，共享元素是以编程方式提供的，而不是通过导航XML文件提供的，因为它们需要引用你希望包含在共享元素转换中的View实例。 每种类型的目标都通过Navigator.Extras接口的子类实现此编程API。 Extras被传递给navigate（）的调用。 #### []()Fragment间共享元素 FragmentNavigator.Extras类允许您将共享元素附加到对Fragment目标的navigate（）调用，如下例所示： FragmentNavigator.Extras extras = new FragmentNavigator.Extras.Builder() .addSharedElement(imageView, “header_image”) .addSharedElement(titleView, “header_title”) .build();Navigation.findNavController(view).navigate(R.id.details, null, // Bundle of args null, // NavOptions extras); #### []()Activity间共享元素 活依赖于ActivityOptionsCompat来控制共享元素转换，详见使用共享元素文档启动活动，如下例所示","link":"/2018/10/14/《Android 基础（四十九）》Navigation Of JetPack【译】/"},{"title":"《Android开源库》 MPAndroidChart Wiki(译文)～Part 2","text":"7. 填充数据 这一章节将讲解给各式各样的图表设置数据的方法。 7.1 LineChart（线形图） 想给图表添加数据，使用如下方法： 1public void setData(ChartData data) { ... } 基类ChartData囊括所有图表在渲染过程中所需要的信息。针对不同的图表，有不同的ChartData的子类来为对应的图表设置数据，例如针对LineChart，你可以使用LineData。在构造函数中，你可以传递List&lt;? extends IDataSet&gt;作为要显示的值。从下面这个例子中，你可以看到如何使用LineData给LineChart设置数据： 12345/** List constructor */public LineData(List&lt;ILineDataSet&gt; sets) { ... }/** Constructor with one or multiple ILineDataSet objects */public LineData(ILineDataSet...) { ... } 那么，什么是DataSet?为什么你需要使用到它呢？其实很简单。一个DataSet代表在图表中显示的一组数据条目。它的设计初衷是为了将同一个图表中的不同组数据在逻辑上分离开，这样子看上去更清晰。针对不同的图表，存在不同的DataSet的子类（例如，LineDataSet），它们都有着自己的样式。 比如说，你想在一个线形图中展示两家公司一年中四个季度的收入。这种情况下，建议创建两个不同的LineDataSet（对应两个公司），每个LineDataSet包含四个季度的值（一年四个季度）。当然你也可以使用一个LineDataSet，然后包含两个公司8个季度的值。 通过以下方式创建LineDataSet: 1public LineDataSet(List&lt;Entry&gt; entries, String label) { ... } 从构造方法可以看出，LineDataSet创建的时候需要一个List&lt; Entry&gt;和一个用于描述LineDataSet的String，这个String也是在图例上显示的标签。 此外，此标签可用于在包含其他LineDataSet的LineData对象中查找该LineDataSet。 Entry列表包含图表中的所有数据。一个Entry对象，实际上就是对一个含有X值和Y值得数据条目的封装。 1public Entry(float x, float y) { ... } 综上（两家公司一年内季度收入的例子）： 首先，创建 List&lt; Entry&gt;来存放数据值： 12List&lt;Entry&gt; valsComp1 = new ArrayList&lt;Entry&gt;();List&lt;Entry&gt; valsComp2 = new ArrayList&lt;Entry&gt;(); 然后，使用Entry对象填写列表。 确保条目对象包含x轴的正确索引。 （当然，这里可以使用一个循环，在这种情况下，循环的计数器变量可以是x轴上的索引）。 1234567891011Entry c1e1 = new Entry(0f, 100000f); // 0 == quarter 1valsComp1.add(c1e1);Entry c1e2 = new Entry(1f, 140000f); // 1 == quarter 2 ...valsComp1.add(c1e2);// and so on ...Entry c2e1 = new Entry(0f, 130000f); // 0 == quarter 1valsComp2.add(c2e1);Entry c2e2 = new Entry(1f, 115000f); // 1 == quarter 2 ...valsComp2.add(c2e2);//... List&lt; Entry&gt;搞定之后，创建LineDataSet对象： 1234LineDataSet setComp1 = new LineDataSet(valsComp1, &quot;Company 1&quot;);setComp1.setAxisDependency(AxisDependency.LEFT);LineDataSet setComp2 = new LineDataSet(valsComp2, &quot;Company 2&quot;);setComp2.setAxisDependency(AxisDependency.LEFT); 通过调用setAxisDependency（…），指定DataSet对应的轴。 最后但同样重要的是 ，创建一个IDataSets列表并构建ChartData对象： 12345678// use the interface ILineDataSetList&lt;ILineDataSet&gt; dataSets = new ArrayList&lt;ILineDataSet&gt;();dataSets.add(setComp1);dataSets.add(setComp2);LineData data = new LineData(dataSets);mLineChart.setData(data);mLineChart.invalidate(); // refresh 在调用invalidate()之后，图表将会刷新，我们提供的数据将会被绘制出来。 如果我们要为x轴添加更多的描述性值（而不是不同季度的0到3的数字），我们可以通过使用IAxisValueFormatter接口来实现。 此接口允许在XAxis上绘制的值自定义样式。 在此示例中，格式化程序可能如下所示： 123456789101112131415161718// the labels that should be drawn on the XAxisfinal String[] quarters = new String[] { &quot;Q1&quot;, &quot;Q2&quot;, &quot;Q3&quot;, &quot;Q4&quot; };IAxisValueFormatter formatter = new IAxisValueFormatter() { @Override public String getFormattedValue(float value, AxisBase axis) { return quarters[(int) value]; } // we don&apos;t draw numbers, so no decimal digits needed @Override public int getDecimalDigits() { return 0; }};XAxis xAxis = mLineChart.getXAxis();xAxis.setGranularity(1f); // minimum axis-step (interval) is 1xAxis.setValueFormatter(formatter); 关于IAxisValueFormatter 接口的更多使用方法，请查阅IAxisValueFormatter 上面示例的运行结果大致如下 给BarChart，ScatterChart，BubbleChart和CandleStickChart设置数据的方法类似于LineChart。 一个特殊情况是针对多组数据的BarChart，这个后面会进行详细的介绍。 7.1.1 数据顺序 请注意，本开源库不支持X轴非升序的Entry组成的LineDataSet的绘制。以未排序的方式添加条目可能会导致正确的绘制，但也可能导致意外的结果。 Entry对象列表可以手动排序，也可以使用EntryXComparator： 12List&lt;Entry&gt; entries = ...;Collections.sort(entries, new EntryXComparator()); 因为本库使用了二分查找算法来优化性能，所以只能在排好序后的列表数据上工作。 7.2 BarChart(柱形图) BarChart上设置数据的方式和LineChart很相似。主要的差别是用于设置的数据对象从Entry变成了BarEntry。除此之外，BarChart还支持更多的样式。 下面是一个给BarChart填充数据的例子： 12345678910List&lt;BarEntry&gt; entries = new ArrayList&lt;&gt;();entries.add(new BarEntry(0f, 30f));entries.add(new BarEntry(1f, 80f));entries.add(new BarEntry(2f, 60f));entries.add(new BarEntry(3f, 50f)); // gap of 2fentries.add(new BarEntry(5f, 70f));entries.add(new BarEntry(6f, 60f));BarDataSet set = new BarDataSet(entries, &quot;BarDataSet&quot;); 在上面的例子中，创建了五个BarEntry对象并将其添加到BarDataSet中。 请注意，在第四个到第五个条目之间的x位置上存在“2”的差距。 在这个例子中，这个差距用于解释BarChart中非常不错的定位方式。 本教程末尾的截图将显示给定数据的结果BarChart，后面会看到。 然后下一步，创建一个BarData对象： 12345BarData data = new BarData(set);data.setBarWidth(0.9f); // set custom bar widthchart.setData(data);chart.setFitBars(true); // make the x-axis fit exactly all barschart.invalidate(); // refresh 在上述代码片段中，创建了一个BarData对象。 当创建图表的BarEntry对象时，每个柱形之间的间隔是1f(以中心为起点终点)。 通过将柱形宽度设置为0.9f，我们在每个柱形之间有效地创建一个0.1f的空间。 setFitBars（true）调用会告诉图表调整它的x轴值的范围，以精确地适合所有的柱形，并且在两边不会有柱形断层。 创建BarData对象后，我们将其设置到图表中并进行刷新。 运行结果如下： 7.3 Grouped BarChart(分组柱形图) 从v3.0.0版本开始，MPAndroidChart开始支持显式分组的柱形图，或者用户自定义，这种情况下用户可以通过改变X坐标将柱形图放在图表的任何位置。 本节将重点介绍显式分组的BarChart，这意味着开源库会帮你处理柱状图的x位置。 示例如下： 1234567891011121314YourData[] group1 = ...;YourData[] group2 = ...;List&lt;BarEntry&gt; entriesGroup1 = new ArrayList&lt;&gt;();List&lt;BarEntry&gt; entriesGroup2 = new ArrayList&lt;&gt;();// fill the listsfor(int i = 0; i &lt; group1.length; i++) { entriesGroup1.add(new BarEntry(i, group1.getValue())); entriesGroup2.add(new BarEntry(i, group2.getValue()));}BarDataSet set1 = new BarDataSet(entriesGroup1, &quot;Group 1&quot;);BarDataSet set2 = new BarDataSet(entriesGroup2, &quot;Group 2&quot;); 这个例子中，我们将有两组柱状图，每组由一个BarDataSet表示。 在显式分组的情况下，条目的实际x位置并不重要，它将会根据条目列表中BarEntry的位置执行分组： 12345678910float groupSpace = 0.06f;float barSpace = 0.02f; // x2 datasetfloat barWidth = 0.45f; // x2 dataset// (0.02 + 0.45) * 2 + 0.06 = 1.00 -&gt; interval per &quot;group&quot;BarData data = new BarData(set1, set2);data.setBarWidth(barWidth); // set the width of each barbarChart.setData(data);barChart.groupBars(1980f, groupSpace, barSpace); // perform the &quot;explicit&quot; groupingbarChart.invalidate(); // refresh 在上面的代码片段中，BarDataSet对象被添加到BarChart。 groupBars（…）方法执行两个BarDataSet对象的分组。 该方法采用以下参数： 1public void groupBars(float fromX, float groupSpace, float barSpace) { ... } fromX参数确定XAxis上分组条目开始的位置（在这种情况下为“1980”），groupSpace确定每组条目之间留下的空间，barSpace确定组中单个条目之间的空间。 基于这些参数，groupBars（…）方法将XAxis上的每个栏的位置更改为分组的外观，保留各个BarEntry对象的顺序。 每个组在XAxis上的“间隔”（占用空间）也由groupSpace、barSpac以及barWidth定义。 运行结果如下： 当然，分组的BarChart也可以在不使用groupBars（…）方法的情况下实现，只需通过手动的方式将各个条目直接定位到XAxis上即可。 为了确保XAxis的标签位于上述屏幕截图上所示的中间位置，可以使用setCenterAxisLabels（…）方法： 12XAxis xAxis = chart.getXAxis();xAxis.setCenterAxisLabels(true); 7.4 Stacked BarChart(堆积柱形图) 堆积柱形图的使用方式和正常柱形图的使用方式基本相同。有点差异的是BarEntry的创建方式不太一样，在堆叠柱形图的使用中，需要使用到BarEntry的另一个构造方法： 1public BarEntry(float x, float [] yValues) { ... } 这个构造方法允许传入多个yValues，代表每个堆积的柱形图的值。下面有个例子： 1BarEntry stackedEntry = new BarEntry(0f, new float[] { 10, 20, 30 }); 这个BarEntry由3个堆积的值组成，高度分别是10,20,30 7.5 PieChart(饼图) 与其他图表类型不同，PieChart以PieEntry对象的形式获取数据。PieEntry的构造方法如下： 1public PieEntry(float value, String label) { ... } 构造函数的第一个参数用于在PieChart中绘制为饼图的实际“值”，第二个参数“label”作为第一个参数绘制的那部分饼的描述。 示例如下： 1234567891011List&lt;PieEntry&gt; entries = new ArrayList&lt;&gt;();entries.add(new PieEntry(18.5f, &quot;Green&quot;));entries.add(new PieEntry(26.7f, &quot;Yellow&quot;));entries.add(new PieEntry(24.0f, &quot;Red&quot;));entries.add(new PieEntry(30.8f, &quot;Blue&quot;));PieDataSet set = new PieDataSet(entries, &quot;Election Results&quot;);PieData data = new PieData(set);pieChart.setData(data);pieChart.invalidate(); // refresh PieEntry对象不需要保存x位置的值，因为图表中显示的PieEntry对象的顺序由其在条目列表中的顺序确定。 添加一下样式设置之后，上面的例子将得到下面的饼图： 7.6 RadarChart 暂无介绍 7.7 CombinedChart 暂无介绍 8. 设置颜色 从V1.4.0版本开始，在之前版本上负责设置颜色的ColorTemplate 不再被需要。但是，一些预定义的颜色值依然保存在这个类中（例如，ColorTemplate.VORDIPLOM_COLORS），并且提供便利的方法，方便我们将颜色资源转换成真正的颜色。通过给DataSet直接指定颜色来代替ColorTemplate，同时你可以给每个DataSet分别设计样式。 在下面这个简单的例子中，我们使用两个不同的LineDataSet分别代表两家公司一年内四个季度的收入，我们给每个公司的数据分别设置不同的颜色。 “Company 1”使用四中不同的红色 “Company 2”使用四中不同的绿色 代码如下： 123456LineDataSet setComp1 = new LineDataSet(valsComp1, &quot;Company 1&quot;); // sets colors for the dataset, resolution of the resource name to a &quot;real&quot; color is done internally setComp1.setColors(new int[] { R.color.red1, R.color.red2, R.color.red3, R.color.red4 }, Context); LineDataSet setComp2 = new LineDataSet(valsComp2, &quot;Company 2&quot;); setComp2.setColors(new int[] { R.color.green1, R.color.green2, R.color.green3, R.color.green4 }, Context); 除了上面这个方法外，还有很多给DataSet设置颜色的方法。具体如下： 方法 | 作用 ------------------------------------------- | -------------------------------------------------------------------------------------------------------------------------------------------------- setColors(int [] colors, Context c) | 设置DataSet的颜色。当数据条目超过颜色数组的大小时，颜色将会被重复使用。你可以使用new int[] { R.color.red, R.color.green, … }来为这个方法提供颜色数组，实际上，内部是通过 getResources().getColor(…)来解析你传入的参数的 setColors(int [] colors) | 设置DataSet的颜色。当数据条目超过颜色数组的大小时，颜色将会被重复使用。确保颜色是通过getResources().getColor(…)后获取的值，也就是颜色的16进制值 setColors(ArrayList&amp;lt; Integer&amp;gt; colors) | 设置DataSet的颜色。当数据条目超过颜色数组的大小时，颜色将会被重复使用。确保颜色是通过getResources().getColor(…)后获取的值，也就是颜色的16进制值 setColor(int color) | 给DataSet设置一个唯一的颜色值。实际上，内部也是使用一个数组，只是数组中的颜色是一样的而已 ColorTemplate示例： 12LineDataSet set = new LineDataSet(...);set.setColors(ColorTemplate.VORDIPLOM_COLORS); 如果没有给DataSet设置颜色，我们将会使用默认值。 9. 格式化数据值(IValueFormatter) V1.6.2版本引入，V2.1.4版本优化 IValueFormatter接口允许用户自定义格式化类来将图表中的数据按照一种特定的方式格式化后再进行绘制。 你可以创建一个类，实现IValueFormatter接口，然后在getFormattedValue(…)方法中，返回你希望在图表中绘制的内容。 1234567891011121314public class MyValueFormatter implements IValueFormatter { private DecimalFormat mFormat; public MyValueFormatter() { mFormat = new DecimalFormat(&quot;###,###,##0.0&quot;); // use one decimal } @Override public String getFormattedValue(float value, Entry entry, int dataSetIndex, ViewPortHandler viewPortHandler) { // write your logic here return mFormat.format(value) + &quot; $&quot;; // e.g. append a dollar-sign }} 然后，将格式化程序设置到ChartData或者DataSet： 12345// usage on whole data objectlineData.setValueFormatter(new MyValueFormatter());// usage on individual dataset objectlineDataSet.setValueFormatter(new MyValueFormatter()); 9.1 预定义的FormatterFormatter | 介绍 --------------------- | ----------------------------------------------------------------------------------------------------- LargeNumberFormatter | 用于格式化大于1000的数字。“1.000”-&amp;gt;“1k”, “1.000.000”-&amp;gt;“1m” (million), “1.000.000.000”-&amp;gt;“1b” (billion)等等 PercentFormatter | 用于显示保留一位小数的百分数，在饼图中用的比较多。50-&amp;gt;50.0% StackedValueFormatter | 为堆积柱形图设置的格式化程序。可以明确指出是需要绘制所有的堆积值还是只绘制顶部值 10. 格式化轴值(AxisValueFormatter) v3.0.0版本中引入，用于格式化X轴和Y轴上的显示值。 10.1 创建Formatter 轴值自定义格式只需要一步：创建实现IAxisValueFormatter 接口的自定义格式类。 如下所示，这个例子中，将轴值格式化为1为小数。 1234567891011121314151617181920public class MyYAxisValueFormatter implements IAxisValueFormatter { private DecimalFormat mFormat; public MyAxisValueFormatter() { // format values to 1 decimal digit mFormat = new DecimalFormat(&quot;###,###,##0.0&quot;); } @Override public String getFormattedValue(float value, AxisBase axis) { // &quot;value&quot; represents the position of the label on the axis (x or y) return mFormat.format(value) + &quot; $&quot;; } /** this is only needed if numbers are returned, else return 0 */ @Override public int getDecimalDigits() { return 1; }} 下面这个例子展示如何将一个字符串数组展示到轴上： 123456789101112131415161718public class MyXAxisValueFormatter implements IAxisValueFormatter { private String[] mValues; public MyXAxisValueFormatter(String[] values) { this.mValues = values; } @Override public String getFormattedValue(float value, AxisBase axis) { // &quot;value&quot; represents the position of the label on the axis (x or y) return mValues[(int) value]; } /** this is only needed if numbers are returned, else return 0 */ @Override public int getDecimalDigits() { return 0; }} 10.2 设置Formatter 创建完Formatter之后，设置到对应的轴： 1234567YAxis left = chart.getAxisLeft();left.setValueFormatter(new MyYAxisValueFormatter());String[] values = new String[] { ... };XAxis xAxis = chart.getXAxis();xAxis.setValueFormatter(new MyXAxisValueFormatter(values)); 现在轴上将绘制Formatter提供的数据，而非默认的数据最小值和最大值。 10.3 限制间隔 如果你使用基于数组索引的格式化程序（如上所述），将轴的最小间隔限制为“1”是有意义的： 1axis.setGranularity(1f); // restrict interval to 1 (minimum) 这将防止格式化程序绘制重复的轴标签（由轴间隔&lt;1）引起。 只要图表的“缩放级别”足够高，它将停止重新计算更小的间隔。 10.4 预定义FormatterFormatter | 介绍 -------------------- | ----------------------------------------------------------------------------------------------------- LargeNumberFormatter | 用于格式化大于1000的数字。“1.000”-&amp;gt;“1k”, “1.000.000”-&amp;gt;“1m” (million), “1.000.000.000”-&amp;gt;“1b” (billion)等等 PercentFormatter | 用于显示保留一位小数的百分数，在饼图中用的比较多。50-&amp;gt;50.0% 10.5 示例Formatters DayAxisValueFormatter，该格式化程序将提供的值转换为日期字符串，根据比例改变字符串。 10.6 之前的Formatter 在v3.0.0之前的版本，针对X轴和Y轴分别存在两个Formatter,具体请查阅： XAxisValueFormatter YAxisValueFormatter 11. 基本设置/样式 本节重点介绍适用于本库中所有图表类型的基本设置和样式。 11.1 刷新方法 | 使用 ---------------------- | ---------------------------------------------------------------- invalidate() | 调用该方法后，图表将会被刷新(重绘)，从而使我们的修改在图表上生效 notifyDataSetChanged() | 让图表知道底层数据发生了变化，需要重新进行所有的必需计算(位移,图例,最大值,最小值等等)。在加载动态数据的时候这个是很有必要的 11.2 日志方法 | 使用 ------------------------------ | ---------------------------------------- setLogEnabled(boolean enabled) | 设置为true,打开图表的日志输出。打开日志对性能有影响，没必要的话最好保持关闭 11.3 基本图表样式 下面是一些和风格相关的方法，你可以直接在图表对象上使用： 方法 | 使用 ---------------------------------------- | --------------------------------------------- setBackgroundColor(int color) | 设置整个图表的背景颜色，也可以通过xml文件设置 setDescription(String desc) | 设置在图表右下角显示的描述文字 setDescriptionColor(int color) | 设置描述文字的颜色 setDescriptionPosition(float x, float y) | 设置描述文字显示的位置 setDescriptionTypeface(Typeface t) | 设置描述文字字体 setDescriptionTextSize(float size) | 设置描述文字的字体大小（px）, 最小6f, 最大16f. setNoDataText(String text) | 设置图表中没有数据时显示的文字. setDrawGridBackground(boolean enabled) | 设置为true之后，图表绘制区域后面的矩形会被绘制 setGridBackgroundColor(int color) | 设置要绘制的网格背景的颜色。 setDrawBorders(boolean enabled) | 启用/禁用绘制图表边框（图表周围的线）. setBorderColor(int color) | 设置图表边框的颜色 setBorderWidth(float width) | 设置图表边框线的宽度(dp) setMaxVisibleValueCount(int count) | 设置图表上最大可见绘制值标签的数量。 这仅在启用setDrawValues（）时才会生效。 12. 特定图表设置和样式12.1 Line-, Bar-, Scatter-, Candle- &amp; BubbleChart(条形图，柱形图，散列图，蜡烛图和气泡图)方法 | 使用 ------------------------------------------ | ----------------------------------------------------------------------------------- setAutoScaleMinMaxEnabled(boolean enabled) | 指示是否启用y轴上的自动缩放的标志。 如果启用，只要视口更改，y轴就会自动调整到当前x轴范围的最小和最大y值。 这对于显示财务数据的图表尤其有用。 默认值：false setKeepPositionOnRotation(boolean enabled) | 设置方向更改后图表是否应保持其位置（缩放/滚动）。 默认值：false 12.2 BarChart(柱形图)方法 | 使用 ------------------------------------------- | ------------------------------------------------- setDrawValueAboveBar(boolean enabled) | 设置为true,所有条目的值将会绘制在条目的上方，而不是顶部的下面 setDrawBarShadow(boolean enabled) | 如果设置为true，则在每个条之后绘制一个指示最大值的灰色区域。 打开这个开关将会是性能下降40% setDrawValuesForWholeStack(boolean enabled) | 如果设置为true，则堆叠条的所有值都是单独绘制的，而不仅仅是它们的总和. setDrawHighlightArrow(boolean enabled) | 设置为true后，若取值高亮，将会在每个高亮的条目上绘制一个箭头 12.3 PieChart(饼图)方法 | 使用 ----------------------------------------- | --------------------------------------------------------------- setDrawSliceText(boolean enabled) | 将其设置为true可将x值文本绘制到饼图切片中 setUsePercentValues(boolean enabled) | 如果启用此功能，则图表中的值将以百分比绘制，而不是以原始值绘制。提供给ValueFormatter的值将会以百分比的形式 setCenterText(SpannableString text) | 设置绘制在饼图中心的文字，过长的文字会被自动处理以免延伸到饼图切片中。 setCenterTextRadiusPercent(float percent) | 设置中心文本边界框的矩形半径，以饼孔默认值的百分比为1.f（100％） setHoleRadius(float percent) | 设置饼图中心空洞的半径，默认是整个饼图半径的一半也就是50% setTransparentCircleRadius(float percent) | 设置饼图中孔旁边的透明圆的半径，最大半径的百分比（max =整个图的半径），默认值55％ - &amp;gt;表示默认值比中心孔大5％ setTransparentCircleColor(int color) | 设置透明圆圈的颜色 setTransparentCircleAlpha(int alpha) | 设置透明圆圈的透明值 setMaxAngle(float maxangle) | 设置用于计算饼形圆的最大角度。 360f意味着它是一个完整的PieChart，180f结果是一个半饼图。 默认值：360f 12.4 RadarChart(雷达图)方法 | 使用 ------------------------------ | ---------------------------- setSkipWebLineCount(int count) | 允许跳过来自图表中心的网页线。 特别有用，如果有很多行。","link":"/2017/06/12/《Android开源库》 MPAndroidChart Wiki(译文)～Part 2/"},{"title":"《Android开源库》 MPAndroidChart Wiki(译文)～Part 1","text":"1. 基础入门1.1 添加依赖 Gradle 工程添加依赖 (推荐使用) 项目级build.gradle中添加: 12345allprojects { repositories { maven { url &quot;https://jitpack.io&quot; } }} App下的 build.gradle中添加: 123dependencies { compile &apos;com.github.PhilJay:MPAndroidChart:v3.0.2&apos;} Maven pom.xml中添加如下repositories: 1234&lt;repository&gt; &lt;id&gt;jitpack.io&lt;/id&gt; &lt;url&gt;https://jitpack.io&lt;/url&gt;&lt;/repository&gt; pom.xml中添加如下dependencies 12345&lt;dependency&gt; &lt;groupId&gt;com.github.PhilJay&lt;/groupId&gt; &lt;artifactId&gt;MPAndroidChart&lt;/artifactId&gt; &lt;version&gt;v3.0.2&lt;/version&gt;&lt;/dependency&gt; 直接使用Jar包文件 下载最新的.jar包，拷贝下载的文件到你的Android项目libs文件夹下然后开始使用这个开源库。 拷贝整个工程 使用git clone https://github.com/PhilJay/MPAndroidChart.git 命令下载整个工程，这个工程包含sample和MPChartLib库，然后你可以将这个库引入到你的Android Studio工程或者是Eclipse工程。 1.2 创建View 要使用LineChart, BarChart, ScatterChart, CandleStickChart, PieChart, BubbleChart 或者 RadarChart，我们可以首先在布局XML文件中定义它 ： 1234&lt;com.github.mikephil.charting.charts.LineChart android:id=&quot;@+id/chart&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; /&gt; 然后我们可以在Fragment，Activity或者其他能拿到它的地方取到对象： 12// in this example, a LineChart is initialized from xml LineChart chart = (LineChart) findViewById(R.id.chart); 或者我们直接在代码中创建Chart然后把它添加到布局中去： 123456// programmatically create a LineChart LineChart chart = new LineChart(Context); // get a layout defined in xml RelativeLayout rl = (RelativeLayout) findViewById(R.id.relativeLayout); rl.add(chart); // add the programmatically created chart 1.3 添加数据 当你创建了一个chart实例后，你可以生成一些数据然后把它加入到图表中去。下面的例子中我们以LineChart为例，对LineChart而言，Entry类代表有X和Y值的图表中的一个条目。对于其他的Chart类型，如BarChart，你可以使用BarEntry作为数据条目。 为了给你的图表添加数据，你需要想下面这样将你的数据封装成Entry： 123456789YourData[] dataObjects = ...;List&lt;Entry&gt; entries = new ArrayList&lt;Entry&gt;();for (YourData data : dataObjects) { // turn your data into Entry objects entries.add(new Entry(data.getValueX(), data.getValueY())); } 下一步，你需要将List&lt; Entry&gt;添加到LineDataSet对象中。DataSet对象包含属于一组的数据，并且每个数据有自己独立的风格。如下“Label”只有描述目的如果设置enabled的话，它将会在Legend中显示出来。 123LineDataSet dataSet = new LineDataSet(entries, &quot;Label&quot;); // add entries to datasetdataSet.setColor(...);dataSet.setValueTextColor(...); // styling, ... 最后一步，添加LineDataSet到LineData中，LineData包含对应Chart中的所有数据，并且我们可以更深入的定制数据的显示风格。在创建了数据之后我们将其加入到chart中然后刷新一下。 123LineData lineData = new LineData(dataSet);chart.setData(lineData);chart.invalidate(); // refresh 上面这些都是很基本的设置和使用。更细节的介绍请查阅setting Data章节—- 结合示例的为你讲解如何给各式各样的图表添加数据。 1.4 样式 想要了解chart和数据的设置和样式，请查阅settings &amp; styling章节。对于各种类型的数据和样式，请查阅specific settings &amp; styling wiki页面。 2. Chart交互 MPAndroidChart允许用户完成自定义于Chart View的触摸或者是手势事件，并且通过回调方法响应交互。 2.1 启用／禁用交互方法 | 作用 ------------------------------------------ | ----------------------------- setTouchEnabled(boolean enabled) | 启用或者禁用触摸交互 setDragEnabled(boolean enabled) | 启用或者禁用拖拽交互 setScaleEnabled(boolean enabled) | 启用或者禁用缩放交互（X轴和Y轴） setScaleXEnabled(boolean enabled) | 启用或者禁用X轴缩放交互 setScaleYEnabled(boolean enabled) | 启用或者禁用Y轴缩放交互 setPinchZoom(boolean enabled) | 设置为true，则可以使用捏缩放，否则X轴Y轴将会分开缩放 setDoubleTapToZoomEnabled(boolean enabled) | 设置为false，双击放大功能将会被禁用 2.2 图表Fling和减速（针对滑动操作）方法 | 作用 ------------------------------------------- | ------------------------------------------------------------------- setDragDecelerationEnabled(boolean enabled) | 如果设置为true，滑动操作完成后图表还会继续滚动。默认值为true setDragDecelerationFrictionCoef(float coef) | 减速摩擦系数在[0; 1]间隔，较高的值表示速度将缓慢降低，例如，如果设置为0，它将立即停止。 1是无效值，将自动转换为0.9999。 2.3 高亮值 如何通过点击手势高亮数据条目，请查阅highlighting section 2.4 手势回调 OnChartGestureListener接口可以让我们定义手势响应事件 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667public interface OnChartGestureListener { /** * Callbacks when a touch-gesture has started on the chart (ACTION_DOWN) * * @param me * @param lastPerformedGesture */ void onChartGestureStart(MotionEvent me, ChartTouchListener.ChartGesture lastPerformedGesture); /** * Callbacks when a touch-gesture has ended on the chart (ACTION_UP, ACTION_CANCEL) * * @param me * @param lastPerformedGesture */ void onChartGestureEnd(MotionEvent me, ChartTouchListener.ChartGesture lastPerformedGesture); /** * Callbacks when the chart is longpressed. * * @param me */ public void onChartLongPressed(MotionEvent me); /** * Callbacks when the chart is double-tapped. * * @param me */ public void onChartDoubleTapped(MotionEvent me); /** * Callbacks when the chart is single-tapped. * * @param me */ public void onChartSingleTapped(MotionEvent me); /** * Callbacks then a fling gesture is made on the chart. * * @param me1 * @param me2 * @param velocityX * @param velocityY */ public void onChartFling(MotionEvent me1, MotionEvent me2, float velocityX, float velocityY); /** * Callbacks when the chart is scaled / zoomed via pinch zoom gesture. * * @param me * @param scaleX scalefactor on the x-axis * @param scaleY scalefactor on the y-axis */ public void onChartScale(MotionEvent me, float scaleX, float scaleY); /** * Callbacks when the chart is moved / translated via drag gesture. * * @param me * @param dX translation distance on the x-axis * @param dY translation distance on the y-axis */ public void onChartTranslate(MotionEvent me, float dX, float dY);} 简单地在类中实现上面这个接口，然后设置到对应的chart对象 1chart.setOnChartGestureListener(this); 3. 高亮 本节重点介绍通过点击手势和基于版本v3.0.0以编程方式突出显示图表中的条目的主题。 3.1 启用／禁用高亮方法 | 作用 ------------------------------------------- | --------------------------------------------------------- setHighlightPerDragEnabled(boolean enabled) | 在图表上将其设置为true，以便在完全缩小时在图表上拖动时突出显示。 默认值：true setHighlightPerTapEnabled(boolean enabled) | 在图表上将其设置为false可防止点击手势突出显示值。 仍然可以通过拖动或以编程方式突出显示值。 默认值：true setMaxHighlightDistance(float distanceDp) | 设置最大高亮距离(dp)。 图表上条目大于这个距离不会触发高亮。 默认值：500dp 除此之外，单独的DataSet也能配置高亮： 123456dataSet.setHighlightEnabled(true); // allow highlighting for DataSet// set this to false to disable the drawing of highlight indicator (lines)dataSet.setDrawHighlightIndicators(true); dataSet.setHighlightColor(Color.BLACK); // color for highlight indicator// and more... 3.2 代码实现高亮方法 | 作用 --------------------------------------------------------------- | ------------------------------------------------------------------------ highlightValue(float x, int dataSetIndex, boolean callListener) | 突出显示给定DataSet中指定x位置的值。 dataSetIndex为-1时撤消所有高亮。 callListener决定了是否调用选择监听器。 highlightValue(Highlight high, boolean callListener) | 突出显示由提供的高光对象表示的值。 提供null以撤销所有突出显示。 callListener决定了是否调用选择监听器。 highlightValues(Highlight[] highs) | 突出显示highs代表的高光对象表示的值。提供null或者是空数组取消所有高亮 getHighlighted() | 以highlight[]的形式返回包含所有高光条目信息，X坐标，DateSet索引 3.3 选择回调 开源库提供了大量用来处理交互的监听器。OnChartValueSelectedListener是其中一个，用来处理通过触摸高亮数据条目时处理回调： 1234567891011121314public interface OnChartValueSelectedListener { /** * Called when a value has been selected inside the chart. * * @param e The selected Entry. * @param h The corresponding highlight object that contains information * about the highlighted position */ public void onValueSelected(Entry e, Highlight h); /** * Called when nothing has been selected or an &quot;un-select&quot; has been made. */ public void onNothingSelected();} 在需要接受回调的类中实现上面这个接口，然后将监听器设置到Chart即可 1chart.setOnChartValueSelectedListener(this); 3.4 Highlight类 Hightlight类代表一个高亮条目的所有数据，如高亮条目本身，它的DataSet，它在界面上的绘制位置等等。这个类可以用来得到当前高亮条目的信息，或者用来告诉Chart，需要高亮哪些条目。为了实现这些目的，Highlight类提供了两个构造方法： 12345/** constructor for standard highlight */public Highlight(float x, int dataSetIndex) { ... }/** constructor for stacked BarEntry highlight */public Highlight(float x, int dataSetIndex, int stackIndex) { ... } 通过构造函数你可以创建Hightlight对象，然后通过代码的方式实现高亮： 1234// highlight the entry and x-position 50 in the first (0) DataSetHighlight highlight = new Highlight(50f, 0); chart.highlightValue(highlight, false); // highlight this value, don&apos;t call listener 3.5 自定义高亮器 所有以高亮手势形式显示的用户输入都由默认的ChartHighlighter类进行内部处理。 使用以下方法可以用自定义实现替换默认的highligher： 方法 | 作用 -------------------------------------------- | ----------------------------------------------------- setHighlighter(ChartHighlighter highlighter) | 设置一个自定义高亮器来处理所有图表上的高亮事件。你的自定义高亮器必须继承ChartHighlighter类 4. 轴 该wiki页面重点介绍AxisBase类，XAxis（XAxis）和YAxis（YAxis）的基础类。 在v2.0.0中引入 下面提到的以下方法都可以应用于两个轴。 轴类允许特定的样式，包括以下组件/部件（可以包括）： 标签（以垂直（y轴）或水平（x轴）对齐绘制），其中包含轴描述值 所谓的“轴线”被直接绘制在标签附近并与标签平行 “网格线”，各自源自水平方向的轴标签 限制线，允许呈现特殊信息，如边界或约束 4.1 控制轴线绘制（哪些部分需要绘制） 方法 | 作用 --------------------------------- | ------------------------------------- setEnabled(boolean enabled) | 设置轴启用或禁用。 如果禁用，无论任何其他设置如何，都不会绘制轴的任何部分 setDrawLabels(boolean enabled) | 将其设置为true可以绘制轴的标签。 setDrawAxisLine(boolean enabled) | 如果沿着轴（轴线）的线应该被绘制，则将其设置为true。 setDrawGridLines(boolean enabled) | 将其设置为true可以绘制轴的网格线。 4.2 自定义轴的范围（最小值／最大值）方法 | 作用 --------------------------------------- | --------------------------------------------------------------------------------------------- setAxisMaximum(float max) | 设置此轴的自定义最大值。 如果设置，此值将不会根据提供的数据自动计算. resetAxisMaximum() | 调用此方法来撤销先前设置的最大值。 通过这样做，你将再次允许轴自动计算它的最大值。 setAxisMinimum(float min) | 设置此轴的自定义最小值。 如果设置，此值将不会根据提供的数据自动计算 resetAxisMinimum() | 调用此方法来撤销先前设置的最小值。 通过这样做，你将再次允许轴自动计算它的最小值。 setStartAtZero(boolean enabled) | 已弃用 - 请使用setAxisMinValue（…）或setAxisMaxValue（…） setInverted(boolean enabled) | 如果设置为true，则该轴将被反转，这意味着最高值将在底部，最低值在顶部 setSpaceTop(float percent) | 设置图表中最高值的顶部间距（以总轴的百分比表示）与轴上的最高值相比较 setSpaceBottom(float percent) | 设置图表中最低值的底部间距（以总轴范围的百分比表示）与轴上的最低值相比较. setShowOnlyMinMax(boolean enabled) | 如果启用，该轴将仅显示其最小值和最大值。 这将忽略/覆盖定义的标签计数（如果不强制）. setLabelCount(int count, boolean force) | 设置y轴的标签数量。 请注意，这个数字不是固定的（如果force == false），并且只能近似。 如果强制启用（true），则绘制精确的指定标签计数 - 这可能导致轴上的数字不均匀。 setPosition(YAxisLabelPosition pos) | 设置绘制轴标签的位置。 INSIDE_CHART或OUTSIDE_CHART。 setGranularity(float gran) | 设置y轴值之间的最小间隔。 这可以用于在放大到为轴设置的小数位数不再允许区分两个轴值的点时避免重复值。 setGranularityEnabled(boolean enabled) | 启用在放大时限制y轴间隔的粒度特征。默认值：false 4.3 样式/修改轴方法 | 作用 ---------------------------------------------------------------------- | ---------------------------------------------------------------------------------- setTextColor(int color) | 设置轴标签的文字颜色. setTextSize(float size) | 设置轴标签的文字大小(dp) setTypeface(Typeface tf) | 设置轴标签的字体 setGridColor(int color) | 设置轴网格线的颜色 setGridLineWidth(float width) | 设置轴网格线的宽度 setAxisLineColor(int color) | 设置轴线的颜色 setAxisLineWidth(float width) | 设置轴线的宽度 enableGridDashedLine(float lineLength, float spaceLength, float phase) | 使网格线以虚线模式绘制，例如”- - - - - -”。 “lineLength”控制线段的长度，“spaceLength”控制线间的空间，“phase”控制起点。 4.4 格式化轴值 对于格式化轴值，可以使用IAxisValueFormatter接口，你可以使用axis.setValueFormatter(IAxisValueFormatter formatter)方法将自定义格式设置到轴，具体请查阅here 4.5 限制值 两个轴都支持所谓的LimitLine，允许提供特殊信息，如边界或约束。 添加到YAxis的LimitLines在水平方向绘制，并且在添加到XAxis时在垂直方向绘制。 下面介绍如何从轴中添加和删除LimitLines： 方法 | 作用 -------------------------------------------- | ---------------------------------------------------------------------------- addLimitLine(LimitLine l) | 给轴添加一条LimitLine removeLimitLine(LimitLine l) | 移除轴上一条指定的LimitLine | 还有很多添加／移除的方法 setDrawLimitLinesBehindData(boolean enabled) | 允许控制LimitLines和实际数据之间的z顺序。 如果将此设置为true，则LimitLine将在实际数据之后绘制，否则在顶部。 默认值：false限制线（LimitLine类）（正如名称可能指示的），可以使用简单线条为用户提供附加信息。 例如，你的图表可能会显示用户使用应用程序记录的各种血压测量结果。 为了通知用户超过140 mmHg的收缩压被认为是健康风险，您可以在140处添加LimitLine来提供该信息。 4.6 示例代码12345678910YAxis leftAxis = chart.getAxisLeft();LimitLine ll = new LimitLine(140f, &quot;Critical Blood Pressure&quot;);ll.setLineColor(Color.RED);ll.setLineWidth(4f);ll.setTextColor(Color.BLACK);ll.setTextSize(12f);// .. and more styling optionsleftAxis.addLimitLine(ll); 5. X轴 XAxis是AxisBase的子类，它继承了许多样式和方法。 XAxis类（在2.0.0之前的版本中称为 XLabels），是与横轴有关的所有数据和信息容器。 每个Line-，Bar-，Scatter-，CandleStick-和RadarChart都有一个XAxis对象。 XAxis类允许特定的样式，包括以下组件（可以包括）以下组件/部件： 所谓的“轴线”被直接绘制在标签附近并与标签平行 “网格线”，各自源于垂直方向的轴标签 通过如下方式获取XAxis实例： 1XAxis xAxis = chart.getXAxis(); 5.1 自定义XAxis方法 | 作用 ---------------------------------- | ---------------------------------------------------------------- setLabelRotationAngle(float angle) | 设置绘制x轴标签的角度（以度为单位） setPosition(XAxisPosition pos) | 设置XAxis位置。 在TOP，BOTTOM，BOTH_SIDED，TOP_INSIDE或BOTTOM_INSIDE之间进行选择 5.2 示例代码123456789XAxis xAxis = chart.getXAxis();xAxis.setPosition(XAxisPosition.BOTTOM);xAxis.setTextSize(10f);xAxis.setTextColor(Color.RED);xAxis.setDrawAxisLine(true);xAxis.setDrawGridLines(false);// set a custom value formatterxAxis.setValueFormatter(new MyCustomFormatter()); // and more... 6. YAxis YAxis是AxisBase的子类。 这个wiki只描述了YAxis，而不是父类。 YAxis类（在2.0.0版本的中称为YLabels），是与垂直轴相关的所有数据和信息容器。 每个Line-，Bar-，Scatter或CandleStickChart都有一个左和右YAxis对象，分别负责左轴或右轴。 RadarChart只有一个YAxis。 默认情况下，图表的两个轴都被启用，并将被绘制。 通过如下方式获取YAxis实例： 123456YAxis leftAxis = chart.getAxisLeft();YAxis rightAxis = chart.getAxisRight();YAxis leftAxis = chart.getAxis(AxisDependency.LEFT);YAxis yAxis = radarChart.getYAxis(); // this method radarchart only 在运行时，使用public AxisDependency getAxisDependency（）来确定此轴表示的图表的边。 所有会影响到轴数值范围的自定义设置都需要在设置图表数据之前完成。 6.1 Axis Dependency 根据默认值，添加到图表的所有数据都会与图表的左侧YAxis对应。 如果没有进一步指定和启用，则右侧的YAxis被调整为与左轴相同的刻度。 如果你的图表需要支持不同的轴刻度，则可以通过设置数据应该对应的轴来实现。 这可以通过更改DataSet对象的AxisDependency来实现： 12LineDataSet dataSet = ...; // get a datasetdataSet.setAxisDependency(AxisDependency.RIGHT); 设置此项将更改你的数据对应的轴。 6.2 零线 除了沿YAxis上的每个值水平位置的网格线之外，还有一个所谓的零线，它在轴上的零（0）值处绘制，并且与网格线相似，但可以单独配置。 方法 | 作用 -------------------------------- | ----------- setDrawZeroLine(boolean enabled) | 启用 / 禁用 零线。 setZeroLineWidth(float width) | 设置零线的宽度。 setZeroLineColor(int color) | 设置零线的颜色 零线示例代码： 1234567// data has AxisDependency.LEFTYAxis left = mChart.getAxisLeft();left.setDrawLabels(false); // no axis labelsleft.setDrawAxisLine(false); // no axis lineleft.setDrawGridLines(false); // no grid linesleft.setDrawZeroLine(true); // draw a zero linemChart.getAxisRight().setEnabled(false); // no right axis 上述代码结果如下所示。 不绘制轴值，不绘制网格线或轴线，只绘制零线。 6.3 更多示例代码12345678910YAxis yAxis = mChart.getAxisLeft();yAxis.setTypeface(...); // set a different fontyAxis.setTextSize(12f); // set the text sizeyAxis.setAxisMinimum(0f); // start at zeroyAxis.setAxisMaximum(100f); // the axis maximum is 100yAxis.setTextColor(Color.BLACK);yAxis.setValueFormatter(new MyValueFormatter());yAxis.setGranularity(1f); // interval 1yAxis.setLabelCount(6, true); // force 6 labels//... and more","link":"/2017/06/10/《Android开源库》 MPAndroidChart Wiki(译文)～Part 1/"},{"title":"《Android开源库》Picasso","text":"1. 前言最近项目开发中使用到来Picasso，并且碰到了一个部分图片无法加载的问题，使用Glide可以正常加载，使用最新的Picasso3.0.0-SNAPSHOT版本也没有问题，最后使用Picasso自带的异常监听获取堆栈，并且在Github中找到的同样的问题，具体查阅： https://github.com/square/picasso/issues/1514 所以，想详细的看看Picasso的详细用法和master分支上的源代码。 2. 基本介绍Picasso 是Square 公司开源的Android 端的图片加载和缓存框架。图片的加载是一个令人很头疼的问题，因为涉及的内容比较多，比如网络请求，本地存储，图片缓存，图片回收等等，处理不好可能会出现图片变形内存泄漏等令开发者焦头烂额的问题，但是Picasso帮我们做了很多事情，比如： 处理Adapter 中ImageView的回收和取消下载。 使用最小的内存 来做复杂的图片变换。比如高斯模糊，圆角、圆形等处理。 自动帮我们缓存图片。内存和磁盘缓存 3. 基本使用以Android Studio为开发环境，以Gradle为构建工具，其他的本文不做介绍。 3.1 添加依赖1compile 'com.squareup.picasso:picasso:2.5.2' 3.2 混淆1-dontwarn com.squareup.okhttp.** 3.3 加载图片1234567891011/* 网络图片 */Picasso.with(context).load(\"http://i.imgur.com/DvpvklR.png\").into(imageView);/* 图片资源 */Picasso.with(context).load(R.drawable.landing_screen).into(imageView1);/* 本地图片*/Picasso.with(context).load(\"file:///android_asset/DvpvklR.png\").into(imageView2);/* 本地图片文件 */Picasso.with(context).load(new File(...)).into(imageView3); 3.3.1 Picasso.with(Context context)12345678910111213141516171819202122232425262728/** * The global default {@link Picasso} instance. * &lt;p&gt; * This instance is automatically initialized with defaults that are suitable to most * implementations. * &lt;ul&gt; * &lt;li&gt;LRU memory cache of 15% the available application RAM&lt;/li&gt; * &lt;li&gt;Disk cache of 2% storage space up to 50MB but no less than 5MB. (Note: this is only * available on API 14+ &lt;em&gt;or&lt;/em&gt; if you are using a standalone library that provides a disk * cache on all API levels like OkHttp)&lt;/li&gt; * &lt;li&gt;Three download threads for disk and network access.&lt;/li&gt; * &lt;/ul&gt; * &lt;p&gt; * If these settings do not meet the requirements of your application you can construct your own * with full control over the configuration by using {@link Picasso.Builder} to create a * {@link Picasso} instance. You can either use this directly or by setting it as the global * instance with {@link #setSingletonInstance}. */public static Picasso with(Context context) { if (singleton == null) { synchronized (Picasso.class) { if (singleton == null) { singleton = new Builder(context).build(); } } } return singleton;} 构造一个默认的Picasso单例，如果注释中的一些基本配置需求无法满足你，你可以使用Picasso.Builder来构造自己的Picasso实例。 3.3.2 load()很显然，四个load方法，不同的入参，相同类型的返回值。针对不同的图片来源，执行不同的加载方式。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273/** * Start an image request using the specified URI. * &lt;p&gt; * Passing {@code null} as a {@code uri} will not trigger any request but will set a placeholder, * if one is specified. * * @see #load(File) * @see #load(String) * @see #load(int) */ public RequestCreator load(Uri uri) { return new RequestCreator(this, uri, 0); } /** * Start an image request using the specified path. This is a convenience method for calling * {@link #load(Uri)}. * &lt;p&gt; * This path may be a remote URL, file resource (prefixed with {@code file:}), content resource * (prefixed with {@code content:}), or android resource (prefixed with {@code * android.resource:}. * &lt;p&gt; * Passing {@code null} as a {@code path} will not trigger any request but will set a * placeholder, if one is specified. * * @see #load(Uri) * @see #load(File) * @see #load(int) * @throws IllegalArgumentException if {@code path} is empty or blank string. */ public RequestCreator load(String path) { if (path == null) { return new RequestCreator(this, null, 0); } if (path.trim().length() == 0) { throw new IllegalArgumentException(\"Path must not be empty.\"); } return load(Uri.parse(path)); } /** * Start an image request using the specified image file. This is a convenience method for * calling {@link #load(Uri)}. * &lt;p&gt; * Passing {@code null} as a {@code file} will not trigger any request but will set a * placeholder, if one is specified. * &lt;p&gt; * Equivalent to calling {@link #load(Uri) load(Uri.fromFile(file))}. * * @see #load(Uri) * @see #load(String) * @see #load(int) */ public RequestCreator load(File file) { if (file == null) { return new RequestCreator(this, null, 0); } return load(Uri.fromFile(file)); } /** * Start an image request using the specified drawable resource ID. * * @see #load(Uri) * @see #load(String) * @see #load(File) */ public RequestCreator load(int resourceId) { if (resourceId == 0) { throw new IllegalArgumentException(\"Resource ID must not be zero.\"); } return new RequestCreator(this, null, resourceId); } 每一个load()方法都是创建一个RequestCreator实例，load(File file)和load(String path)最后都是通过转换成load(Uri uri)的方式实现加载。而RequestCreator的构造方法中三个参数，第一个是Picasso实例，一个是uri，一个是resourceId，通过后两个参数覆盖所有的加载场景。 12345678RequestCreator(Picasso picasso, Uri uri, int resourceId) { if (picasso.shutdown) { throw new IllegalStateException( \"Picasso instance already shut down. Cannot submit new requests.\"); } this.picasso = picasso; this.data = new Request.Builder(uri, resourceId, picasso.defaultBitmapConfig);} 3.3.3 into()RequestCreator中很多方法都是我们经常会用到的。先看into()方法 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224/** * Asynchronously fulfills the request into the specified {@link Target}. In most cases, you * should use this when you are dealing with a custom {@link android.view.View View} or view * holder which should implement the {@link Target} interface. * &lt;p&gt; * Implementing on a {@link android.view.View View}: * &lt;blockquote&gt;&lt;pre&gt; * public class ProfileView extends FrameLayout implements Target { * {@literal @}Override public void onBitmapLoaded(Bitmap bitmap, LoadedFrom from) { * setBackgroundDrawable(new BitmapDrawable(bitmap)); * } * * {@literal @}Override public void onBitmapFailed() { * setBackgroundResource(R.drawable.profile_error); * } * * {@literal @}Override public void onPrepareLoad(Drawable placeHolderDrawable) { * frame.setBackgroundDrawable(placeHolderDrawable); * } * } * &lt;/pre&gt;&lt;/blockquote&gt; * Implementing on a view holder object for use inside of an adapter: * &lt;blockquote&gt;&lt;pre&gt; * public class ViewHolder implements Target { * public FrameLayout frame; * public TextView name; * * {@literal @}Override public void onBitmapLoaded(Bitmap bitmap, LoadedFrom from) { * frame.setBackgroundDrawable(new BitmapDrawable(bitmap)); * } * * {@literal @}Override public void onBitmapFailed() { * frame.setBackgroundResource(R.drawable.profile_error); * } * * {@literal @}Override public void onPrepareLoad(Drawable placeHolderDrawable) { * frame.setBackgroundDrawable(placeHolderDrawable); * } * } * &lt;/pre&gt;&lt;/blockquote&gt; * &lt;p&gt; * &lt;em&gt;Note:&lt;/em&gt; This method keeps a weak reference to the {@link Target} instance and will be * garbage collected if you do not keep a strong reference to it. To receive callbacks when an * image is loaded use {@link #into(android.widget.ImageView, Callback)}. */public void into(Target target) { long started = System.nanoTime(); checkMain(); if (target == null) { throw new IllegalArgumentException(\"Target must not be null.\"); } if (deferred) { throw new IllegalStateException(\"Fit cannot be used with a Target.\"); } if (!data.hasImage()) { picasso.cancelRequest(target); target.onPrepareLoad(setPlaceholder ? getPlaceholderDrawable() : null); return; } Request request = createRequest(started); String requestKey = createKey(request); if (shouldReadFromMemoryCache(memoryPolicy)) { Bitmap bitmap = picasso.quickMemoryCacheCheck(requestKey); if (bitmap != null) { picasso.cancelRequest(target); target.onBitmapLoaded(bitmap, MEMORY); return; } } target.onPrepareLoad(setPlaceholder ? getPlaceholderDrawable() : null); Action action = new TargetAction(picasso, target, request, memoryPolicy, networkPolicy, errorDrawable, requestKey, tag, errorResId); picasso.enqueueAndSubmit(action);}/** * Asynchronously fulfills the request into the specified {@link RemoteViews} object with the * given {@code viewId}. This is used for loading bitmaps into a {@link Notification}. */public void into(RemoteViews remoteViews, int viewId, int notificationId, Notification notification) { long started = System.nanoTime(); if (remoteViews == null) { throw new IllegalArgumentException(\"RemoteViews must not be null.\"); } if (notification == null) { throw new IllegalArgumentException(\"Notification must not be null.\"); } if (deferred) { throw new IllegalStateException(\"Fit cannot be used with RemoteViews.\"); } if (placeholderDrawable != null || placeholderResId != 0 || errorDrawable != null) { throw new IllegalArgumentException( \"Cannot use placeholder or error drawables with remote views.\"); } Request request = createRequest(started); String key = createKey(request, new StringBuilder()); // Non-main thread needs own builder. RemoteViewsAction action = new NotificationAction(picasso, request, remoteViews, viewId, notificationId, notification, memoryPolicy, networkPolicy, key, tag, errorResId); performRemoteViewInto(action);}/** * Asynchronously fulfills the request into the specified {@link RemoteViews} object with the * given {@code viewId}. This is used for loading bitmaps into all instances of a widget. */public void into(RemoteViews remoteViews, int viewId, int[] appWidgetIds) { long started = System.nanoTime(); if (remoteViews == null) { throw new IllegalArgumentException(\"remoteViews must not be null.\"); } if (appWidgetIds == null) { throw new IllegalArgumentException(\"appWidgetIds must not be null.\"); } if (deferred) { throw new IllegalStateException(\"Fit cannot be used with remote views.\"); } if (placeholderDrawable != null || placeholderResId != 0 || errorDrawable != null) { throw new IllegalArgumentException( \"Cannot use placeholder or error drawables with remote views.\"); } Request request = createRequest(started); String key = createKey(request, new StringBuilder()); // Non-main thread needs own builder. RemoteViewsAction action = new AppWidgetAction(picasso, request, remoteViews, viewId, appWidgetIds, memoryPolicy, networkPolicy, key, tag, errorResId); performRemoteViewInto(action);}/** * Asynchronously fulfills the request into the specified {@link ImageView}. * &lt;p&gt; * &lt;em&gt;Note:&lt;/em&gt; This method keeps a weak reference to the {@link ImageView} instance and will * automatically support object recycling. */public void into(ImageView target) { into(target, null);}/** * Asynchronously fulfills the request into the specified {@link ImageView} and invokes the * target {@link Callback} if it's not {@code null}. * &lt;p&gt; * &lt;em&gt;Note:&lt;/em&gt; The {@link Callback} param is a strong reference and will prevent your * {@link android.app.Activity} or {@link android.app.Fragment} from being garbage collected. If * you use this method, it is &lt;b&gt;strongly&lt;/b&gt; recommended you invoke an adjacent * {@link Picasso#cancelRequest(android.widget.ImageView)} call to prevent temporary leaking. */public void into(ImageView target, Callback callback) { long started = System.nanoTime(); checkMain(); if (target == null) { throw new IllegalArgumentException(\"Target must not be null.\"); } if (!data.hasImage()) { picasso.cancelRequest(target); if (setPlaceholder) { setPlaceholder(target, getPlaceholderDrawable()); } return; } if (deferred) { if (data.hasSize()) { throw new IllegalStateException(\"Fit cannot be used with resize.\"); } int width = target.getWidth(); int height = target.getHeight(); if (width == 0 || height == 0) { if (setPlaceholder) { setPlaceholder(target, getPlaceholderDrawable()); } picasso.defer(target, new DeferredRequestCreator(this, target, callback)); return; } data.resize(width, height); } Request request = createRequest(started); String requestKey = createKey(request); if (shouldReadFromMemoryCache(memoryPolicy)) { Bitmap bitmap = picasso.quickMemoryCacheCheck(requestKey); if (bitmap != null) { picasso.cancelRequest(target); setBitmap(target, picasso.context, bitmap, MEMORY, noFade, picasso.indicatorsEnabled); if (picasso.loggingEnabled) { log(OWNER_MAIN, VERB_COMPLETED, request.plainId(), \"from \" + MEMORY); } if (callback != null) { callback.onSuccess(); } return; } } if (setPlaceholder) { setPlaceholder(target, getPlaceholderDrawable()); } Action action = new ImageViewAction(picasso, target, request, memoryPolicy, networkPolicy, errorResId, errorDrawable, requestKey, tag, callback, noFade); picasso.enqueueAndSubmit(action);} 可以看到5个into()方法，可以看到Picasso常用的是直接往ImageView，但是它的功能远远不止如此，我们可以通过实现Target接口来实现自定义的图片处理，可以用来设背景，可以用来填充布局，可扩展性很强，也支持RemoteView。而我们常用的 123public void into(ImageView target) { into(target, null);} 转到有Callback的执行方法。我们可以通过使用带有回调的into方法来执行图片加载成功或者失败后的事件处理。 1234567891011121314public interface Callback { void onSuccess(); void onError(); public static class EmptyCallback implements Callback { @Override public void onSuccess() { } @Override public void onError() { } }} 看下public void into(ImageView target, Callback callback)这个方法： checkMain() 判断是否为主进程 非空检查。判断target是否为空，uri 或者 resourceId是否为空； deferred是否为true。这个和是否调用fit方法有关。由于fit方法是让图片适应ImageView的大小，所以需要ImageView大小明确之后才执行请求，所以需要延迟执行。 创建Request和requestKey 是否在Cache查找该图片，通过requestKey，这个Key的构建过程和很多内容有关系。 设置占位图片 构建Action并提交 以上就是图片加载的主要过程。 4. 进阶用法(链式使用)主要介绍一下Picasso的其他用法 4.1 noPlaceholder()不设置占位图片，不能于placeHolder同时使用 1234567891011121314151617/** * Explicitly opt-out to having a placeholder set when calling {@code into}. * &lt;p&gt; * By default, Picasso will either set a supplied placeholder or clear the target * {@link ImageView} in order to ensure behavior in situations where views are recycled. This * method will prevent that behavior and retain any already set image. */public RequestCreator noPlaceholder() { if (placeholderResId != 0) { throw new IllegalStateException(\"Placeholder resource already set.\"); } if (placeholderDrawable != null) { throw new IllegalStateException(\"Placeholder image already set.\"); } setPlaceholder = false; return this;} 4.2 placeholder()设置占位图片 123456789101112131415161718/** * A placeholder drawable to be used while the image is being loaded. If the requested image is * not immediately available in the memory cache then this resource will be set on the target * {@link ImageView}. */public RequestCreator placeholder(int placeholderResId) { if (!setPlaceholder) { throw new IllegalStateException(\"Already explicitly declared as no placeholder.\"); } if (placeholderResId == 0) { throw new IllegalArgumentException(\"Placeholder image resource invalid.\"); } if (placeholderDrawable != null) { throw new IllegalStateException(\"Placeholder image already set.\"); } this.placeholderResId = placeholderResId; return this;} 4.3 error()设置加载出错时的图片 1234567891011121314151617181920212223/** An error drawable to be used if the request image could not be loaded. */public RequestCreator error(int errorResId) { if (errorResId == 0) { throw new IllegalArgumentException(\"Error image resource invalid.\"); } if (errorDrawable != null) { throw new IllegalStateException(\"Error image already set.\"); } this.errorResId = errorResId; return this;}/** An error drawable to be used if the request image could not be loaded. */public RequestCreator error(Drawable errorDrawable) { if (errorDrawable == null) { throw new IllegalArgumentException(\"Error image may not be null.\"); } if (errorResId != 0) { throw new IllegalStateException(\"Error image already set.\"); } this.errorDrawable = errorDrawable; return this;} 4.4 tag()设置tag，方便后续pause，cancel，或者resume。这个应该用的比较少，有可能通过tag来cancel一下。 12345678910111213141516171819202122232425262728/** * Assign a tag to this request. Tags are an easy way to logically associate * related requests that can be managed together e.g. paused, resumed, * or canceled. * &lt;p&gt; * You can either use simple {@link String} tags or objects that naturally * define the scope of your requests within your app such as a * {@link android.content.Context}, an {@link android.app.Activity}, or a * {@link android.app.Fragment}. * * &lt;strong&gt;WARNING:&lt;/strong&gt;: Picasso will keep a reference to the tag for * as long as this tag is paused and/or has active requests. Look out for * potential leaks. * * @see Picasso#cancelTag(Object) * @see Picasso#pauseTag(Object) * @see Picasso#resumeTag(Object) */public RequestCreator tag(Object tag) { if (tag == null) { throw new IllegalArgumentException(\"Tag invalid.\"); } if (this.tag != null) { throw new IllegalStateException(\"Tag already set.\"); } this.tag = tag; return this;} 4.5 fit() &amp; unfit()调整图片大小来适配target的边界，这个会导致图片的加载过程在ImageView布局确定之后进行。 12345678910111213141516/** * Attempt to resize the image to fit exactly into the target {@link ImageView}'s bounds. This * will result in delayed execution of the request until the {@link ImageView} has been laid out. * &lt;p&gt; * &lt;em&gt;Note:&lt;/em&gt; This method works only when your target is an {@link ImageView}. */public RequestCreator fit() { deferred = true; return this;}/** Internal use only. Used by {@link DeferredRequestCreator}. */RequestCreator unfit() { deferred = false; return this;} 4.6 resizeDimen() &amp; resize()调整图片大小。 12345678910111213/** Resize the image to the specified dimension size. */public RequestCreator resizeDimen(int targetWidthResId, int targetHeightResId) { Resources resources = picasso.context.getResources(); int targetWidth = resources.getDimensionPixelSize(targetWidthResId); int targetHeight = resources.getDimensionPixelSize(targetHeightResId); return resize(targetWidth, targetHeight);}/** Resize the image to the specified size in pixels. */public RequestCreator resize(int targetWidth, int targetHeight) { data.resize(targetWidth, targetHeight); return this;} 4.7 centerCrop() &amp; centerInside()centerCrop：充满ImageView居中裁剪centerInside： 完整显示图片但是可能无法充满ImageView 123456789101112131415161718/** * Crops an image inside of the bounds specified by {@link #resize(int, int)} rather than * distorting the aspect ratio. This cropping technique scales the image so that it fills the * requested bounds and then crops the extra. */public RequestCreator centerCrop() { data.centerCrop(); return this;}/** * Centers an image inside of the bounds specified by {@link #resize(int, int)}. This scales * the image so that both dimensions are equal to or less than the requested bounds. */public RequestCreator centerInside() { data.centerInside(); return this;} 4.8 onlyScaleDown()当调用了resize 方法重新设置图片尺寸的时候，调用onlyScaleDown 方法，只有当原始图片的尺寸大于我们指定的尺寸时，resize才起作用。 12345678/** * Only resize an image if the original image size is bigger than the target size * specified by {@link #resize(int, int)}. */public RequestCreator onlyScaleDown() { data.onlyScaleDown(); return this;} 4.9 rotate()旋转图片角度，可指定旋转中心点 1234567891011/** Rotate the image by the specified degrees. */public RequestCreator rotate(float degrees) { data.rotate(degrees); return this;}/** Rotate the image by the specified degrees around a pivot point. */public RequestCreator rotate(float degrees, float pivotX, float pivotY) { data.rotate(degrees, pivotX, pivotY); return this;} 4.10 config()设置图片Bitmap格式，如ALPHA_8，ARGB_4444，ARGB_8888，HARDWARE，RGBA_F16，RGB_565等等。 12345678910/** * Attempt to decode the image using the specified config. * &lt;p&gt; * Note: This value may be ignored by {@link BitmapFactory}. See * {@link BitmapFactory.Options#inPreferredConfig its documentation} for more details. */public RequestCreator config(Bitmap.Config config) { data.config(config); return this;} 4.11 stableKey()设置固定Key 12345678/** * Sets the stable key for this request to be used instead of the URI or resource ID when * caching. Two requests with the same value are considered to be for the same resource. */public RequestCreator stableKey(String stableKey) { data.stableKey(stableKey); return this;} 4.12 priority()设置优先级，这个对图片请求的执行顺序有影响，默认的优先级均为NORMAL 1234567891011/** * Set the priority of this request. * &lt;p&gt; * This will affect the order in which the requests execute but does not guarantee it. * By default, all requests have {@link Priority#NORMAL} priority, except for * {@link #fetch()} requests, which have {@link Priority#LOW} priority by default. */public RequestCreator priority(Priority priority) { data.priority(priority); return this;} 4.13 transform()添加自定义Transformation，方便执行图形转换。更多transformation请移步picasso-transformations 12345678910111213141516171819/** * Add a custom transformation to be applied to the image. * &lt;p&gt; * Custom transformations will always be run after the built-in transformations. */// TODO show example of calling resize after a transform in the javadocpublic RequestCreator transform(Transformation transformation) { data.transform(transformation); return this;}/** * Add a list of custom transformations to be applied to the image. * &lt;p&gt; * Custom transformations will always be run after the built-in transformations. */public RequestCreator transform(List&lt;? extends Transformation&gt; transformations) { data.transform(transformations); return this;} 4.14 memoryPolicy()指定memoryPolicy。NO_CACHE，NO_STORENO_CACHE：表示处理请求的时候跳过检查内存缓存NO_STORE: 表示请求成功之后，结果不存到内存。 12345678910111213141516171819202122/** * Specifies the {@link MemoryPolicy} to use for this request. You may specify additional policy * options using the varargs parameter. */public RequestCreator memoryPolicy(MemoryPolicy policy, MemoryPolicy... additional) { if (policy == null) { throw new IllegalArgumentException(\"Memory policy cannot be null.\"); } this.memoryPolicy |= policy.index; if (additional == null) { throw new IllegalArgumentException(\"Memory policy cannot be null.\"); } if (additional.length &gt; 0) { for (MemoryPolicy memoryPolicy : additional) { if (memoryPolicy == null) { throw new IllegalArgumentException(\"Memory policy cannot be null.\"); } this.memoryPolicy |= memoryPolicy.index; } } return this;} 4.15 networkPolicy()指定NetworkPolicy。NO_CACHE，NO_STORE，OFFLINENO_CACHE: 表示处理请求的时候跳过处理磁盘缓存NO_STORE: 表示请求成功后，结果不缓存到Disk。OFFLINE: 强制这次请求从缓存中获取结果，不会发起网络请求，不管缓存中能否获取到结果。 12345678910111213141516171819202122/** * Specifies the {@link NetworkPolicy} to use for this request. You may specify additional policy * options using the varargs parameter. */public RequestCreator networkPolicy(NetworkPolicy policy, NetworkPolicy... additional) { if (policy == null) { throw new IllegalArgumentException(\"Network policy cannot be null.\"); } this.networkPolicy |= policy.index; if (additional == null) { throw new IllegalArgumentException(\"Network policy cannot be null.\"); } if (additional.length &gt; 0) { for (NetworkPolicy networkPolicy : additional) { if (networkPolicy == null) { throw new IllegalArgumentException(\"Network policy cannot be null.\"); } this.networkPolicy |= networkPolicy.index; } } return this;} 4.16 noFade()去掉默认的图片加载过程中的渐入效果 12345/** Disable brief fade in of images loaded from the disk cache or network. */public RequestCreator noFade() { noFade = true; return this;} 5. 其他用法 5.1 get()同步方法，获取Bitmap。所以不要在主线程执行此操作用法： 12345try { Bitmap bitmap = Picasso.with(this).load(URL).get();} catch (IOException e) { e.printStackTrace();} 源码实现： 1234567891011121314151617181920212223/** * Synchronously fulfill this request. Must not be called from the main thread. * &lt;p&gt; * &lt;em&gt;Note&lt;/em&gt;: The result of this operation is not cached in memory because the underlying * {@link Cache} implementation is not guaranteed to be thread-safe. */ public Bitmap get() throws IOException { long started = System.nanoTime(); checkNotMain(); if (deferred) { throw new IllegalStateException(\"Fit cannot be used with get.\"); } if (!data.hasImage()) { return null; } Request finalData = createRequest(started); String key = createKey(finalData, new StringBuilder()); Action action = new GetAction(picasso, finalData, memoryPolicy, networkPolicy, tag, key); return forRequest(picasso, picasso.dispatcher, picasso.cache, picasso.stats, action).hunt(); } 5.2 fetch()毫无结果的获取图片，也没有目标，也没有返回bitmap，难道只是为了暖场？考虑到Picasso有缓存机制，这个方法还是有一点价值的，提前加载放到缓存，后面加载速度会更快。 123456789101112131415161718192021222324252627282930313233343536373839/** * Asynchronously fulfills the request without a {@link ImageView} or {@link Target}, * and invokes the target {@link Callback} with the result. This is useful when you want to warm * up the cache with an image. * &lt;p&gt; * &lt;em&gt;Note:&lt;/em&gt; The {@link Callback} param is a strong reference and will prevent your * {@link android.app.Activity} or {@link android.app.Fragment} from being garbage collected * until the request is completed. */public void fetch(Callback callback) { long started = System.nanoTime(); if (deferred) { throw new IllegalStateException(\"Fit cannot be used with fetch.\"); } if (data.hasImage()) { // Fetch requests have lower priority by default. if (!data.hasPriority()) { data.priority(Priority.LOW); } Request request = createRequest(started); String key = createKey(request, new StringBuilder()); Bitmap bitmap = picasso.quickMemoryCacheCheck(key); if (bitmap != null) { if (picasso.loggingEnabled) { log(OWNER_MAIN, VERB_COMPLETED, request.plainId(), \"from \" + MEMORY); } if (callback != null) { callback.onSuccess(); } } else { Action action = new FetchAction(picasso, request, memoryPolicy, networkPolicy, tag, key, callback); picasso.submit(action); } }} 6. 自定义Picasso默认使用Picasso.with(context)可以快速的构建Picasso实例，但是Picasso支持扩展自定义Picasso，也就是一些默认的配置，我们可以自己来调控。 可以看到Picasso.Builder方法存在很多可配置的内容，downloader, executor, memoryCache,listener等等都是可以自己设置的，配置完成后调用builder()方法即可返回Picasso实例。还可以通过如下方法设置全局Picasso实例。 12345678910111213/** * Set the global instance returned from {@link #with}. * &lt;p&gt; * This method must be called before any calls to {@link #with} and may only be called once. */public static void setSingletonInstance(Picasso picasso) { synchronized (Picasso.class) { if (singleton != null) { throw new IllegalStateException(\"Singleton instance already exists.\"); } singleton = picasso; }} 7. 类图请适当放大后查看。 8. 主要流程图请适当放大后查看。","link":"/2017/10/08/《Android开源库》Picasso/"},{"title":"《Android Framework 之路》Android5.1 MediaScanner","text":"前言 MediaScanner是Android系统中针对媒体文件的扫描过程，将储存空间中的媒体文件通过扫描的方式遍历并存储在数据库中，然后通过MediaProvider提供接口使用，在Android多媒体中占有很重要的位置。 源码位置 packages\\providers\\mediaprovider frameworks\\base\\media\\java\\android\\media frameworks\\av\\media\\libmedia frameworks\\base\\media\\jni frameworks\\av\\media\\libstagefright 扫描过程 MediaScannerReceiver.java (packages\\providers\\mediaprovider\\src\\com\\android\\providers\\media) MediaScannerReceiver继承BroadcastReceiver,在AndroidManifest.xml静态注册 1234567891011121314151617&lt;receiver android:name=\"MediaScannerReceiver\"&gt; &lt;intent-filter&gt; &lt;action android:name=\"android.intent.action.BOOT_COMPLETED\" /&gt; &lt;/intent-filter&gt; &lt;intent-filter&gt; &lt;action android:name=\"android.intent.action.MEDIA_MOUNTED\" /&gt; &lt;data android:scheme=\"file\" /&gt; &lt;/intent-filter&gt; &lt;intent-filter&gt; &lt;action android:name=\"android.intent.action.MEDIA_UNMOUNTED\" /&gt; &lt;data android:scheme=\"file\" /&gt; &lt;/intent-filter&gt; &lt;intent-filter&gt; &lt;action android:name=\"android.intent.action.MEDIA_SCANNER_SCAN_FILE\" /&gt; &lt;data android:scheme=\"file\" /&gt; &lt;/intent-filter&gt; &lt;/receiver&gt; 可以看到，当接收到 android.intent.action.BOOT_COMPLETED android.intent.action.MEDIA_MOUNTED android.intent.action.MEDIA_UNMOUNTED android.intent.action.MEDIA_SCANNER_SCAN_FILE广播的时候，MediaScannerReceiver中的onReceiver()方法将会执行 123456789101112131415161718192021222324252627282930313233343536public void onReceive(Context context, Intent intent) { final String action = intent.getAction(); final Uri uri = intent.getData(); if (Intent.ACTION_BOOT_COMPLETED.equals(action)) { // Scan both internal and external storage scan(context, MediaProvider.INTERNAL_VOLUME); scan(context, MediaProvider.EXTERNAL_VOLUME); } else { if (uri.getScheme().equals(\"file\")) { // handle intents related to external storage String path = uri.getPath(); String externalStoragePath = Environment.getExternalStorageDirectory().getPath(); String legacyPath = Environment.getLegacyExternalStorageDirectory().getPath(); try { path = new File(path).getCanonicalPath(); } catch (IOException e) { Log.e(TAG, \"couldn't canonicalize \" + path); return; } if (path.startsWith(legacyPath)) { path = externalStoragePath + path.substring(legacyPath.length()); } Log.d(TAG, \"action: \" + action + \" path: \" + path); if (Intent.ACTION_MEDIA_MOUNTED.equals(action)) { // scan whenever any volume is mounted scan(context, MediaProvider.EXTERNAL_VOLUME); } else if (Intent.ACTION_MEDIA_SCANNER_SCAN_FILE.equals(action) &amp;&amp; path != null &amp;&amp; path.startsWith(externalStoragePath + \"/\")) { scanFile(context, path); } } } } onReceiver方法中，会执行到scan()或者是scanFile()方法，一个是针对整个卷，一个是针对具体的文件，从传入的参数可以看出眉目，scan传入的是卷名，scanFile传入的是文件路径。通过接收广播启动扫描，然而不管是scan还是scanFile都是以startService的方式启动MediaScannerService。 12345678910111213private void scan(Context context, String volume) { Bundle args = new Bundle(); args.putString(\"volume\", volume); context.startService( new Intent(context, MediaScannerService.class).putExtras(args));}private void scanFile(Context context, String path) { Bundle args = new Bundle(); args.putString(\"filepath\", path); context.startService( new Intent(context, MediaScannerService.class).putExtras(args));} 分别传入卷名或者文件路径。 MediaScannerService.java (packages\\providers\\mediaprovider\\src\\com\\android\\providers\\media) MediaScannerService看下AndroidManifest.xml文件中定义 12345&lt;service android:name=\"MediaScannerService\" android:exported=\"true\"&gt; &lt;intent-filter&gt; &lt;action android:name=\"android.media.IMediaScannerService\" /&gt; &lt;/intent-filter&gt;&lt;/service&gt; 继承Service，实现Runnable接口，首先执行onCreate()方法 12345678910111213public void onCreate(){ PowerManager pm = (PowerManager)getSystemService(Context.POWER_SERVICE); mWakeLock = pm.newWakeLock(PowerManager.PARTIAL_WAKE_LOCK, TAG); StorageManager storageManager = (StorageManager)getSystemService(Context.STORAGE_SERVICE); mExternalStoragePaths = storageManager.getVolumePaths(); // Start up the thread running the service. Note that we create a // separate thread because the service normally runs in the process's // main thread, which we don't want to block. Thread thr = new Thread(null, this, \"MediaScannerService\"); thr.start();} 这里会单独启动一个线程来处理，然后走到onStartCommand() 12345678910111213141516171819202122232425public int onStartCommand(Intent intent, int flags, int startId){ while (mServiceHandler == null) { synchronized (this) { try { wait(100); } catch (InterruptedException e) { } } } if (intent == null) { Log.e(TAG, \"Intent is null in onStartCommand: \", new NullPointerException()); return Service.START_NOT_STICKY; } Message msg = mServiceHandler.obtainMessage(); msg.arg1 = startId; msg.obj = intent.getExtras(); mServiceHandler.sendMessage(msg); // Try again later if we are killed before we can finish scanning. return Service.START_REDELIVER_INTENT;} 这里先等待mServiceHandler创建完成，然后通过handler message机制传递消息给handler处理，这里的mServiceHandler创建过程是在run(）方法中 12345678910111213public void run(){ // reduce priority below other background threads to avoid interfering // with other services at boot time. Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND + Process.THREAD_PRIORITY_LESS_FAVORABLE); Looper.prepare(); mServiceLooper = Looper.myLooper(); mServiceHandler = new ServiceHandler(); Looper.loop();} 由于这个是单独的线程，无法保证在发送消息的时候，handler已经创建完成，所以需要等待handler的创建 看下这个处理消息的handler 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950private final class ServiceHandler extends Handler{ @Override public void handleMessage(Message msg) { Bundle arguments = (Bundle) msg.obj; String filePath = arguments.getString(\"filepath\"); try { if (filePath != null) { IBinder binder = arguments.getIBinder(\"listener\"); IMediaScannerListener listener = (binder == null ? null : IMediaScannerListener.Stub.asInterface(binder)); Uri uri = null; try { uri = scanFile(filePath, arguments.getString(\"mimetype\")); } catch (Exception e) { Log.e(TAG, \"Exception scanning file\", e); } if (listener != null) { listener.scanCompleted(filePath, uri); } } else { String volume = arguments.getString(\"volume\"); String[] directories = null; if (MediaProvider.INTERNAL_VOLUME.equals(volume)) { // scan internal media storage directories = new String[] { Environment.getRootDirectory() + \"/media\", Environment.getOemDirectory() + \"/media\", }; } else if (MediaProvider.EXTERNAL_VOLUME.equals(volume)) { // scan external storage volumes directories = mExternalStoragePaths; } if (directories != null) { if (false) Log.d(TAG, \"start scanning volume \" + volume + \": \" + Arrays.toString(directories)); scan(directories, volume); if (false) Log.d(TAG, \"done scanning volume \" + volume); } } } catch (Exception e) { Log.e(TAG, \"Exception in handleMessage\", e); } stopSelf(msg.arg1); }}; 分别执行scan和scanFile方法 123456789101112131415161718192021222324252627282930private void scan(String[] directories, String volumeName) { Uri uri = Uri.parse(\"file://\" + directories[0]); // don't sleep while scanning mWakeLock.acquire(); try { ContentValues values = new ContentValues(); values.put(MediaStore.MEDIA_SCANNER_VOLUME, volumeName); Uri scanUri = getContentResolver().insert(MediaStore.getMediaScannerUri(), values); sendBroadcast(new Intent(Intent.ACTION_MEDIA_SCANNER_STARTED, uri)); try { if (volumeName.equals(MediaProvider.EXTERNAL_VOLUME)) { openDatabase(volumeName); } MediaScanner scanner = createMediaScanner(); scanner.scanDirectories(directories, volumeName); } catch (Exception e) { Log.e(TAG, \"exception in MediaScanner.scan()\", e); } getContentResolver().delete(scanUri, null, null); } finally { sendBroadcast(new Intent(Intent.ACTION_MEDIA_SCANNER_FINISHED, uri)); mWakeLock.release(); }} 12345678910111213private Uri scanFile(String path, String mimeType) { String volumeName = MediaProvider.EXTERNAL_VOLUME; openDatabase(volumeName); MediaScanner scanner = createMediaScanner(); try { // make sure the file path is in canonical form String canonicalPath = new File(path).getCanonicalPath(); return scanner.scanSingleFile(canonicalPath, volumeName, mimeType); } catch (Exception e) { Log.e(TAG, \"bad path \" + path + \" in scanFile()\", e); return null; }} 两者都是会通过createMediaScanner创建MediaScanner对象，然后通过scanDirectories或者scanSingleFile来对卷或者文件进行扫描，下面我们就只针对scanDirectories进行分析。 MediaScanner.java (base\\media\\java\\android\\media) 1234567891011121314151617181920212223242526272829303132333435363738394041424344public void scanDirectories(String[] directories, String volumeName) { try { long start = System.currentTimeMillis(); initialize(volumeName);//初始化数据库中的一些内容 prescan(null, true); //预扫描 long prescan = System.currentTimeMillis(); //计算预扫描时间 if (ENABLE_BULK_INSERTS) { // create MediaInserter for bulk inserts mMediaInserter = new MediaInserter(mMediaProvider, mPackageName, 500); } for (int i = 0; i &lt; directories.length; i++) { processDirectory(directories[i], mClient); //扫描目录 } if (ENABLE_BULK_INSERTS) { // flush remaining inserts mMediaInserter.flushAll(); mMediaInserter = null; } long scan = System.currentTimeMillis(); postscan(directories); long end = System.currentTimeMillis(); if (false) { Log.d(TAG, \" prescan time: \" + (prescan - start) + \"ms\\n\"); Log.d(TAG, \" scan time: \" + (scan - prescan) + \"ms\\n\"); Log.d(TAG, \"postscan time: \" + (end - scan) + \"ms\\n\"); Log.d(TAG, \" total time: \" + (end - start) + \"ms\\n\"); } } catch (SQLException e) { // this might happen if the SD card is removed while the media scanner is running Log.e(TAG, \"SQLException in MediaScanner.scan()\", e); } catch (UnsupportedOperationException e) { // this might happen if the SD card is removed while the media scanner is running Log.e(TAG, \"UnsupportedOperationException in MediaScanner.scan()\", e); } catch (RemoteException e) { Log.e(TAG, \"RemoteException in MediaScanner.scan()\", e); } finally { releaseResources(); } } 这里面比较重要的几个内容，一个是prescan，一个是processDirectory 先看看prescan 1234567891011121314151617181920212223242526272829303132333435363738394041424344Uri limitUri = mFilesUri.buildUpon().appendQueryParameter(\"limit\", \"1000\").build(); //查询条数为1000条mWasEmptyPriorToScan = true;while (true) { selectionArgs[0] = \"\" + lastId; if (c != null) { c.close(); c = null; } c = mMediaProvider.query(mPackageName, limitUri, FILES_PRESCAN_PROJECTION, where, selectionArgs, MediaStore.Files.FileColumns._ID, null); if (c == null) { break; } int num = c.getCount(); if (num == 0) { break; } mWasEmptyPriorToScan = false; while (c.moveToNext()) { long rowId = c.getLong(FILES_PRESCAN_ID_COLUMN_INDEX); String path = c.getString(FILES_PRESCAN_PATH_COLUMN_INDEX); int format = c.getInt(FILES_PRESCAN_FORMAT_COLUMN_INDEX); long lastModified = c.getLong(FILES_PRESCAN_DATE_MODIFIED_COLUMN_INDEX); lastId = rowId; //查询id,路径，格式和最后修改时间 // Only consider entries with absolute path names. // This allows storing URIs in the database without the // media scanner removing them. if (path != null &amp;&amp; path.startsWith(\"/\")) { boolean exists = false; try { exists = Os.access(path, android.system.OsConstants.F_OK); } catch (ErrnoException e1) { } ...... } } } }} 这里主要就是注意下最后修改时间，后面扫描的过程中应该会用到。 再看下processDirectory,native方法 android_media_MediaScanner.cpp (base\\media\\jni) 12345678910111213141516171819202122232425262728static voidandroid_media_MediaScanner_processDirectory( JNIEnv *env, jobject thiz, jstring path, jobject client){ ALOGV(\"processDirectory\"); MediaScanner *mp = getNativeScanner_l(env, thiz); if (mp == NULL) { jniThrowException(env, kRunTimeException, \"No scanner available\"); return; } if (path == NULL) { jniThrowException(env, kIllegalArgumentException, NULL); return; } const char *pathStr = env-&gt;GetStringUTFChars(path, NULL); if (pathStr == NULL) { // Out of memory return; } MyMediaScannerClient myClient(env, client); MediaScanResult result = mp-&gt;processDirectory(pathStr, myClient); if (result == MEDIA_SCAN_RESULT_ERROR) { ALOGE(\"An error occurred while scanning directory '%s'.\", pathStr); } env-&gt;ReleaseStringUTFChars(path, pathStr);} 从MediaScanner.java一直跟过来，忘记了MediaScanner.java中有一个比较重要的内容 1234static { System.loadLibrary(\"media_jni\"); native_init();} 这里加载libmedia_jni.so即上面会用到的android_media_MediaScanner.cpp就是存在于这个so中， 1private static native final void native_init(); 123456789101112131415static voidandroid_media_MediaScanner_native_init(JNIEnv *env){ ALOGV(\"native_init\"); jclass clazz = env-&gt;FindClass(kClassMediaScanner); //这里指的是static const char* const kClassMediaScanner =\"android/media/MediaScanner\";也就是后面会用到的MediaScanner.cpp if (clazz == NULL) { return; } fields.context = env-&gt;GetFieldID(clazz, \"mNativeContext\", \"J\"); if (fields.context == NULL) { return; }} 在创建MediaScanner对象的过程中 123456789101112131415 public MediaScanner(Context c) { native_setup(); mContext = c; mPackageName = c.getPackageName(); mBitmapOptions.inSampleSize = 1; mBitmapOptions.inJustDecodeBounds = true; setDefaultRingtoneFileNames(); mExternalStoragePath = Environment.getExternalStorageDirectory().getAbsolutePath(); mExternalIsEmulated = Environment.isExternalStorageEmulated(); //mClient.testGenreNameConverter(); }......private native final void native_setup();//native方法 12345678910111213static voidandroid_media_MediaScanner_native_setup(JNIEnv *env, jobject thiz){ ALOGV(\"native_setup\"); MediaScanner *mp = new StagefrightMediaScanner;//这里采用的是StagefrightMediaScanner if (mp == NULL) { jniThrowException(env, kRunTimeException, \"Out of memory\"); return; } env-&gt;SetLongField(thiz, fields.context, (jlong)mp);//set操作一下，后面会用到} 再回到processDirectory方法中来， MediaScanner *mp = getNativeScanner_l(env, thiz);拿到MediaScaner的cpp对象 MyMediaScannerClient myClient(env, client); //创建MyMediaScannerClient对象，而这里传入的client是MediaScanner.java中的MyMediaScannerClient对象 MediaScanResult result = mp-&gt;processDirectory(pathStr, myClient); //执行processDirectory方法，传入myClient对象 这样传来传去无非就是想保存下当前的java侧的一个client,后面会有妙用？ StagefrightMediaScanner继承MediaScanner，没有实现processDirectory方法，使用的是父类中的方法 12345678MediaScanResult MediaScanner::processDirectory( const char *path, MediaScannerClient &amp;client) { ...... MediaScanResult result = doProcessDirectory(pathBuffer, pathRemaining, client, false); free(pathBuffer); return result;} 123456789101112MediaScanResult MediaScanner::doProcessDirectory( char *path, int pathRemaining, MediaScannerClient &amp;client, bool noMedia) { ...... while ((entry = readdir(dir))) { if (doProcessDirectoryEntry(path, pathRemaining, client, noMedia, entry, fileSpot) == MEDIA_SCAN_RESULT_ERROR) { result = MEDIA_SCAN_RESULT_ERROR; break; } }} 123456789101112131415161718192021222324252627282930313233MediaScanResult MediaScanner::doProcessDirectoryEntry( char *path, int pathRemaining, MediaScannerClient &amp;client, bool noMedia, struct dirent* entry, char* fileSpot) { ...... if (type == DT_DIR) { //如果是目录，继续遍历子节点 bool childNoMedia = noMedia; // set noMedia flag on directories with a name that starts with '.' // for example, the Mac \".Trashes\" directory if (name[0] == '.') childNoMedia = true; // report the directory to the client if (stat(path, &amp;statbuf) == 0) { status_t status = client.scanFile(path, statbuf.st_mtime, 0, true /*isDirectory*/, childNoMedia); if (status) { return MEDIA_SCAN_RESULT_ERROR; } } // and now process its contents strcat(fileSpot, \"/\"); MediaScanResult result = doProcessDirectory(path, pathRemaining - nameLength - 1, client, childNoMedia); if (result == MEDIA_SCAN_RESULT_ERROR) { return MEDIA_SCAN_RESULT_ERROR; } } else if (type == DT_REG) { //如果是普通文件，执行scanFile操作 stat(path, &amp;statbuf); status_t status = client.scanFile(path, statbuf.st_mtime, statbuf.st_size, false /*isDirectory*/, noMedia); ...... } 这里注意一下，使用的client就是之前传入的参数，最终会调用会MediaScanner.java中MyMediaScannerClient中的scanFile方法 123456public void scanFile(String path, long lastModified, long fileSize, boolean isDirectory, boolean noMedia) { // This is the callback funtion from native codes. // Log.v(TAG, \"scanFile: \"+path); doScanFile(path, null, lastModified, fileSize, isDirectory, false, noMedia);} 123456789101112131415161718192021222324252627public Uri doScanFile(String path, String mimeType, long lastModified, long fileSize, boolean isDirectory, boolean scanAlways, boolean noMedia) { ...... try { FileEntry entry = beginFile(path, mimeType, lastModified, fileSize, isDirectory, noMedia); //beginFile创建FileEntry ...... // rescan for metadata if file was modified since last scan if (entry != null &amp;&amp; (entry.mLastModifiedChanged || scanAlways)) { if (noMedia) { result = endFile(entry, false, false, false, false, false); } else { ...... // we only extract metadata for audio and video files if (isaudio || isvideo) { processFile(path, mimeType, this);//处理音频视频文件 } if (isimage) { processImageFile(path);//处理图片文件 } result = endFile(entry, ringtones, notifications, alarms, music, podcasts); } ...... } 下面看下音频文件的处理 processFile(path, mimeType, this)，注意这里传入的参数有路径和mimetype 1private native void processFile(String path, String mimeType, MediaScannerClient client); 跟到android_media_MediaScanner.cpp 12MyMediaScannerClient myClient(env, client);MediaScanResult result = mp-&gt;processFile(pathStr, mimeTypeStr, myClient); 然后跟到 StagefrightMediaScanner.cpp (av\\include\\media\\stagefright) 1234567891011MediaScanResult StagefrightMediaScanner::processFile( const char *path, const char *mimeType, MediaScannerClient &amp;client) { ALOGV(\"processFile '%s'.\", path); client.setLocale(locale()); client.beginFile(); MediaScanResult result = processFileInternal(path, mimeType, client); client.endFile(); return result;} 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960MediaScanResult StagefrightMediaScanner::processFileInternal( const char *path, const char * /* mimeType */, MediaScannerClient &amp;client) { ...... sp&lt;MediaMetadataRetriever&gt; mRetriever(new MediaMetadataRetriever); //创建解析实例 int fd = open(path, O_RDONLY | O_LARGEFILE); status_t status; if (fd &lt; 0) { //设置数据源 // couldn't open it locally, maybe the media server can? status = mRetriever-&gt;setDataSource(NULL /* httpService */, path); } else { status = mRetriever-&gt;setDataSource(fd, 0, 0x7ffffffffffffffL); close(fd); } ...... const char *value; if ((value = mRetriever-&gt;extractMetadata(//解析元数据 METADATA_KEY_MIMETYPE)) != NULL) { status = client.setMimeType(value); if (status) { return MEDIA_SCAN_RESULT_ERROR; } } struct KeyMap { const char *tag; int key; }; static const KeyMap kKeyMap[] = { { \"tracknumber\", METADATA_KEY_CD_TRACK_NUMBER }, { \"discnumber\", METADATA_KEY_DISC_NUMBER }, { \"album\", METADATA_KEY_ALBUM }, { \"artist\", METADATA_KEY_ARTIST }, { \"albumartist\", METADATA_KEY_ALBUMARTIST }, { \"composer\", METADATA_KEY_COMPOSER }, { \"genre\", METADATA_KEY_GENRE }, { \"title\", METADATA_KEY_TITLE }, { \"year\", METADATA_KEY_YEAR }, { \"duration\", METADATA_KEY_DURATION }, { \"writer\", METADATA_KEY_WRITER }, { \"compilation\", METADATA_KEY_COMPILATION }, { \"isdrm\", METADATA_KEY_IS_DRM }, { \"width\", METADATA_KEY_VIDEO_WIDTH }, { \"height\", METADATA_KEY_VIDEO_HEIGHT }, }; static const size_t kNumEntries = sizeof(kKeyMap) / sizeof(kKeyMap[0]); for (size_t i = 0; i &lt; kNumEntries; ++i) { const char *value; if ((value = mRetriever-&gt;extractMetadata(kKeyMap[i].key)) != NULL) { status = client.addStringTag(kKeyMap[i].tag, value); if (status != OK) { return MEDIA_SCAN_RESULT_ERROR; } } } return MEDIA_SCAN_RESULT_OK;} 这里创建的MediaMetadataRetriever并不是MediaMetadataRetriver本身，而是一个之类，StagefrightMetadataRetriver，中间有一个过程，我们来看下。 123456789101112131415MediaMetadataRetriever::MediaMetadataRetriever(){ ALOGV(\"constructor\"); const sp&lt;IMediaPlayerService&gt;&amp; service(getService()); if (service == 0) { ALOGE(\"failed to obtain MediaMetadataRetrieverService\"); return; } sp&lt;IMediaMetadataRetriever&gt; retriever(service-&gt;createMetadataRetriever()); //创建元数据解析对象 if (retriever == 0) { ALOGE(\"failed to create IMediaMetadataRetriever object from server\"); } mRetriever = retriever;//赋值给mRetriver} 这里的service是MediaPlayerService，这里使用的代理，实现直接看MediaPlayerService.cpp中的函数 12345678sp&lt;IMediaMetadataRetriever&gt; MediaPlayerService::createMetadataRetriever(){ pid_t pid = IPCThreadState::self()-&gt;getCallingPid(); sp&lt;MetadataRetrieverClient&gt; retriever = new MetadataRetrieverClient(pid); //这里创建了MetadataRetrieverClient对象 ALOGV(\"Create new media retriever from pid %d\", pid); return retriever;} MetadataRetrieverClient.cpp (av\\media\\libmediaplayerservice) 12345678MetadataRetrieverClient::MetadataRetrieverClient(pid_t pid){ ALOGV(\"MetadataRetrieverClient constructor pid(%d)\", pid); mPid = pid; mThumbnail = NULL; mAlbumArt = NULL; mRetriever = NULL;} 显然上面创建的东西只是一个空壳，继续往下看 在processFileInternal函数中setDataSource函数中同样会跟到 1234567891011121314151617181920status_t MetadataRetrieverClient::setDataSource(int fd, int64_t offset, int64_t length){ ...... player_type playerType = MediaPlayerFactory::getPlayerType(NULL /* client */, fd, offset, length); //获取playertype方便后面选择对应的元数据解析器 ALOGV(\"player type = %d\", playerType); sp&lt;MediaMetadataRetrieverBase&gt; p = createRetriever(playerType);//创建实际的metadataretriver if (p == NULL) { ::close(fd); return NO_INIT; } status_t status = p-&gt;setDataSource(fd, offset, length); if (status == NO_ERROR) mRetriever = p; ::close(fd); return status;} 12345678910111213141516171819202122232425static sp&lt;MediaMetadataRetrieverBase&gt; createRetriever(player_type playerType){ sp&lt;MediaMetadataRetrieverBase&gt; p; switch (playerType) { case STAGEFRIGHT_PLAYER: case NU_PLAYER: { p = new StagefrightMetadataRetriever;//这里才是我们实际使用的MedadataRetriver break; } case SONIVOX_PLAYER: ALOGV(\"create midi metadata retriever\"); p = new MidiMetadataRetriever(); break; default: // TODO: // support for TEST_PLAYER ALOGE(\"player type %d is not supported\", playerType); break; } if (p == NULL) { ALOGE(\"failed to create a retriever object\"); } return p;} StagefrightMetadataRetriever.cpp (av\\media\\libstagefright) 那么然后执行setDataSouce() 1234567// Warning caller retains ownership of the filedescriptor! Dup it if necessary.status_t StagefrightMetadataRetriever::setDataSource( int fd, int64_t offset, int64_t length) { ...... mExtractor = MediaExtractor::Create(mSource);//创建媒体解析器 ......} setDataSouce()有两个方法，传入的参数不用，另外一个是针对在线媒体的 然后就是创建媒体解析器 MediaExtractor.cpp (av\\media\\libstagefright) 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455sp&lt;MediaExtractor&gt; MediaExtractor::Create( const sp&lt;DataSource&gt; &amp;source, const char *mime) { ...... //如果Mimetype为null,匹配出最符合的mimetype if (mime == NULL) { float confidence; if (!source-&gt;sniff(&amp;tmp, &amp;confidence, &amp;meta)) { ALOGV(\"FAILED to autodetect media content.\"); return NULL; } mime = tmp.string(); ALOGV(\"Autodetected media content as '%s' with confidence %.2f\", mime, confidence); } ...... MediaExtractor *ret = NULL; //不同的mimetype对应不同的extractor if (!strcasecmp(mime, MEDIA_MIMETYPE_CONTAINER_MPEG4) || !strcasecmp(mime, \"audio/mp4\")) { ret = new MPEG4Extractor(source); } else if (!strcasecmp(mime, MEDIA_MIMETYPE_AUDIO_MPEG)) { ret = new MP3Extractor(source, meta); } else if (!strcasecmp(mime, MEDIA_MIMETYPE_AUDIO_AMR_NB) || !strcasecmp(mime, MEDIA_MIMETYPE_AUDIO_AMR_WB)) { ret = new AMRExtractor(source); } else if (!strcasecmp(mime, MEDIA_MIMETYPE_AUDIO_FLAC)) { ret = new FLACExtractor(source); } else if (!strcasecmp(mime, MEDIA_MIMETYPE_CONTAINER_WAV)) { ret = new WAVExtractor(source); } else if (!strcasecmp(mime, MEDIA_MIMETYPE_CONTAINER_OGG)) { ret = new OggExtractor(source); } else if (!strcasecmp(mime, MEDIA_MIMETYPE_CONTAINER_MATROSKA)) { ret = new MatroskaExtractor(source); } else if (!strcasecmp(mime, MEDIA_MIMETYPE_CONTAINER_MPEG2TS)) { ret = new MPEG2TSExtractor(source); } else if (!strcasecmp(mime, MEDIA_MIMETYPE_CONTAINER_WVM)) { // Return now. WVExtractor should not have the DrmFlag set in the block below. return new WVMExtractor(source); } else if (!strcasecmp(mime, MEDIA_MIMETYPE_AUDIO_AAC_ADTS)) { ret = new AACExtractor(source, meta); } else if (!strcasecmp(mime, MEDIA_MIMETYPE_CONTAINER_MPEG2PS)) { ret = new MPEG2PSExtractor(source); } if (ret != NULL) { if (isDrm) { ret-&gt;setDrmFlag(true); } else { ret-&gt;setDrmFlag(false); } } return ret;} 针对mimetype为空的情况 DataSource.cpp (av\\media\\libstagefright) 1234567891011121314151617181920212223242526272829bool DataSource::sniff( String8 *mimeType, float *confidence, sp&lt;AMessage&gt; *meta) { *mimeType = \"\";//mimetype *confidence = 0.0f;//可信度 meta-&gt;clear(); { Mutex::Autolock autoLock(gSnifferMutex); if (!gSniffersRegistered) {//如果没有嗅探器直接return return false; } } for (List&lt;SnifferFunc&gt;::iterator it = gSniffers.begin(); it != gSniffers.end(); ++it) { String8 newMimeType; float newConfidence; sp&lt;AMessage&gt; newMeta; if ((*it)(this, &amp;newMimeType, &amp;newConfidence, &amp;newMeta)) { if (newConfidence &gt; *confidence) { *mimeType = newMimeType; *confidence = newConfidence; *meta = newMeta; } } } //遍历所有的嗅探器，找到可信度最高的 return *confidence &gt; 0.0;} 到这里对应的mimetype和extractor都明确了，再回到StagefrightMediaScanner.cpp中processFileInternal函数，执行完了setDataSouce，执行extractMetadata，依然是跟到StagefrightMetadataRetriver.cpp中 123456789101112131415161718const char *StagefrightMetadataRetriever::extractMetadata(int keyCode) { if (mExtractor == NULL) { return NULL; } if (!mParsedMetaData) { parseMetaData();//如果没有解析，就解析一下 mParsedMetaData = true;//标识一下，已经解析过了 } ssize_t index = mMetaData.indexOfKey(keyCode); if (index &lt; 0) { return NULL; } return mMetaData.valueAt(index).string();//如果解析过就直接放回对应的内容即可} 再看下parseMetaData函数，这个函数比较长，主要看下一部分 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849static const Map kMap[] = { { kKeyMIMEType, METADATA_KEY_MIMETYPE, NULL }, { kKeyCDTrackNumber, METADATA_KEY_CD_TRACK_NUMBER, \"tracknumber\" }, { kKeyDiscNumber, METADATA_KEY_DISC_NUMBER, \"discnumber\" }, { kKeyAlbum, METADATA_KEY_ALBUM, \"album\" }, { kKeyArtist, METADATA_KEY_ARTIST, \"artist\" }, { kKeyAlbumArtist, METADATA_KEY_ALBUMARTIST, \"albumartist\" }, { kKeyAuthor, METADATA_KEY_AUTHOR, NULL }, { kKeyComposer, METADATA_KEY_COMPOSER, \"composer\" }, { kKeyDate, METADATA_KEY_DATE, NULL }, { kKeyGenre, METADATA_KEY_GENRE, \"genre\" }, { kKeyTitle, METADATA_KEY_TITLE, \"title\" }, { kKeyYear, METADATA_KEY_YEAR, \"year\" }, { kKeyWriter, METADATA_KEY_WRITER, \"writer\" }, { kKeyCompilation, METADATA_KEY_COMPILATION, \"compilation\" }, { kKeyLocation, METADATA_KEY_LOCATION, NULL },};static const size_t kNumMapEntries = sizeof(kMap) / sizeof(kMap[0]);//创建字符集探测器，这个内容是L版本新加的内容CharacterEncodingDetector *detector = new CharacterEncodingDetector();for (size_t i = 0; i &lt; kNumMapEntries; ++i) { const char *value; if (meta-&gt;findCString(kMap[i].from, &amp;value)) { if (kMap[i].name) { // add to charset detector detector-&gt;addTag(kMap[i].name, value);//加入探测器 } else { // directly add to output list mMetaData.add(kMap[i].to, String8(value)); } }}detector-&gt;detectAndConvert();//探测器中执行字符集的探测和转换int size = detector-&gt;size();if (size) { for (int i = 0; i &lt; size; i++) { const char *name; const char *value; detector-&gt;getTag(i, &amp;name, &amp;value); for (size_t j = 0; j &lt; kNumMapEntries; ++j) { if (kMap[j].name &amp;&amp; !strcmp(kMap[j].name, name)) { mMetaData.add(kMap[j].to, String8(value));//最后的数据保存 } } }} 此函数中其他的内容也是解析一些其他的元数据报保存下来。 再回到processFileInternal中，在解析完元数据之后 123456789for (size_t i = 0; i &lt; kNumEntries; ++i) { const char *value; if ((value = mRetriever-&gt;extractMetadata(kKeyMap[i].key)) != NULL) { status = client.addStringTag(kKeyMap[i].tag, value); if (status != OK) { return MEDIA_SCAN_RESULT_ERROR; } }} 将数据一个一个通过client的addStringTag往上传递，跟下此过程 MediaScannerClient.cpp (av\\media\\libmedia) 12345status_t MediaScannerClient::addStringTag(const char* name, const char* value){ handleStringTag(name, value); return OK;} 最后会回到MediaScanner.java中的handleStringTag() 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647public void handleStringTag(String name, String value) { if (name.equalsIgnoreCase(\"title\") || name.startsWith(\"title;\")) { // Don't trim() here, to preserve the special \\001 character // used to force sorting. The media provider will trim() before // inserting the title in to the database. mTitle = value; } else if (name.equalsIgnoreCase(\"artist\") || name.startsWith(\"artist;\")) { mArtist = value.trim(); } else if (name.equalsIgnoreCase(\"albumartist\") || name.startsWith(\"albumartist;\") || name.equalsIgnoreCase(\"band\") || name.startsWith(\"band;\")) { mAlbumArtist = value.trim(); } else if (name.equalsIgnoreCase(\"album\") || name.startsWith(\"album;\")) { mAlbum = value.trim(); } else if (name.equalsIgnoreCase(\"composer\") || name.startsWith(\"composer;\")) { mComposer = value.trim(); } else if (mProcessGenres &amp;&amp; (name.equalsIgnoreCase(\"genre\") || name.startsWith(\"genre;\"))) { mGenre = getGenreName(value); } else if (name.equalsIgnoreCase(\"year\") || name.startsWith(\"year;\")) { mYear = parseSubstring(value, 0, 0); } else if (name.equalsIgnoreCase(\"tracknumber\") || name.startsWith(\"tracknumber;\")) { // track number might be of the form \"2/12\" // we just read the number before the slash int num = parseSubstring(value, 0, 0); mTrack = (mTrack / 1000) * 1000 + num; } else if (name.equalsIgnoreCase(\"discnumber\") || name.equals(\"set\") || name.startsWith(\"set;\")) { // set number might be of the form \"1/3\" // we just read the number before the slash int num = parseSubstring(value, 0, 0); mTrack = (num * 1000) + (mTrack % 1000); } else if (name.equalsIgnoreCase(\"duration\")) { mDuration = parseSubstring(value, 0, 0); } else if (name.equalsIgnoreCase(\"writer\") || name.startsWith(\"writer;\")) { mWriter = value.trim(); } else if (name.equalsIgnoreCase(\"compilation\")) { mCompilation = parseSubstring(value, 0, 0); } else if (name.equalsIgnoreCase(\"isdrm\")) { mIsDrm = (parseSubstring(value, 0, 0) == 1); } else if (name.equalsIgnoreCase(\"width\")) { mWidth = parseSubstring(value, 0, 0); } else if (name.equalsIgnoreCase(\"height\")) { mHeight = parseSubstring(value, 0, 0); } else { //Log.v(TAG, \"unknown tag: \" + name + \" (\" + mProcessGenres + \")\"); }} 对应的数据已经被传递到了Java侧，剩下的就比较好处理了 本文只是跟了一条大致的代码流程，先到此，后续有可能还要更新一下。 本文中代码使用的是Android5.1原始代码，欢迎大家留言交流。","link":"/2015/10/07/《Android Framework 之路》Android5.1 MediaScanner/"},{"title":"《Android 开源库》 FlycoTabLayout 从头到脚","text":"简介 FlycoTabLayout，是一个比Google原生TabLayout 功能更强大的TabLayout库。目前有3种TabLayout： SlidingTabLayout CommonTabLayout SegmentTabLayout 具体介绍和使用方法参考开源库的Wiki 官方示例： 源码分析共有属性名称 | 格式 | 描述 -------------------------- | --------- | ---------------------------------- tl_indicator_color | color | 设置显示器颜色 tl_indicator_height | dimension | 设置显示器高度 tl_indicator_margin_left | dimension | 设置显示器margin,当indicator_width大于0,无效 tl_indicator_margin_top | dimension | 设置显示器margin,当indicator_width大于0,无效 tl_indicator_margin_right | dimension | 设置显示器margin,当indicator_width大于0,无效 tl_indicator_margin_bottom | dimension | 设置显示器margin,当indicator_width大于0,无效 tl_indicator_corner_radius | dimension | 设置显示器圆角弧度 tl_divider_color | color | 设置分割线颜色 tl_divider_width | dimension | 设置分割线宽度 tl_divider_padding | dimension | 设置分割线的paddingTop和paddingBottom tl_tab_padding | dimension | 设置tab的paddingLeft和paddingRight tl_tab_space_equal | boolean | 设置tab大小等分 tl_tab_width | dimension | 设置tab固定大小 tl_textsize | dimension | 设置字体大小 tl_textSelectColor | color | 设置字体选中颜色 tl_textUnselectColor | color | 设置字体未选中颜色 tl_textBold | boolean | 设置字体加粗 tl_textAllCaps | boolean | 设置字体全大写 1. SlidingTabLayout1.1 特有属性特有属性 | 格式 | 描述 ------------------------------ | --------- | ------------------------------------------ tl_indicator_width | dimension | 设置显示器固定宽度 tl_indicator_gravity | enum | 设置显示器上方(TOP)还是下方(BOTTOM),只对常规显示器有用 tl_indicator_style | enum | 设置显示器为常规(NORMAL)或三角形(TRIANGLE)或背景色块(BLOCK) tl_indicator_width_equal_title | boolean | 设置显示器与标题一样长(only for SlidingTabLayout) tl_underline_color | color | 设置下划线颜色 tl_underline_height | dimension | 设置下划线高度 tl_underline_gravity | enum | 设置下划线上方(TOP)还是下方(BOTTOM) 1.2 类结构1.2.1 构造方法 第一个调用第二个，第二个调用第三个，第三个获取自定义属性值。 123456789101112131415161718192021222324252627public SlidingTabLayout(Context context, AttributeSet attrs, int defStyleAttr) { super(context, attrs, defStyleAttr); setFillViewport(true);//设置滚动视图是否可以伸缩其内容以填充视口 setWillNotDraw(false);//重写onDraw方法,需要调用这个方法来清除flag setClipChildren(false);//不限制child在其范围内绘制 setClipToPadding(false);//滚动时child可以绘制到padding区域 this.mContext = context; mTabsContainer = new LinearLayout(context);//tab容器 addView(mTabsContainer);//添加到HorizontalScrollView中 obtainAttributes(context, attrs);//获取自定义属性，常用的方法，TypedArray记得回收 //获取layout_height属性的值，这个方法比较溜，之前没见过 String height = attrs.getAttributeValue(&quot;http://schemas.android.com/apk/res/android&quot;, &quot;layout_height&quot;); //针对height做处理 if (height.equals(ViewGroup.LayoutParams.MATCH_PARENT + &quot;&quot;)) { } else if (height.equals(ViewGroup.LayoutParams.WRAP_CONTENT + &quot;&quot;)) { } else { int[] systemAttrs = {android.R.attr.layout_height}; TypedArray a = context.obtainStyledAttributes(attrs, systemAttrs); //获取高度 mHeight = a.getDimensionPixelSize(0, ViewGroup.LayoutParams.WRAP_CONTENT); a.recycle(); }} 1.2.2 ViewPager 方法 | 描述 ------------------------------------------------------- | -------------------- setViewPager(ViewPager vp) | 设置ViewPager内容 public void setViewPager(ViewPager vp, String[] titles) | 设置ViewPager内容和标签页的标题12345678910111213/** 关联ViewPager */public void setViewPager(ViewPager vp) { if (vp == null || vp.getAdapter() == null) { throw new IllegalStateException(&quot;ViewPager or ViewPager adapter can not be NULL !&quot;); } /*本地赋值*/ this.mViewPager = vp; /*重新绑定OnPageChangeListener*/ this.mViewPager.removeOnPageChangeListener(this); this.mViewPager.addOnPageChangeListener(this); /*viewpager变化，tab页响应处理处理*/ notifyDataSetChanged();} 123456789101112131415/** 更新数据 */public void notifyDataSetChanged() { mTabsContainer.removeAllViews();//清空tab this.mTabCount = mTitles == null ? mViewPager.getAdapter().getCount() : mTitles.size();//获取tab数量，优先级mTitles &gt; ViewPager的默认标题 /*添加tab*/ View tabView; for (int i = 0; i &lt; mTabCount; i++) { tabView = View.inflate(mContext, R.layout.layout_tab, null); CharSequence pageTitle = mTitles == null ? mViewPager.getAdapter().getPageTitle(i) : mTitles.get(i); addTab(i, pageTitle.toString(), tabView); } //更新选中未选中状态更新tab updateTabStyles();} 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950/** 创建并添加tab */ private void addTab(final int position, String title, View tabView) { //设置标题 TextView tv_tab_title = (TextView) tabView.findViewById(R.id.tv_tab_title); if (tv_tab_title != null) { if (title != null) tv_tab_title.setText(title); } //绑定点击事件，与ViewPager联动 tabView.setOnClickListener(new OnClickListener() { @Override public void onClick(View v) { int position = mTabsContainer.indexOfChild(v); if (position != -1) { if (mViewPager.getCurrentItem() != position) { if (mSnapOnTabClick) { // transition immediately mViewPager.setCurrentItem(position, false); } else { //smoothly scroll to mViewPager.setCurrentItem(position); } if (mListener != null) { //自定义tab点击事件处理 mListener.onTabSelect(position); } } else { if (mListener != null) { //自定义Reselect事件处理 mListener.onTabReselect(position); } } } } }); /** 每一个Tab的布局参数，mTabSpaceEqual 属性控制是否均分 */ LinearLayout.LayoutParams lp_tab = mTabSpaceEqual ? new LinearLayout.LayoutParams(0, LayoutParams.MATCH_PARENT, 1.0f) : new LinearLayout.LayoutParams( LayoutParams.WRAP_CONTENT, LayoutParams.MATCH_PARENT); if (mTabWidth &gt; 0) { lp_tab = new LinearLayout.LayoutParams((int) mTabWidth, LayoutParams.MATCH_PARENT); } //添加到Tab容器 mTabsContainer.addView(tabView, position, lp_tab); } 123456789101112131415161718192021private void updateTabStyles() { //遍历设置标题选中颜色，未选中颜色，字体大小，大小写，粗体字 for (int i = 0; i &lt; mTabCount; i++) { View v = mTabsContainer.getChildAt(i); TextView tv_tab_title = (TextView) v.findViewById(R.id.tv_tab_title); if (tv_tab_title != null) { tv_tab_title.setTextColor(i == mCurrentTab ? mTextSelectColor : mTextUnselectColor); tv_tab_title.setTextSize(TypedValue.COMPLEX_UNIT_PX, mTextsize); tv_tab_title.setPadding((int) mTabPadding, 0, (int) mTabPadding, 0); if (mTextAllCaps) { tv_tab_title.setText(tv_tab_title.getText().toString().toUpperCase()); } if (mTextBold == TEXT_BOLD_BOTH) { tv_tab_title.getPaint().setFakeBoldText(true); } else if (mTextBold == TEXT_BOLD_NONE) { tv_tab_title.getPaint().setFakeBoldText(false); } } }} 方法 | 描述 ------------------------------------------------------------------------------------------------------- | --------------------------------------------------------------------- setViewPager(ViewPager vp, String[] titles, FragmentActivity fa, ArrayList&amp;lt; Fragment &amp;gt; fragments) | 设置ViewPager，标题内容，FragmentActivity和用于显示的Fragment,用来设置ViewPager的Adapter123456789101112131415161718/** 关联ViewPager,用于连适配器都不想自己实例化的情况 */public void setViewPager(ViewPager vp, String[] titles, FragmentActivity fa, ArrayList&lt;Fragment&gt; fragments) { if (vp == null) { throw new IllegalStateException(&quot;ViewPager can not be NULL !&quot;); } if (titles == null || titles.length == 0) { throw new IllegalStateException(&quot;Titles can not be EMPTY !&quot;); } this.mViewPager = vp; /*通过传入的参数构建FragmentPagerAdapter，设置到ViewPager*/ this.mViewPager.setAdapter(new InnerPagerAdapter(fa.getSupportFragmentManager(), fragments, titles)); this.mViewPager.removeOnPageChangeListener(this); this.mViewPager.addOnPageChangeListener(this); notifyDataSetChanged();} 看下这个内部的InnerPagerAdapter,静态Fragment,不销毁重建，只更新数据内容。 123456789101112131415161718192021222324252627282930313233343536class InnerPagerAdapter extends FragmentPagerAdapter { private ArrayList&lt;Fragment&gt; fragments = new ArrayList&lt;&gt;(); private String[] titles; public InnerPagerAdapter(FragmentManager fm, ArrayList&lt;Fragment&gt; fragments, String[] titles) { super(fm); this.fragments = fragments; this.titles = titles; } @Override public int getCount() { return fragments.size(); } @Override public CharSequence getPageTitle(int position) { return titles[position]; } @Override public Fragment getItem(int position) { return fragments.get(position); } @Override public void destroyItem(ViewGroup container, int position, Object object) { // 覆写destroyItem并且空实现,这样每个Fragment中的视图就不会被销毁 // super.destroyItem(container, position, object); } @Override public int getItemPosition(Object object) { return PagerAdapter.POSITION_NONE; }} 方法 | 描述 ---------------------------------------------------------------------------- | ---------------------------------------------------------------------------------------- onPageScrolled(int position, float positionOffset, int positionOffsetPixels) | 页面滚动，position为当前位置，positionOffset范围[0,1),从当前到下一页，positionOffsetPixels从当前位置滚动的offset,单位px onPageSelected(int position) | 选中位置 onPageScrollStateChanged(int state) | 滚动状态改变 SCROLL_STATE_IDLE(pager处于空闲状态) SCROLL_STATE_DRAGGING( pager处于正在拖拽中) SCROLL_STATE_SETTLING(pager正在自动沉降，相当于松手后，pager恢复到一个完整pager的过程) 1234567891011121314151617181920212223@Overridepublic void onPageScrolled(int position, float positionOffset, int positionOffsetPixels) { /** * position:当前View的位置 * mCurrentPositionOffset:当前View的偏移量比例.[0,1) */ this.mCurrentTab = position; this.mCurrentPositionOffset = positionOffset; /*标签栏根据ViewPager的滚动状态联动，滚动到对应位置*/ scrollToCurrentTab(); /*触发重绘*/ invalidate();}@Overridepublic void onPageSelected(int position) { /*根据ViewPager选中状态调整标签页的选中状态*/ updateTabSelection(position);}@Overridepublic void onPageScrollStateChanged(int state) {} 1234567891011121314151617181920212223242526/** HorizontalScrollView滚到当前tab,并且居中显示 */ private void scrollToCurrentTab() { if (mTabCount &lt;= 0) { return; } int offset = (int) (mCurrentPositionOffset * mTabsContainer.getChildAt(mCurrentTab).getWidth()); /**当前Tab的left+当前Tab的Width乘以positionOffset*/ int newScrollX = mTabsContainer.getChildAt(mCurrentTab).getLeft() + offset; if (mCurrentTab &gt; 0 || offset &gt; 0) { /**HorizontalScrollView移动到当前tab,并居中*/ newScrollX -= getWidth() / 2 - getPaddingLeft(); calcIndicatorRect(); newScrollX += ((mTabRect.right - mTabRect.left) / 2); } if (newScrollX != mLastScrollX) { mLastScrollX = newScrollX; /** scrollTo（int x,int y）:x,y代表的不是坐标点,而是偏移量 * x:表示离起始位置的x水平方向的偏移量 * y:表示离起始位置的y垂直方向的偏移量 */ scrollTo(newScrollX, 0); } } 123456789101112131415/*根据是否选中设置字体颜色和粗体*/private void updateTabSelection(int position) { for (int i = 0; i &lt; mTabCount; ++i) { View tabView = mTabsContainer.getChildAt(i); final boolean isSelect = i == position; TextView tab_title = (TextView) tabView.findViewById(R.id.tv_tab_title); if (tab_title != null) { tab_title.setTextColor(isSelect ? mTextSelectColor : mTextUnselectColor); if (mTextBold == TEXT_BOLD_WHEN_SELECT) { tab_title.getPaint().setFakeBoldText(isSelect); } } }} 1.2.3 Tab相关 方法 | 描述 ----------------------- | ---------------- addNewTab(String title) | 提供给外部使用的新增tab的方法123456789101112public void addNewTab(String title) { View tabView = View.inflate(mContext, R.layout.layout_tab, null); if (mTitles != null) { mTitles.add(title); } CharSequence pageTitle = mTitles == null ? mViewPager.getAdapter().getPageTitle(mTabCount) : mTitles.get(mTabCount); addTab(mTabCount, pageTitle.toString(), tabView); this.mTabCount = mTitles == null ? mViewPager.getAdapter().getCount() : mTitles.size(); updateTabStyles();} 方法 | 描述 --------------------------------------------------- | ---------------------------------- setCurrentTab(int currentTab) | 跳转到指定tab,是否平滑的滚动过去由系统控制 setCurrentTab(int currentTab, boolean smoothScroll) | 跳转到制指定tab, smoothScroll控制是否平滑的滚动过去12345678910public void setCurrentTab(int currentTab) { this.mCurrentTab = currentTab; mViewPager.setCurrentItem(currentTab);}public void setCurrentTab(int currentTab, boolean smoothScroll) { this.mCurrentTab = currentTab; mViewPager.setCurrentItem(currentTab, smoothScroll);} 1.2.4 Getter和Setter 不做赘述 1.2.5 MsgView相关（未读信息） 方法 | 描述 ------------------------------------------------------------------ | --------------------------------------------- showMsg(int position, int num) | 显示未读消息，position为tab位置，num小于等于0显示红点,num大于0显示数字 showDot(int position) | 显示未读红点， position为tab位置 hideMsg(int position) | 隐藏未读消息， position为tab位置 setMsgMargin(int position, float leftPadding, float bottomPadding) | 设置未读消息偏移,原点为文字的右上角.当控件高度固定,消息提示位置易控制,显示效果佳 getMsgView(int position) | 当前类只提供了少许设置未读消息属性的方法,可以通过该方法获取MsgView对象从而各种设置2. CommonTabLayout2.1 特有属性特有属性 | 格式 | 描述 -------------------------- | --------- | ----------------------------------------------------------------------- tl_indicator_width | dimension | 设置显示器固定宽度 tl_indicator_gravity | enum | 设置显示器上方(TOP)还是下方(BOTTOM),只对常规显示器有用 tl_indicator_style | enum | 设置显示器为常规(NORMAL)或三角形(TRIANGLE)或背景色块(BLOCK) tl_indicator_anim_enable | boolean | 设置显示器支持动画(only for CommonTabLayout) tl_indicator_anim_duration | integer | 设置显示器动画时间(only for CommonTabLayout) tl_indicator_bounce_enable | boolean | 设置显示器支持动画回弹效果(only for CommonTabLayout) tl_underline_color | color | 设置下划线颜色 tl_underline_height | dimension | 设置下划线高度 tl_underline_gravity | enum | 设置下划线上方(TOP)还是下方(BOTTOM) tl_iconWidth | dimension | 设置icon宽度(仅支持CommonTabLayout) tl_iconHeight | dimension | 设置icon高度(仅支持CommonTabLayout) tl_iconVisible | boolean | 设置icon是否可见(仅支持CommonTabLayout) tl_iconGravity | enum | 设置icon显示位置,对应Gravity中常量值,左上右下(仅支持CommonTabLayout)，LEFT，RIGHT，TOP，BOTTOM tl_iconMargin | dimension | 设置icon与文字间距(仅支持CommonTabLayout) 2.2 区别于SlidingTabLayout 不依赖于ViewPager，可以与其他组件搭配 支持自定义Tab样式，主要体现在常用的图标+文字的形式。 SlidingTabLayout继承HorizontalScrollView而CommonTabLayout继承FrameLayout 2.3 类结构 2.3.1 构造方法 与SlidingTabLayout实现类似，获取的属性值不太一样而已。多出一个动画的内容，点击某一个Tab后，indicator的移动动画效果 12mValueAnimator = ValueAnimator.ofObject(new PointEvaluator(), mLastP, mCurrentP);mValueAnimator.addUpdateListener(this); 2.3.2 动画相关12345678910111213141516171819class IndicatorPoint { public float left; public float right;}private IndicatorPoint mCurrentP = new IndicatorPoint();private IndicatorPoint mLastP = new IndicatorPoint();class PointEvaluator implements TypeEvaluator&lt;IndicatorPoint&gt; { @Override public IndicatorPoint evaluate(float fraction, IndicatorPoint startValue, IndicatorPoint endValue) { float left = startValue.left + fraction * (endValue.left - startValue.left); float right = startValue.right + fraction * (endValue.right - startValue.right); IndicatorPoint point = new IndicatorPoint(); point.left = left; point.right = right; return point; }} 1234567891011121314151617@Overridepublic void onAnimationUpdate(ValueAnimator animation) { View currentTabView = mTabsContainer.getChildAt(this.mCurrentTab); IndicatorPoint p = (IndicatorPoint) animation.getAnimatedValue(); mIndicatorRect.left = (int) p.left; mIndicatorRect.right = (int) p.right; if (mIndicatorWidth &lt; 0) { //indicatorWidth小于0时,原jpardogo&apos;s PagerSlidingTabStrip } else {//indicatorWidth大于0时,圆角矩形以及三角形 float indicatorLeft = p.left + (currentTabView.getWidth() - mIndicatorWidth) / 2; mIndicatorRect.left = (int) indicatorLeft; mIndicatorRect.right = (int) (mIndicatorRect.left + mIndicatorWidth); } invalidate();} 2.3.3 Tab相关 方法 | 描述 ---------------------------------------------------------------------------------------------------------------------------------------- | ------------------- setTabData(ArrayList&amp;lt; CustomTabEntity&amp;gt; tabEntitys) | 设置tab entity setTabData(ArrayList&amp;lt; CustomTabEntity&amp;gt; tabEntitys, FragmentActivity fa, int containerViewId, ArrayList&amp;lt; Fragment&amp;gt; fragments) | 关联数据支持同时切换fragments notifyDataSetChanged() | 更新数据 setCurrentTab(int currentTab) | 设置当前tab 1234567891011public void setTabData(ArrayList&lt;CustomTabEntity&gt; tabEntitys) { if (tabEntitys == null || tabEntitys.size() == 0) { throw new IllegalStateException(&quot;TabEntitys can not be NULL or EMPTY !&quot;); } this.mTabEntitys.clear(); /*设置tab标签*/ this.mTabEntitys.addAll(tabEntitys); /*更新数据*/ notifyDataSetChanged();} 12345678910111213141516171819202122232425/** 更新数据 */public void notifyDataSetChanged() { /*清空容器中的tab*/ mTabsContainer.removeAllViews(); this.mTabCount = mTabEntitys.size(); View tabView; /*根据图标的gravity构建不同的tab样式，图标支持上下左右*/ for (int i = 0; i &lt; mTabCount; i++) { if (mIconGravity == Gravity.LEFT) { tabView = View.inflate(mContext, R.layout.layout_tab_left, null); } else if (mIconGravity == Gravity.RIGHT) { tabView = View.inflate(mContext, R.layout.layout_tab_right, null); } else if (mIconGravity == Gravity.BOTTOM) { tabView = View.inflate(mContext, R.layout.layout_tab_bottom, null); } else { tabView = View.inflate(mContext, R.layout.layout_tab_top, null); } /*i添加到tag,但从这个类的方法上看，这一步没有什么必要，因为addTab会传入i,addTab中直接使用i就好，但是如果我们在外部拿到tabView,就可以直接指导它的position,不用循环遍历，还是挺方便的*/ tabView.setTag(i); /*添加tab*/ addTab(i, tabView); } /*根据选中未选中状态更新tab显示效果*/ updateTabStyles();} 123456789101112131415161718192021222324252627282930313233343536373839/** 创建并添加tab */private void addTab(final int position, View tabView) { /*设置文本内容，title*/ TextView tv_tab_title = (TextView) tabView.findViewById(R.id.tv_tab_title); tv_tab_title.setText(mTabEntitys.get(position).getTabTitle()); /*设置图标内容，添加未选中内容，后面根据选中未选中重新刷一次图片*/ ImageView iv_tab_icon = (ImageView) tabView.findViewById(R.id.iv_tab_icon); iv_tab_icon.setImageResource(mTabEntitys.get(position).getTabUnselectedIcon()); /*设置tabView的点击事件*/ tabView.setOnClickListener(new OnClickListener() { @Override public void onClick(View v) { /*前面设置的tab,也就是position*/ int position = (Integer) v.getTag(); if (mCurrentTab != position) { /*设置当前tab*/ setCurrentTab(position); //有OnTabSelectListener则执行对应的处理 if (mListener != null) { mListener.onTabSelect(position); } } else { if (mListener != null) { mListener.onTabReselect(position); } } } }); /** 每一个Tab的布局参数 ，根据是否均分设置不同的布局，若宽度不为0，则设置宽度*/ LinearLayout.LayoutParams lp_tab = mTabSpaceEqual ? new LinearLayout.LayoutParams(0, LayoutParams.MATCH_PARENT, 1.0f) : new LinearLayout.LayoutParams(LayoutParams.WRAP_CONTENT, LayoutParams.MATCH_PARENT); if (mTabWidth &gt; 0) { lp_tab = new LinearLayout.LayoutParams((int) mTabWidth, LayoutParams.MATCH_PARENT); } mTabsContainer.addView(tabView, position, lp_tab);} 12345678910111213141516171819202122232425262728293031323334353637383940414243/*和SlidingTabLayout相似，多了一个图标的处理*/private void updateTabStyles() { for (int i = 0; i &lt; mTabCount; i++) { View tabView = mTabsContainer.getChildAt(i); tabView.setPadding((int) mTabPadding, 0, (int) mTabPadding, 0); TextView tv_tab_title = (TextView) tabView.findViewById(R.id.tv_tab_title); tv_tab_title.setTextColor(i == mCurrentTab ? mTextSelectColor : mTextUnselectColor); tv_tab_title.setTextSize(TypedValue.COMPLEX_UNIT_PX, mTextsize);// tv_tab_title.setPadding((int) mTabPadding, 0, (int) mTabPadding, 0); if (mTextAllCaps) { tv_tab_title.setText(tv_tab_title.getText().toString().toUpperCase()); } if (mTextBold == TEXT_BOLD_BOTH) { tv_tab_title.getPaint().setFakeBoldText(true); } else if (mTextBold == TEXT_BOLD_NONE) { tv_tab_title.getPaint().setFakeBoldText(false); } ImageView iv_tab_icon = (ImageView) tabView.findViewById(R.id.iv_tab_icon); if (mIconVisible) { iv_tab_icon.setVisibility(View.VISIBLE); CustomTabEntity tabEntity = mTabEntitys.get(i); iv_tab_icon.setImageResource(i == mCurrentTab ? tabEntity.getTabSelectedIcon() : tabEntity.getTabUnselectedIcon()); LinearLayout.LayoutParams lp = new LinearLayout.LayoutParams( mIconWidth &lt;= 0 ? LinearLayout.LayoutParams.WRAP_CONTENT : (int) mIconWidth, mIconHeight &lt;= 0 ? LinearLayout.LayoutParams.WRAP_CONTENT : (int) mIconHeight); if (mIconGravity == Gravity.LEFT) { lp.rightMargin = (int) mIconMargin; } else if (mIconGravity == Gravity.RIGHT) { lp.leftMargin = (int) mIconMargin; } else if (mIconGravity == Gravity.BOTTOM) { lp.topMargin = (int) mIconMargin; } else { lp.bottomMargin = (int) mIconMargin; } iv_tab_icon.setLayoutParams(lp); } else { iv_tab_icon.setVisibility(View.GONE); } }} 另外一个setTabData 123456/** 关联数据支持同时切换fragments */public void setTabData(ArrayList&lt;CustomTabEntity&gt; tabEntitys, FragmentActivity fa, int containerViewId, ArrayList&lt;Fragment&gt; fragments) { /*拿到一个mFragmentChangeManager ，后面setCurrentTab的时候 ，如果这个值不为空，根据这个来切换fragment,实现一种类似FragmentPagerAdapter的效果*/ mFragmentChangeManager = new FragmentChangeManager(fa.getSupportFragmentManager(), containerViewId, fragments); setTabData(tabEntitys);} 12345678910111213141516public void setCurrentTab(int currentTab) { mLastTab = this.mCurrentTab; this.mCurrentTab = currentTab; /*遍历更新tab选中未选中状态*/ updateTabSelection(currentTab); /*如果mFragmentChangeManager 不为空，就根据当前选中的tab显示对应的Fragment*/ if (mFragmentChangeManager != null) { mFragmentChangeManager.setFragments(currentTab); } /*indicator动画效果，计算后重绘*/ if (mIndicatorAnimEnable) { calcOffset(); } else { invalidate(); }} 2.3.4 FragmentChangeManager 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748public class FragmentChangeManager { private FragmentManager mFragmentManager; private int mContainerViewId; /** Fragment切换数组 */ private ArrayList&lt;Fragment&gt; mFragments; /** 当前选中的Tab */ private int mCurrentTab; /*构造方法，setTabData的时候看到过*/ public FragmentChangeManager(FragmentManager fm, int containerViewId, ArrayList&lt;Fragment&gt; fragments) { this.mFragmentManager = fm; this.mContainerViewId = containerViewId; this.mFragments = fragments; initFragments(); } /** 初始化fragments */ private void initFragments() { for (Fragment fragment : mFragments) { mFragmentManager.beginTransaction().add(mContainerViewId, fragment).hide(fragment).commit(); } setFragments(0); } /** 界面切换控制,CommonTabLayout中的setCurrentTab方法可以控制*/ public void setFragments(int index) { for (int i = 0; i &lt; mFragments.size(); i++) { FragmentTransaction ft = mFragmentManager.beginTransaction(); Fragment fragment = mFragments.get(i); if (i == index) { ft.show(fragment); } else { ft.hide(fragment); } ft.commit(); } mCurrentTab = index; } public int getCurrentTab() { return mCurrentTab; } public Fragment getCurrentFragment() { return mFragments.get(mCurrentTab); }} 2.3.5 Getter,Setter以及MsgView先关 Getter和Setter方法是属性值的获取和设置，MsgView相关方法和SlidingTabLayout比较相似。 3. SegmentTabLayout3.1 特有属性特有属性 | 格式 | 描述 -------------------------- | --------- | ------------- tl_indicator_anim_enable | boolean | 设置显示器支持动画 tl_indicator_anim_duration | integer | 设置显示器动画时间 tl_indicator_bounce_enable | boolean | 设置显示器支持动画回弹效果 tl_bar_color | color | 设置整体颜色 tl_bar_stroke_color | color | 设置边框颜色 tl_bar_stroke_width | dimension | 设置边框粗细 3.2 区别于CommonTabLayout 不支持图标，但是可以看做是一个特殊的CommonTabLayout. 3.3 类结构整体来说，内容基本上和CommonTabLayout，只是少了Icon的对应处理，多出的是Segment样式的处理。 4. MsgView4.1 自定义属性属性值 | 格式 | 描述 --------------------- | --------- | ---------------- mv_backgroundColor | color | 圆角矩形背景色 mv_cornerRadius | dimension | 圆角弧度,单位dp mv_strokeWidth | dimension | 边框粗细，单位dp mv_strokeColor | color | 圆角边框颜色 mv_isRadiusHalfHeight | boolean | 圆角弧度是高度一半 mv_isWidthHeightEqual | boolean | 圆角矩形宽高相等,取较宽高中大值4.2 类结构 项目使用 个人项目Gank.io Android 客户端中使用效果,底部使用的CommonTabLayout，顶部使用的是SlidingTabLayout。整体而言，日常开发过程中，FlycoTabLayout还是很实用的。","link":"/2017/04/19/《Android 开源库》 FlycoTabLayout 从头到脚/"},{"title":"《Android 开源库》 GreenDAO 用法详解（译文）","text":"简介 greenDAO是一个开源的Android ORM，使SQLite数据库的开发再次变得有趣。 它减轻了开发人员处理底层的数据库需求，同时节省开发时间。 SQLite是一个很不错的关系型数据库。 尽管如此，编写SQL和解析查询结果仍然是相当乏味和耗时的任务。 greenDAO通过将Java对象映射到数据库表（称为ORM，“对象/关系映射”）来解决这些问题。 这样，您可以使用简单的面向对象的API来存储，更新，删除和查询Java对象。 特性 最高性能（可能是Android中最快的ORM）; 我们的benchmarks 也是开源的 涵盖关系和连接且易用的强大API 最小的内存开销 迷你开源库（&lt;100KB），降低工程构建时间同时避免65k方法限制 数据库加密：greenDAO支持SQLCipher以保证用户的数据安全 强大的社区：超过5000 GitHub星星表明我们拥有一个强大而活跃的社区 开始使用入门 本教程将引导你完成一个简单的greenDAO示例项目DaoExample。 克隆代码并运行它，或者直接在GitHub上查看文件。 DaoExample是一个简单地用来记笔记的Android应用程序。 你可以通过键入一些文本来添加新笔记，并通过点击现有笔记删除笔记。 #####1. Note实体和DAO类 一起看下代码：在src文件夹中，你会发现一个实体类Note.java。 它被持久化到数据库并包含Note的所有数据，如id，注释文本和创建日期。 123456789101112@Entity(indexes = { @Index(value = &quot;text, date DESC&quot;, unique = true)})public class Note { @Id private Long id; @NotNull private String text; private Date date; ... 通常，实体是在数据库中持久化的类（例如，一个对象的一行）。 实体包含映射到数据库列的属性。 现在开始编译工程，例如在Android Studio中使用“Build&gt; Make project”。 这将触发greenDAO来生成DAO类，例如NoteDao.java，这将帮助我们向数据库添加笔记。 #####2. 插入和删除笔记 要学习如何添加一些笔记，请看一下NoteActivity类。 首先，我们必须为我们的Note类准备一个DAO对象，我们在onCreate（）中做： 123// get the note DAODaoSession daoSession = ((App) getApplication()).getDaoSession();noteDao = daoSession.getNoteDao(); 当用户单击添加按钮时，将调用addNote()方法。 在这里，我们创建一个新的Note对象，并将其传递给DAO insert()方法，以将其插入到数据库中： 123Note note = new Note(null, noteText, comment, new Date());noteDao.insert(note);Log.d(&quot;DaoExample&quot;, &quot;Inserted new note, ID: &quot; + note.getId()); 注意，我们在创建笔记的时候没有传递id。 在这种情况下，数据库决定note id。 DAO负责在从插入操作返回之前自动设置新的ID（请参阅日志语句）。 删除笔记也很简单，参见NoteClickListener： 1noteDao.deleteByKey(id); 你可以探索NoteDao的其他方法，比如loadAll（）和update（）。 #####3. 设置数据库 你已经看到了DAO，但是如何初始化greenDAO和底层数据库呢？ 通常你需要init一个DaoSession，它通常在整个应用程序中的Application类中执行一次： 123DevOpenHelper helper = new DevOpenHelper(this, &quot;notes-db&quot;);Database db = helper.getWritableDb();daoSession = new DaoMaster(db).newSession(); 使用生成的DaoMaster类提供的帮助器类DevOpenHelper创建数据库。 它是DaoMaster中的OpenHelper类的一个实现，它为你创建所有数据库。 再也不需要编写“CREATE TABLE”语句。 然后Activity和Fragment可以调用getDaoSession()来访问所有实体DAO，和我们之前在插入和删除的时候一样。 #####4. 扩展和添加实体 为了扩展我们的笔记或创建新实体，你只需修改或创建Java类，并以相同的方式注解它们。 然后重新编译项目。 有关详细信息，请参阅建模实体。(这个下面已经翻译出来) 介绍 greenDAO是Android的对象/关系映射（ORM）工具。 它为关系数据库SQLite提供了一个面向对象的接口。像greenDAO一类的ORM工具为你做很多重复性的任务，提供简单的数据接口。 1. Gradle插件和DAO代码生成 为了在你的Android项目中使用greenDAO，你需要添加greenDAO Gradle插件并添加greenDAO库： 123456789101112131415buildscript { repositories { mavenCentral() } dependencies { classpath &apos;org.greenrobot:greendao-gradle-plugin:3.2.1&apos; }} apply plugin: &apos;com.android.application&apos;apply plugin: &apos;org.greenrobot.greendao&apos; dependencies { compile &apos;org.greenrobot:greendao:3.2.0&apos;} 然后进行实体建模也就是创建实体，并编译项目，例如在Android Studio中使用“Build&gt; Make Project”。 2. 核心类 一旦项目构建完毕，你就可以在Android项目中开始使用greenDAO了。 以下核心类是greenDAO的基本接口： DaoMaster：使用greenDAO的切入点。 DaoMaster保存数据库对象（SQLiteDatabase）并管理特定模式的DAO类（而不是对象）。 它有静态方法来创建表或删除它们。 它的内部类OpenHelper和DevOpenHelper都是SQLiteOpenHelper的实现，用来在SQLite数据库中创建模式。 DaoSession：管理特定模式的所有可用DAO对象，你可以使用其中一个的getter方法获取DAO对象。 DaoSession还为实体提供了一些通用的持久性方法，如插入，加载，更新，刷新和删除。 最后，DaoSession对象也跟踪identity scope。 有关更多详细信息，请查看会话文档 DAO：数据访问对象（DAO），用于实体的持久化和查询。 对于每个实体，greenDAO会生成一个DAO。 它比DaoSession拥有更多的持久化方法，例如：count，loadAll和insertInTx。 实体：可持久化对象。 通常，实体是使用标准Java属性（如POJO或JavaBean）表示数据库行的对象。 3. 核心初始化 最后，以下代码示例说明了初始化数据库和核心greenDAO类的第一步 1234567//做一次，例如在你的Application类中helper = new DaoMaster.DevOpenHelper（this，“notes-db”，null）;db = helper.getWritableDatabase（）;daoMaster = new DaoMaster（db）;daoSession = daoMaster.newSession（）;//在您的活动/片段中执行此操作以获取DAOnoteDao = daoSession.getNoteDao（）; 该示例假设存在一个Note实体。 有了它的DAO（noteDao对象），我们可以调用这个特定实体的持久化操作。 实体建模 要在项目中使用greenDAO，您需要创建一个表示应用程序中持久数据的实体模型。 然后，基于此模型，greenDAO为DAO类生成Java代码。 模型本身是使用带有注解的Java类定义的。 要使用旧式生成器创建模式，请参阅生成器。 下侧的图示描述了greenDAO所基于的元模型。 #####1. 模式 无需任何其他配置就可以开始使用greenDAO Gradle插件。但是，至少应该像下面这样设置下模式版本： 12345678// In the build.gradle file of your app project:android {...} greendao { schemaVersion 2} 此外，greendao配置元素支持一系列配置选项： schemaVersion：数据库模式的当前版本。 这由* OpenHelpers类用于在模式版本之间迁移。 如果更改实体/数据库模式，则必须增加此值。 默认值为1。 daoPackage：生成的DAO，DaoMaster和DaoSession的包名称。 默认为源实体的包名称。 targetGenDir：生成的源码应存储在的位置。 默认为生成目录（build / generated / source / greendao）中生成的源文件夹。 generateTests：设置为true以自动生成单元测试。 targetGenDirTests：生成的单元测试应存储在的基本目录。 默认为src / androidTest / java。 #####2. 实体和注解greenDAO 3使用注解来定义模式和实体。 这里有一个简单的例子： 123456789101112@Entitypublic class User { @Id private Long id; private String name; @Transient private int tempUsageCount; // not persisted // getters and setters for id and user ...} @Entity注解将Java类User转换为数据库支持的实体。 这也将指示greenDAO生成必要的代码（例如DAO）。 注意：仅支持Java类。 如果你喜欢另一种语言，如Kotlin，你的实体类仍然必须是Java。 #####5. @Entity 注解 正如在上面的示例中看到的，@Entity注解将Java类标记为greenDAO的持久化的实体。 虽然通常没有任何额外的参数，在使用@Entity的时候你仍然可以配置一些细节： 123456789101112131415161718192021222324252627282930313233@Entity( // If you have more than one schema, you can tell greenDAO // to which schema an entity belongs (pick any string as a name). schema = &quot;myschema&quot;, // Flag to make an entity &quot;active&quot;: Active entities have update, // delete, and refresh methods. active = true, // Specifies the name of the table in the database. // By default, the name is based on the entities class name. nameInDb = &quot;AWESOME_USERS&quot;, // Define indexes spanning multiple columns here. indexes = { @Index(value = &quot;name DESC&quot;, unique = true) }, // Flag if the DAO should create the database table (default is true). // Set this to false, if you have multiple entities mapping to one table, // or the table creation is done outside of greenDAO. createInDb = false, // Whether an all properties constructor should be generated. // A no-args constructor is always required. generateConstructors = true, // Whether getters and setters for properties should be generated if missing. generateGettersSetters = true)public class User { ...} 注意，当使用Gradle插件时，目前不支持多个模式。 暂时，继续使用你的生成器项目。 #####5. 基本属性 12345678910111213141516@Entitypublic class User { @Id(autoincrement = true) private Long id; @Property(nameInDb = &quot;USERNAME&quot;) private String name; @NotNull private int repos; @Transient private int tempUsageCount; ...} @Id注解选择long / Long属性作为实体ID。 在数据库术语中，它是主键。 参数autoincrement是一个标志，使ID值不断增加（不重用旧值）。 @Property允许你定义一个当前属性映射到的数据库列的非默认名称。 如果为空，greenDAO将以SQL-ish方式使用字段名（大写字母，下划线代替驼峰，例如customName将成为CUSTOM_NAME）。 注意：当前只能使用内联常量来指定列名称。 @NotNull使属性在数据库端为“NOT NULL”列。 通常，使用@NotNull标记原始类型（long，int，short，byte），同时使用封装类（Long，Integer，Short，Byte）可以使用空值。 @Transient标记要从持久性中排除的属性。 将它们用于临时状态等。或者，也可以使用Java中的transient关键字。 6. 主键限制 目前，实体必须具有long或Long属性作为其主键。 这是Android和SQLite的推荐做法。 要解决此问题，请将你的键属性定义为其他属性，但为其创建唯一索引： 12345@Idprivate Long id; @Index(unique = true)private String key; #####7. 属性索引 在属性中使用@Index可为相应的数据库列创建数据库索引。 使用以下参数自定义： name：如果你不喜欢greenDAO为索引生成的默认名称，你可以在这里指定你的名字。 unique：向索引添加UNIQUE约束，强制所有值是唯一的。 123456@Entitypublic class User { @Id private Long id; @Index(unique = true) private String name;} @Unique向数据库列添加UNIQUE约束。 注意，SQLite也隐式地为它创建一个索引。 12345@Entitypublic class User { @Id private Long id; @Unique private String name;} 8. 默认值 greenDAO尝试使用合理的默认值，以便开发人员每个都一一配置。 例如，数据库侧的表和列名称派生自实体和属性名称。 而不是在Java中使用的骆驼案例样式，默认数据库名称使用大写，使用下划线分隔单词。 例如，名为creationDate的属性将成为数据库列CREATION_DATE 9. 关系 要了解如何添加一对一和多对多关系，请参阅关系(下面已经翻译) 10. 触发生成 一旦实体模式就位，你就可以通过在IDE中使用“Make project”来触发代码生成过程。 或者直接执行greendao Gradle任务。 如果在更改实体类之后遇到错误，请尝试重新生成项目，以确保清除旧生成的类。 11. 修改生成的代码 greenDAO 3中的实体类由开发人员创建和编辑。 然而，在代码生成过程中，greenDAO可能会增加实体的源代码。 greenDAO将为它创建的方法和字段添加一个@Generated注解，以通知开发人员并防止任何代码丢失。 在大多数情况下，你不必关心使用@Generated注解的代码。 作为预防措施，greenDAO不会覆盖现有代码，并且如果手动更改生成的代码会引发错误： 1234Error:Execution failed for task &apos;:app:greendao&apos;.&gt; Constructor (see ExampleEntity:21) has been changed after generation.Please either mark it with @Keep annotation instead of @Generated to keep it untouched,or use @Generated (without hash) to allow to replace it. 正如错误消息所暗示的，通常有两种方法来解决此问题： 将更改还原为使用@Generated注解的代码。 或者，你也可以完全删除更改的构造函数或方法。 它们将与下一个版本重新生成。 使用@Keep注解替换@Generated注解。 这将告诉greenDAO永远不要触摸带注解的代码。 请记住，你的更改可能会中断实体和其他greenDAO之间的约定。 此外，未来的greenDAO版本可能期望生成的方法中有不同的代码。 所以，要谨慎！。同时采用单元测试的方法来避免麻烦是个不错的选择。 12. 保留部分不再支持旧版本的greenDAO中使用的KEEP。 但是，如果Gradle插件检测到KEEP FIELDS部分，它将自动使用@Transient注释字段。 之后，可能会删除周围的KEEP FIELDS注释。 会话和会话的identity scope （生成的）DaoSession类是greenDAO的中心接口之一。 DaoSession提供开发人员访问基本实体操作和相较于DAO的更完整的操作集合。 此外，会话还管理实体的identity scope。 1. DaoMaster and DaoSession 如“入门”部分所述，你需要创建一个DaoMaster以获取DaoSession： 12daoMaster = new DaoMaster(db);daoSession = daoMaster.newSession(); 请注意，数据库连接属于DaoMaster部分，因此多个会话指的是同一个数据库连接。 因此，我们可以相当快地创建新会话。 但是，每个会话得分配存储空间，特别是实体的会话“缓存”。 2. Identity scope 和会话缓存 如果有两个查询返回相同的数据库对象，则使用多少个Java对象：一个或两个？ 它完全取决于Identity scope。 greenDAO中的默认值（行为是可配置的）是多个查询返回对同一Java对象的引用。 例如，从ID为42的USER表中加载User对象会为这两个查询返回相同的Java对象。 这种方式的副作用是某种实体“缓存”。 如果实体对象在内存中仍然存在（greenDAO在这里使用弱引用），则不会再次构造该实体。 此外，greenDAO不执行数据库查询以更新实体值。 相反，对象从会话高速缓存“立即”返回，这个速度是相当快的。 3. 清除identity scope 要清除整个会话的identity scope，以便不返回“缓存”对象： 1daoSession.clear(); 清除单个DAO的identity scope： 12noteDao = daoSession.getNoteDao();noteDao.detachAll(); 4. 概念 本文档页面当前信息有限。 请参考Hibernate会话以掌握会话和identiry scope的完整概念。 查询和查询构建器 查询返回符合特定条件的实体。 在greenDAO中，你可以使用原始SQL来制定查询，或者使用QueryBuilder API，相对而言后者会更容易。 此外，查询支持懒加载结果，当在大结果集上操作时，可以节省内存和性能。 1. 查询构建器 编写SQL可能很困难，并且容易出现错误，这些错误仅在运行时被察觉。 QueryBuilder类允许你为没有SQL的实体构建自定义查询，并帮助在编译时检测错误。 简单条件示例：查询所有名为“Joe”的用户，按姓氏排序： 1234List&lt;User&gt; joes = userDao.queryBuilder() .where(Properties.FirstName.eq(&quot;Joe&quot;)) .orderAsc(Properties.LastName) .list(); 嵌套条件示例：获取1970年10月或之后出生的名为“Joe”的用户。 假设我们有一个用户的生日作为年，月和日的单独属性。 然后，我们可以用更正式的方式表示条件：名字是“Joe”AND（出生年份大于1970年或（出生年份是1970年，出生年份等于或大于10））（ 10月，10月）。 12345QueryBuilder&lt;User&gt; qb = userDao.queryBuilder();qb.where(Properties.FirstName.eq(&quot;Joe&quot;),qb.or(Properties.YearOfBirth.gt(1970),qb.and(Properties.YearOfBirth.eq(1970), Properties.MonthOfBirth.ge(10))));List&lt;User&gt; youngJoes = qb.list(); 2. 限制，偏移和分页 有时候，你只需要一个查询结果的子集，例如在用户界面中显示的前10个元素。 当拥有大量实体时，这是非常有用的（节省资源的），并且你也不能使用“where”语句来限制结果。 QueryBuilder 有定义限制和偏移的方法： limit（int）：限制查询返回的结果数。 offset（int）：结合limit（int）设置查询结果的偏移量。 将跳过第一个偏移结果，并且结果的总数将受limit（int）限制。 你不能使用offset无限制（int）。 3. 使用自定义类型作为参数 通常，greenDAO以透明方式映射查询中使用的类型。 例如，boolean被映射到INTEGER，具有0或1个值，并且Date被映射到（long）INTEGER值。 自定义类型是一个例外：在构建查询时，总是必须使用数据库值类型。 例如，如果使用转换器将枚举类型映射到int值，则应在查询中使用int值。 4. 查询和LazyList Query类表示可以多次执行的查询。当你使用QueryBuilder中的一个方法来获取结果（如list()）时，执行过程中QueryBuilder 内部会使用Query 类。如果要多次运行同一个查询，应该在QueryBuilder 上调用build()来创建查询而并非执行它。 greenDAO支持唯一结果（0或1个结果）和结果列表。如果你想在Query （或QueryBuilder ）上有唯一的结果调用unique()，这将为你提供单个结果或者在没有找到匹配的实体时返回null。如果你的用例禁止null作为结果，调用uniqueOrThrow()将保证返回一个非空的实体（否则会抛出一个DaoException）。 如果希望多个实体作为查询结果，请使用以下方法之一： list()所有实体都加载到内存中。结果通常是一个简单的ArrayList。最方便使用。 listLazy()实体按需加载到内存中。一旦列表中的元素第一次被访问，它将被加载并缓存以备将来使用。使用完后必须关闭。 listLazyUncached()一个“虚拟”实体列表：对列表元素的任何访问都导致从数据库加载其数据。使用完后必须关闭。 listIterator()让我们通过按需加载数据（lazily）来遍历结果。数据未缓存。使用完后必须关闭。 方法listLazy()，listLazyUncached()和listIterator()使用greenDAO的LazyList类。要按需加载数据，它保存对数据库游标的引用。这就是为什么你必须确保关闭惰性列表和迭代器（通常在try / finally块）。 来自listLazy()的缓存延迟列表和listIterator()中的惰性迭代器在访问或遍历所有元素后自动关闭游标。如果列表处理过早停止,开发者需要自己调用close()进行处理 5. 多次执行查询 使用QueryBuilder构建查询后，这个Query对象是可以被重复使用的。 这比总是创建新的Query对象更高效。 如果查询参数不更改，你可以继续调用列表/唯一结果等方法进行查询操作。 但是，参数是可以被更改的：通过调用setParameter方法来更改参数。 当前，通过基于零的参数索引来寻址各个参数。 索引基于我们传入到QueryBuilder的顺序。 例如： 1234567891011// fetch users with Joe as a first name born in 1970Query&lt;User&gt; query = userDao.queryBuilder().where( Properties.FirstName.eq(&quot;Joe&quot;), Properties.YearOfBirth.eq(1970)).build();List&lt;User&gt; joesOf1970 = query.list(); // using the same Query object, we can change the parameters// to search for Marias born in 1977 later:query.setParameter(0, &quot;Maria&quot;);query.setParameter(1, 1977);List&lt;User&gt; mariasOf1977 = query.list(); 6. 在多线程中执行查询 如果在多个线程中使用查询，则必须调用forCurrentThread（）获取当前线程的Query实例。 Query实例绑定到构建查询的那个线程。 你可以安全地设置Query对象的参数，不涉及到其他线程。 如果一个线程尝试修改查询参数或执行已经绑定到另一个线程的查询绑，系统将抛出异常。 用这种方式，你就不再需要synchronized语句了。 实际上，你应该避免锁定，因为如果并发事务使用相同的Query对象，这可能导致死锁。 每次调用forCurrentThread()时，查询参数将会被设置成使用构建器构建查询时的参数。 7. 原始查询 如果QueryBuilder不能满足你的需求，有两种方法来执行原始SQL并返回实体对象。 第一种，首选的方法是使用QueryBuilder和WhereCondition.StringCondition。 这样，你可以将任何SQL片段作为WHERE子句传递给查询构建器。 以下代码是一个理论示例，说明如何运行子选择（使用连接将是更好的解决方案）： 1234Query&lt;User&gt; query = userDao.queryBuilder().where( new StringCondition(&quot;_ID IN &quot; + &quot;(SELECT USER_ID FROM USER_MESSAGE WHERE READ_FLAG = 0)&quot;)).build(); 第二种方法不使用QueryBuilder， 而是使用queryRaw或queryRawCreate方法。 它们允许您传递一个原始SQL字符串，它附加在SELECT和实体列之后。 这样，你可以有任何WHERE和ORDER BY子句来选择实体。 可以使用别名T来引用实体表。 以下示例显示如何创建一个查询，该查询使用连接检索名为“admin”的组的用户（同样，greenDAO本身支持连接，这只是为了演示）： 123Query&lt;User&gt; query = userDao.queryRawCreate( &quot;, GROUP G WHERE G.NAME=? AND T.GROUP_ID=G._ID&quot;, &quot;admin&quot;); 注意：可以使用生成的常量引用表和列名称。 这是建议避免打字错误，因为编译器将检查名称。 在实体的DAO中，你将发现TABLENAME包含数据库表的名称，以及一个内部类属性，其中包含所有属性的常量（字段columnName）。 8. 删除查询 批量删除不会删除单个实体，但是所有实体都符合一些条件。 要执行批量删除，请创建一个QueryBuilder，调用其buildDelete（）方法，并执行返回的DeleteQuery。 ***API的这一部分可以在将来改变，例如可以添加方便的方法。 请注意，批量删除目前不影响identity scope中的实体，例如，如果已删除的实体先前已缓存，并通过其ID（加载方法）进行访问，则可以“复活”。 请考虑立即清除身份范围，如果这可能会导致你的用例的问题。*** 9. 疑难解答查询 您的查询不返回预期结果？ 在QueryBuilder上启用SQL和参数记录有两个静态标志： 12QueryBuilder.LOG_SQL = true;QueryBuilder.LOG_VALUES = true; 当调用其中一个构建方法时，它们将记录生成的SQL命令和传递的值，并将它们与实际所需的值进行比较。 此外，它可能有助于将生成的SQL复制到一些SQLite数据库浏览器，并看看它如何执行。 查询构建器连接表1. 连接 非普通查询通常需要几个实体类型（表）的数据。 在SQL世界中，可以通过使用连接条件“连接”两个或多个表来实现。 让我们考虑一个实体User，它与Address实体具有一对多的关系。 然后，我们要查询居住在“Sesame Street”上的用户：我们必须使用用户ID与User实体加入Address实体，并在Address实体上定义WHERE条件： 1234QueryBuilder&lt;User&gt; queryBuilder = userDao.queryBuilder();queryBuilder.join(Address.class, AddressDao.Properties.userId) .where(AddressDao.Properties.Street.eq(&quot;Sesame Street&quot;));List&lt;User&gt; users = queryBuilder.list(); 连接需要目标实体类作为每个实体的参数和连接属性。 在示例中，只定义Address实体的join属性，因为默认使用主键属性。 换句话说，查询导致用户具有UserId等于User实体ID并且还具有特定街道的Address实体。 2. 查询构建器连接API 由于可以在使用主键属性时省略join属性，因此QueryBuilder中提供了三种重载的连接方法： 123456789101112131415161718192021/** * Expands the query to another entity type by using a JOIN. * The primary key property of the primary entity for * this QueryBuilder is used to match the given destinationProperty. */public &lt;J&gt; Join&lt;T, J&gt; join(Class&lt;J&gt; destinationEntityClass, Property destinationProperty) /** * Expands the query to another entity type by using a JOIN. * The given sourceProperty is used to match the primary * key property of the given destinationEntity. */public &lt;J&gt; Join&lt;T, J&gt; join(Property sourceProperty, Class&lt;J&gt; destinationEntityClass) /** * Expands the query to another entity type by using a JOIN. * The given sourceProperty is used to match the given * destinationProperty of the given destinationEntity. */public &lt;J&gt; Join&lt;T, J&gt; join(Property sourceProperty, Class&lt;J&gt; destinationEntityClass, Property destinationProperty) 3. 链式连接 此外，greenDAO允许跨多个表连接。 在这里，使用另一个连接和目标实体定义连接。 在这种情况下，第一连接的目的实体变为第二联接的起始实体。 用于链接连接的QueryBuilder API如下所示： 1234567891011/** * Expands the query to another entity type by using a JOIN. * The given sourceJoin&apos;s property is used to match the * given destinationProperty of the given destinationEntity. * Note that destination entity of the given join is used * as the source for the new join to add. In this way, * it is possible to compose complex &quot;join of joins&quot; across * several entities if required. */public &lt;J&gt; Join&lt;T, J&gt; join(Join&lt;?, T&gt; sourceJoin, Property sourceProperty, Class&lt;J&gt; destinationEntityClass, Property destinationProperty) 让我们看看另一个有三个实体的例子：城市，国家和大陆。 如果我们要查询欧洲所有人口至少100万的所有城市，它将如下所示： 123456QueryBuilder&lt;City&gt; qb = cityDao.queryBuilder().where(Properties.Population.ge(1000000));Join country = qb.join(Properties.CountryId, Country.class);Join continent = qb.join(country, CountryDao.Properties.ContinentId, Continent.class, ContinentDao.Properties.Id);continent.where(ContinentDao.Properties.Name.eq(&quot;Europe&quot;));List&lt;City&gt; bigEuropeanCities = qb.list(); 4. 自连接/树示例 连接也可以与引用单个实体的关系一起使用。 例如，我们想找到所有的人，他的祖父的名字是“林肯”。 让我们假设我们有一个具有指向同一个实体的fatherId属性的Person实体。 然后，查询构建如下： 12345QueryBuilder&lt;Person&gt; qb = personDao.queryBuilder();Join father = qb.join(Person.class, Properties.FatherId);Join grandfather = qb.join(father, Properties.FatherId, Person.class, Properties.Id);grandfather.where(Properties.Name.eq(&quot;Lincoln&quot;));List&lt;Person&gt; lincolnDescendants = qb.list(); 如您所见，连接是构建跨多个实体类型或关系的查询的强大工具。 实体之间的关系（一对多）1. 关系 数据库表可以使用1：1,1：N或N：M关系彼此相关。 如果你刚接触数据库关系，你需要在我们讨论ORM之前快速的恶补一下。 这里有一些关于数据库关系的网络链接。 第一篇 第二篇 第三篇 在greenDAO中，实体使用一对一或一对多关系。 例如，如果要在greenDAO中建模1：n关系，则将具有一对一关系和一对多关系。 但是，请注意，一对一和一对多关系不会彼此连接，因此你必须更新两者。 2. 构建一对一关系 @ToOne注解定义与另一个实体（一个实体对象）的关系。 将其应用于包含其他实体对象的属性。 在内部，greenDAO需要一个指向由joinProperty参数指定的目标实体的ID的附加属性。 如果此参数不存在，则会自动创建一个附加列来保存这个信息。 1234567891011121314@Entitypublic class Order { @Id private Long id; private long customerId; @ToOne(joinProperty = &quot;customerId&quot;) private Customer customer;} @Entitypublic class Customer { @Id private Long id;} 一对一关系的getter方法（在此示例中为getCustomer()）在其第一次调用时延迟解析目标实体。 后续调用将立即返回先前解析的对象。 注意，如果更改外键属性（这里为customerId），下一次对getter（getCustomer()）的调用将解析实体以获取更新的ID。 另外，如果设置了一个新实体（setCustomer（）），外键属性（customerId）也将被更新。 123456789Customer customerA = user.getCustomer(); // change the customer iduser.setCustomerId(customerIdB);// or set a customer with a different iduser.setCustomer(customerB); customerB = user.getCustomer();assert(customerA.getId() != customerB.getId()); 注意：要热加载一对一关系，请使用实体DAO类的loadDeep（）和queryDeep（）。 这将解析与单个数据库查询具有所有一对一关系的实体。 如果你总是访问相关实体，这将有助于性能的提高。 2. 构建一对多关系 @ToMany定义与一组其他实体（多个实体对象）的关系。 将此应用于表示目标实体列表的属性。 引用的实体必须有一个或多个属性指向拥有@ToMany的实体。 有三种可能性来指定关系映射，只使用其中一个即可： referencedJoinProperty参数：指定目标实体中指向此实体标识的“外键”属性的名称。 123456789101112131415@Entitypublic class Customer { @Id private Long id; @ToMany(referencedJoinProperty = &quot;customerId&quot;) @OrderBy(&quot;date ASC&quot;) private List&lt;Order&gt; orders;} @Entitypublic class Order { @Id private Long id; private Date date; private long customerId;} joinProperties参数：对于更复杂的关系，你可以指定一列@JoinProperty注解。 每个@JoinProperty需要原始实体中的源属性和目标实体中的引用属性。 123456789101112131415161718@Entitypublic class Customer { @Id private Long id; @Unique private String tag; @ToMany(joinProperties = { @JoinProperty(name = &quot;tag&quot;, referencedName = &quot;customerTag&quot;) }) @OrderBy(&quot;date ASC&quot;) private List&lt;Site&gt; orders;} @Entitypublic class Order { @Id private Long id; private Date date; @NotNull private String customerTag;} @JoinEntity：如果你正在执行涉及另一个连接实体/表的N：M（多对多）关系，请在属性上放置此附加注解。 123456789101112131415161718192021222324@Entitypublic class Product { @Id private Long id; @ToMany @JoinEntity( entity = JoinProductsWithOrders.class, sourceProperty = &quot;productId&quot;, targetProperty = &quot;orderId&quot; ) private List&lt;Order&gt; ordersWithThisProduct;} @Entitypublic class JoinProductsWithOrders { @Id private Long id; private Long productId; private Long orderId;} @Entitypublic class Order { @Id private Long id;} 一旦运行，插件将生成一个getter来解析被引用实体的列表。 例如在前两种情况下： 12// return all orders where customerId == customer.getId()List&lt;Order&gt; orders = customer.getOrders(); 3. 解析和更新对多关系 多对多关系在第一个请求上解析比较慢，然后将List对象缓存在实体中。 因此，后续采用get方法调用将不会查询数据库。 更新多对多关系需要一些额外的工作。 因为缓存了一对多列表，所以当将相关实体添加到数据库时，它们不会更新。 以下代码说明了这种行为： 12345678910111213141516// get the current list of orders for a customerList&lt;Order&gt; orders1 = customer.getOrders(); // insert a new order for this customerOrder order = new Order();order.setCustomerId(customer.getId());daoSession.insert(order); // get the list of orders againList&lt;Order&gt; orders2 = customer.getOrders(); // the (cached) list of orders was not updated// orders1 has the same size as orders2assert(orders1.size() == orders2.size);// orders1 is the same object as orders2assert(orders1.equals(orders2)); 因此，要添加新的相关实体，请将它们手动添加到源实体的多对多列表中，如下： 1234567891011// get the to-many list before inserting the new entity// otherwise the new entity might be in the list twiceList&lt;Order&gt; orders = customer.getOrders();// create the new entityOrder newOrder = ...// set the foreign key propertynewOrder.setCustomerId(customer.getId());// persist the new entitydaoSession.insert(newOrder);// add it to the to-many listorders.add(newOrder); 同样，你可以删除相关实体，如下： 12345List&lt;Order&gt; orders = customer.getOrders();// remove one of the orders from the databasedaoSession.delete(someOrder);// manually remove it from the to-many listorders.remove(someOrder); 添加，更新或删除许多相关实体时，可以使用重置方法清除缓存的列表。 然后下一个get将重新查询相关实体： 123// clear any cached list of related orderscustomer.resetOrders();List&lt;Order&gt; orders = customer.getOrders(); 4. 双向1：N关系 有时你想在两个方向上建立1：N关系。 在greenDAO中，你必须添加一对一和一对多关系才能实现此目的。 以下示例显示了客户和订单实体的完整建模，我们之前用作示例。 这次，我们使用customerId属性创建两个关系： 123456789101112131415161718@Entitypublic class Customer { @Id private Long id; @ToMany(referencedJoinProperty = &quot;customerId&quot;) @OrderBy(&quot;date ASC&quot;) private List&lt;Order&gt; orders;} @Entitypublic class Order { @Id private Long id; private Date date; private long customerId; @ToOne(joinProperty = &quot;customerId&quot;) private Customer customer;} 让我们假设我们有一个订单实体。 使用这两种关系，我们可以得到客户和客户所做的所有订单： 1List&lt;Order&gt; allOrdersOfCustomer = order.getCustomer().getOrders(); 5. 示例：建模树关系 您可以通过使用指向自身的一对一和多对一关系建模实体来建模树关系： 123456789101112@Entitypublic class TreeNode { @Id private Long id; private Long parentId; @ToOne(joinProperty = &quot;parentId&quot;) private TreeNode parent; @ToMany(referencedJoinProperty = &quot;parentId&quot;) private List&lt;TreeNode&gt; children;} 生成的实体允许您导航其父级和子级： 12TreeNode parent = entity.getParent();List&lt;TreeNode&gt; children = entity.getChildren(); 6. 更多示例 查看DaoExample项目以获取完整的Android应用示例。 此外，DaoTestEntityAnnotation项目附带了几个关系测试。 其中，除了其他示例和测试项目之外，可以用作进一步的示例。 自定义类型：将类和枚举映射到数据库值 自定义类型允许实体具有任何类型的属性。 默认情况下，greenDAO支持以下类型 12345678910boolean, Booleanint, Integershort, Shortlong, Longfloat, Floatdouble, Doublebyte, Bytebyte[]StringDate 1. 转换注解和属性转换器 要添加对自定义类型的支持，可以使用@Convert注释将它们映射到其中一种受支持的类型。 同时你还需要提供PropertyConverter实现。 例如，你可以使用自定义Color类在实体中定义颜色，并将其映射到整数。 或者你可以将流行的org.joda.time.DateTime从Joda Time映射到Long。 这是将枚举映射到整数的示例： 1234567891011121314151617181920212223242526272829303132333435363738@Entitypublic class User { @Id private Long id; @Convert(converter = RoleConverter.class, columnType = Integer.class) private Role role; public enum Role { DEFAULT(0), AUTHOR(1), ADMIN(2); final int id; Role(int id) { this.id = id; } } public static class RoleConverter implements PropertyConverter&lt;Role, Integer&gt; { @Override public Role convertToEntityProperty(Integer databaseValue) { if (databaseValue == null) { return null; } for (Role role : Role.values()) { if (role.id == databaseValue) { return role; } } return Role.DEFAULT; } @Override public Integer convertToDatabaseValue(Role entityProperty) { return entityProperty == null ? null : entityProperty.id; } }} 注意：如果你在实体类中定义自定义类型或转换器，它们必须是静态的。 不要忘记正确处理空值 - 通常，如果输入为null，则应返回null。 转换器的数据库类型意义上不是SQLite类型，而是由greenDAO提供的原始Java类型。 建议使用易于转换的基本类型（int，long，byte数组，String，…）。 注意：为了获得最佳性能，greenDAO将为所有转换使用单个转换器实例。 确保转换器除了无参数默认构造函数之外没有任何其他构造函数。 另外，使它线程安全，因为它可能在多个实体上并发调用。 2. 如何正确转换枚举 枚举在像实体这样的数据对象中使很常用的。 当持久化枚举时，有下面几个不错的方法： 不要持久化枚举的序号或名称：两者都不稳定，并且很有可能下次编辑枚举定义的时候就变化了。 使用stable ids：在你的枚举中定义一个保证稳定的自定义属性（整数或字符串）。 使用它来进行持久性映射。 未知值：定义一个UNKNOWN枚举值。 它可以用于处理空值或未知值。 这将允许你处理像旧的枚举值被删除而不会崩溃您的应用程序的情况。 3. 自定义类型在查询中的处理QueryBuilder不知道自定义类型。 您必须对查询使用原语类型（例如在WHERE参数中）。 还要注意，在数据库中完成的操作总是引用原始类型，例如在ORDER BY子句中。 数据库加密 greenDAO支持加密的数据库来保护敏感数据。 虽然较新版本的Android支持文件系统加密，但Android本身并不为数据库文件提供加密。 因此，如果攻击者获得对数据库文件的访问（例如通过利用安全缺陷或欺骗有根的设备的用户），攻击者可以访问该数据库内的所有数据。 使用受密码保护的加密数据库增加了额外的安全层。 它防止攻击者简单地打开数据库文件。 1. 使用自定义SQLite构建 因为Android不支持加密数据库，所以你需要在APK中捆绑SQLite的自定义构建。 这些定制构建包括CPU相关和本地代码。 所以你的APK大小将增加几个MByte。 因此，你应该只使用加密，如果你真的需要它。 2. 设置数据库加密 greenDAO直接支持带有绑定的SQLCipher。 SQLCipher是使用256位AES加密的SQLite的自定义构建。 2.1 添加SQLCipher依赖关系 请参阅SQLCipher for Android，了解如何向项目添加SQLCipher。 2.2 数据库初始化 确保使用DaoMaster中提供的OpenHelper的子类来创建数据库实例。 例如简单的DevOpenHelper，也在DaoMaster中提供。 然后，在创建数据库实例时，只需调用.getEncryptedWritableDb（）而不是.getWritableDb（）。 最后，像往常一样将数据库传递给DaoMaster： 1234567DevOpenHelper helper = new DevOpenHelper(this, &quot;notes-db-encrypted.db&quot;);Database db = helper.getEncryptedWritableDb(&quot;&lt;your-secret-password&gt;&quot;);daoSession = new DaoMaster(db).newSession();DevOpenHelper helper = new DevOpenHelper(this, &quot;notes-db-encrypted.db&quot;);Database db = helper.getEncryptedWritableDb(&quot;&lt;your-secret-password&gt;&quot;);daoSession = new DaoMaster(db).newSession(); 3. 数据库抽象 greenDAO对所有数据库交互使用一个小型的抽象层，因此支持标准和非标准的SQLite实现： Android的标准android.database.sqlite.SQLiteDatabase SQLCipher的net.sqlcipher.database.SQLiteDatabase 任何SQLite兼容的数据库，它可以实现 org.greenrobot.greendao.database.Database（例如SQLite的自定义构建） 这使您能够轻松地从标准数据库切换到加密数据库，因为在针对DaoSession和单个DAO时，代码将是相同的。 3.1 使用Robolectric进行单元测试 数据库抽象允许用Robolectric进行单元测试。 即使你的应用程序使用加密的数据库，你的测试也可以使用未加密的数据库。 Robolectric实现标准的SQLite API，没有办法加载自定义SQLite构建（Android二进制）。 因此，对于你的测试，在创建数据库实例时使用.getWritableDb（）而不是.getEncryptedWritableDb（）（见上文）。 3.2 SQLCipher的已知问题 SQLCipher是SQLite的自定义构建。 它的Android API与Android系统API有点分歧。 这里是我们注意到的问题（与greenDAO无关）： 抛出的异常不是类型android.database.SQLException（请参阅SQLcipher问题223） SQLCipher比最近的SQLiteDatabase实现锁定更多。 这不仅降低了并发性，而且增加了死锁的机会。 从SQLCipher 3.5.0开始，缺少Android归类（如LOCALIZED） 写在最后 个人翻译，用于后面查阅，若有不当请担待~ 原文链接： http://greenrobot.org/greendao/ 最后 关注「码道长」，了解最前沿的技术知识，抬高自己的天花板。","link":"/2017/02/21/《Android 开源库》 GreenDAO 用法详解（译文）/"}],"tags":[{"name":"Android基础","slug":"Android基础","link":"/tags/Android基础/"},{"name":"IDEA插件","slug":"IDEA插件","link":"/tags/IDEA插件/"},{"name":"Android Studio","slug":"Android-Studio","link":"/tags/Android-Studio/"},{"name":"配置","slug":"配置","link":"/tags/配置/"},{"name":"Angular","slug":"Angular","link":"/tags/Angular/"},{"name":"开发问题","slug":"开发问题","link":"/tags/开发问题/"},{"name":"工具","slug":"工具","link":"/tags/工具/"},{"name":"Linux","slug":"Linux","link":"/tags/Linux/"},{"name":"CentOS","slug":"CentOS","link":"/tags/CentOS/"},{"name":"Docker","slug":"Docker","link":"/tags/Docker/"},{"name":"Gitlab","slug":"Gitlab","link":"/tags/Gitlab/"},{"name":"Mysql","slug":"Mysql","link":"/tags/Mysql/"},{"name":"Tomcat","slug":"Tomcat","link":"/tags/Tomcat/"},{"name":"Flutter","slug":"Flutter","link":"/tags/Flutter/"},{"name":"Android实战","slug":"Android实战","link":"/tags/Android实战/"},{"name":"Gank.io","slug":"Gank-io","link":"/tags/Gank-io/"},{"name":"MacOS","slug":"MacOS","link":"/tags/MacOS/"},{"name":"Android源码","slug":"Android源码","link":"/tags/Android源码/"},{"name":"PowerDesign","slug":"PowerDesign","link":"/tags/PowerDesign/"},{"name":"PMDReader","slug":"PMDReader","link":"/tags/PMDReader/"},{"name":"微信公众号","slug":"微信公众号","link":"/tags/微信公众号/"},{"name":"Markdown","slug":"Markdown","link":"/tags/Markdown/"},{"name":"Android开源库","slug":"Android开源库","link":"/tags/Android开源库/"},{"name":"RxJava","slug":"RxJava","link":"/tags/RxJava/"},{"name":"虚拟化","slug":"虚拟化","link":"/tags/虚拟化/"},{"name":"Xen","slug":"Xen","link":"/tags/Xen/"},{"name":"Aandroid实战","slug":"Aandroid实战","link":"/tags/Aandroid实战/"},{"name":"WanANdroid","slug":"WanANdroid","link":"/tags/WanANdroid/"},{"name":"终端","slug":"终端","link":"/tags/终端/"},{"name":"Framework","slug":"Framework","link":"/tags/Framework/"},{"name":"多线程","slug":"多线程","link":"/tags/多线程/"},{"name":"开机动画","slug":"开机动画","link":"/tags/开机动画/"},{"name":"HAL","slug":"HAL","link":"/tags/HAL/"},{"name":"CodeStyle","slug":"CodeStyle","link":"/tags/CodeStyle/"},{"name":"Fragment","slug":"Fragment","link":"/tags/Fragment/"},{"name":"自定义View","slug":"自定义View","link":"/tags/自定义View/"},{"name":"布局控件","slug":"布局控件","link":"/tags/布局控件/"},{"name":"设计模式","slug":"设计模式","link":"/tags/设计模式/"},{"name":"NDK","slug":"NDK","link":"/tags/NDK/"},{"name":"屏幕适配","slug":"屏幕适配","link":"/tags/屏幕适配/"},{"name":"快捷键","slug":"快捷键","link":"/tags/快捷键/"},{"name":"动画","slug":"动画","link":"/tags/动画/"},{"name":"EditText","slug":"EditText","link":"/tags/EditText/"},{"name":"资源配置","slug":"资源配置","link":"/tags/资源配置/"},{"name":"四大组件","slug":"四大组件","link":"/tags/四大组件/"},{"name":"BroadcastReceiver","slug":"BroadcastReceiver","link":"/tags/BroadcastReceiver/"},{"name":"Drawable","slug":"Drawable","link":"/tags/Drawable/"},{"name":"MultiDex","slug":"MultiDex","link":"/tags/MultiDex/"},{"name":"框架","slug":"框架","link":"/tags/框架/"},{"name":"allowBackup","slug":"allowBackup","link":"/tags/allowBackup/"},{"name":"Smali","slug":"Smali","link":"/tags/Smali/"},{"name":"应用","slug":"应用","link":"/tags/应用/"},{"name":"MPAndroidChart","slug":"MPAndroidChart","link":"/tags/MPAndroidChart/"},{"name":"Kotlin","slug":"Kotlin","link":"/tags/Kotlin/"},{"name":"百度地图","slug":"百度地图","link":"/tags/百度地图/"},{"name":"聚合数据","slug":"聚合数据","link":"/tags/聚合数据/"},{"name":"开源库","slug":"开源库","link":"/tags/开源库/"},{"name":"系统源码","slug":"系统源码","link":"/tags/系统源码/"},{"name":"资源","slug":"资源","link":"/tags/资源/"},{"name":"译文","slug":"译文","link":"/tags/译文/"},{"name":"Realm","slug":"Realm","link":"/tags/Realm/"},{"name":"LeetCode","slug":"LeetCode","link":"/tags/LeetCode/"},{"name":"微信小程序","slug":"微信小程序","link":"/tags/微信小程序/"},{"name":"开源","slug":"开源","link":"/tags/开源/"},{"name":"局域网","slug":"局域网","link":"/tags/局域网/"},{"name":"Service","slug":"Service","link":"/tags/Service/"},{"name":"RecyclerView","slug":"RecyclerView","link":"/tags/RecyclerView/"},{"name":"文本","slug":"文本","link":"/tags/文本/"},{"name":"TabLayout","slug":"TabLayout","link":"/tags/TabLayout/"},{"name":"辅助工具","slug":"辅助工具","link":"/tags/辅助工具/"},{"name":"FileProvider","slug":"FileProvider","link":"/tags/FileProvider/"},{"name":"View","slug":"View","link":"/tags/View/"},{"name":"事件分发","slug":"事件分发","link":"/tags/事件分发/"},{"name":"手电筒","slug":"手电筒","link":"/tags/手电筒/"},{"name":"贪吃蛇","slug":"贪吃蛇","link":"/tags/贪吃蛇/"},{"name":"技术选型","slug":"技术选型","link":"/tags/技术选型/"},{"name":"源码分析","slug":"源码分析","link":"/tags/源码分析/"},{"name":"Retrofit","slug":"Retrofit","link":"/tags/Retrofit/"},{"name":"WebService","slug":"WebService","link":"/tags/WebService/"},{"name":"Flex","slug":"Flex","link":"/tags/Flex/"},{"name":"JetPack","slug":"JetPack","link":"/tags/JetPack/"},{"name":"Picasso","slug":"Picasso","link":"/tags/Picasso/"}],"categories":[{"name":"Android基础","slug":"Android基础","link":"/categories/Android基础/"},{"name":"Angular","slug":"Angular","link":"/categories/Angular/"},{"name":"运维","slug":"运维","link":"/categories/运维/"},{"name":"Flutter","slug":"Flutter","link":"/categories/Flutter/"},{"name":"Android系统","slug":"Android系统","link":"/categories/Android系统/"},{"name":"Android开源库","slug":"Android开源库","link":"/categories/Android开源库/"},{"name":"Android应用","slug":"Android应用","link":"/categories/Android应用/"},{"name":"Android源码","slug":"Android源码","link":"/categories/Android源码/"},{"name":"Android Studio","slug":"Android基础/Android-Studio","link":"/categories/Android基础/Android-Studio/"},{"name":"Android安全","slug":"Android安全","link":"/categories/Android安全/"},{"name":"Android进阶","slug":"Android进阶","link":"/categories/Android进阶/"},{"name":"Kotlin","slug":"Kotlin","link":"/categories/Kotlin/"},{"name":"LeetCode","slug":"LeetCode","link":"/categories/LeetCode/"},{"name":"微信小程序","slug":"微信小程序","link":"/categories/微信小程序/"}]}